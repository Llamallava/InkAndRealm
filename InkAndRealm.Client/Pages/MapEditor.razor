@page "/map-demo/{MapId:int}"
@using System
@using System.Net
@using System.Net.Http.Json
@using System.Linq
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Web
@using InkAndRealm.Shared
@using InkAndRealm.Client.State
@inject HttpClient Http
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject UserState UserState
@implements IDisposable

<PageTitle>Ink & Realm Map Editor</PageTitle>

<div class="container-fluid map-editor-page">
    <div class="map-editor-layout">
        <aside class="map-editor-sidebar">
            <div class="map-editor-sidebar-header">
                <div class="fw-semibold">Tools</div>
                <button class="btn btn-outline-secondary btn-sm" @onclick="GoHome">
                    Back
                </button>
            </div>
            <div class="btn-group-vertical w-100" role="group" aria-label="Tool selection">
                @foreach (var tool in ToolDefinitions)
                {
                    <button class="btn btn-sm @(_activeTool == tool.Tool ? "btn-primary" : "btn-outline-primary")"
                            disabled="@(tool.Tool == MapToolType.Undo && !CanUndo || tool.Tool == MapToolType.Redo && !CanRedo)"
                            @onclick="() => SelectTool(tool.Tool)">
                        @tool.Label
                    </button>
                }
            </div>
            <div class="map-editor-sidebar-section">
                <div class="small text-muted">Active Tool</div>
                <div class="fw-semibold">@ActiveToolDefinition.Label</div>
                <div class="small text-muted">@ActiveToolSummary</div>
            </div>
            <div class="map-editor-sidebar-section">
                <div class="d-flex align-items-center justify-content-between">
                    <div class="fw-semibold">Layers</div>
                    <button class="btn btn-sm btn-outline-secondary" @onclick="AddAreaLayer">
                        Add
                    </button>
                </div>
                <div class="btn-group-vertical w-100 mt-2" role="group" aria-label="Area layers">
                    @for (var i = 0; i < _areaLayers.Count; i += 1)
                    {
                        var layer = _areaLayers[i];
                        <button class="btn btn-sm map-layer-button @(_activeAreaLayer == layer ? "btn-primary" : "btn-outline-primary")"
                                @onclick="() => SelectAreaLayer(layer)">
                            <span>@GetLayerLabel(layer, i)</span>
                            <span class="map-layer-delete"
                                  role="button"
                                  title="Delete layer"
                                  aria-label="Delete layer"
                                  @onclick="() => PromptDeleteLayerAsync(layer)"
                                  @onclick:stopPropagation="true">
                                &#128465;
                            </span>
                        </button>
                    }
                </div>
            </div>
            <div class="map-editor-sidebar-section map-editor-sidebar-metrics">
                <div class="small text-muted">Last Placement</div>
                <div>@(_hasLastPlacement ? $"{_lastX:0}, {_lastY:0}" : "No placements yet.")</div>
                <div class="small text-muted mt-2">View</div>
                <div>@($"Zoom {_zoom * 100:0}% | Origin {_viewX:0}, {_viewY:0}")</div>
                <div class="small text-muted mt-2">Unsaved Items</div>
                <div>@PendingCount</div>
            </div>
            @if (_isSelectingRelationshipTarget)
            {
                <div class="mt-3 mb-0">
                    <button class="btn btn-outline-secondary btn-sm" @onclick="CancelRelationshipTargetSelection">
                        Cancel Target Selection
                    </button>
                </div>
            }
        </aside>

        <section class="map-editor-main">
            <div class="map-editor-topbar">
                @if (_activeTool == MapToolType.Eraser)
                {
                    <div class="map-editor-topbar-block">
                        <div class="small text-muted">Eraser Target</div>
                        <div class="btn-group btn-group-sm" role="group" aria-label="Eraser target selection">
                            @foreach (var target in EraserTargetDefinitions)
                            {
                                <button class="btn @(_eraserTarget == target.Target ? "btn-primary" : "btn-outline-primary")"
                                        @onclick="() => SelectEraserTarget(target.Target)">
                                    @target.Label
                                </button>
                            }
                        </div>
                    </div>
                }
                <div class="map-editor-topbar-block">
                    <div class="small text-muted">@ActiveStyleDefinition.MenuLabel</div>
                    <select class="form-select form-select-sm" @bind="SelectedPlacementStyle">
                        @foreach (var style in ActiveStyleDefinition.Styles)
                        {
                            <option value="@style">@style</option>
                        }
                    </select>
                </div>
                @if (ShowPointSize)
                {
                    <div class="map-editor-topbar-block">
                        <div class="small text-muted">Point Size (@($"{SelectedPointSize:0.0}x"))</div>
                        <input class="form-range"
                               type="range"
                               min="@PointSizeMin"
                               max="@PointSizeMax"
                               step="@PointSizeStep"
                               @bind="SelectedPointSize"
                               @bind:event="oninput" />
                    </div>
                }
                @if (ShowTitleSize)
                {
                    <div class="map-editor-topbar-block">
                        <div class="small text-muted">Title Size (@($"{SelectedTitleSize:0.0}x"))</div>
                        <input class="form-range"
                               type="range"
                               min="@TitleSizeMin"
                               max="@TitleSizeMax"
                               step="@TitleSizeStep"
                               @bind="SelectedTitleSize"
                               @bind:event="oninput" />
                    </div>
                }
                <div class="map-editor-topbar-block">
                    <div class="small text-muted">Brush Tightness</div>
                    <input class="form-range"
                           type="range"
                           min="1"
                           max="10"
                           step="1"
                           disabled="@(_activeTool != MapToolType.Brush)"
                           @bind="_brushTightness" />
                </div>
                <div class="map-editor-topbar-block">
                    <div class="small text-muted">Brush Size</div>
                    <input class="form-range"
                           type="range"
                           min="1"
                           max="10"
                           step="1"
                           disabled="@(_activeTool != MapToolType.Brush)"
                           @bind="_brushSize" />
                </div>
                <div class="map-editor-topbar-block">
                    <div class="small text-muted">Polygon Density</div>
                    <input class="form-range"
                           type="range"
                           min="1"
                           max="10"
                           step="1"
                           disabled="@(!ShowPolygonDensity)"
                           @bind="_polygonDensity" />
                </div>
                @if (ShowChaoticEdgesToggle)
                {
                    <div class="map-editor-topbar-block">
                        <div class="small text-muted">Chaotic Edges</div>
                        <div class="form-check form-switch">
                            <input class="form-check-input"
                                   type="checkbox"
                                   id="land-chaos-toggle"
                                   @bind="UseChaoticLandEdges" />
                            <label class="form-check-label" for="land-chaos-toggle">
                                @(_useChaoticLandEdges ? "On" : "Off")
                            </label>
                        </div>
                    </div>
                }
                <div class="map-editor-topbar-actions">
                    @if (_placementType == PlacementType.Land)
                    {
                        <button class="btn btn-outline-success btn-sm"
                                disabled="@(!CanGenerateStarterLandMass)"
                                @onclick="GenerateStarterLandMassAsync">
                            Starter Land
                        </button>
                    }
                    <button class="btn btn-outline-primary btn-sm"
                            disabled="@(_isLoading || !IsLoggedIn || !_hasMap)"
                            @onclick="OpenRelationshipTreeAsync">
                        Character Tree
                    </button>
                    <button class="btn btn-primary btn-sm"
                            disabled="@(PendingCount == 0 || _isSaving || !IsLoggedIn || !_hasMap)"
                            @onclick="SaveEditsAsync">
                        Save All
                    </button>
                    <button class="btn btn-outline-secondary btn-sm"
                            disabled="@(_isLoading)"
                            @onclick="ReloadAsync">
                        Reload
                    </button>
                </div>
            </div>

            <div class="map-editor-canvas-card">
                <div class="map-editor-canvas-shell">
                    <canvas id="@CanvasId"
                            width="1000"
                            height="600"
                            class="map-editor-canvas"
                            style="touch-action:none;"
                            @onmousedown="HandlePointerDown"
                            @onmousemove="HandlePointerMove"
                            @onmouseup="HandlePointerUp"
                            @onmouseleave="HandlePointerLeave"
                            @oncontextmenu="HandleContextMenu"
                            @oncontextmenu:preventDefault="true"
                            @onwheel="HandleWheel"
                            @onwheel:preventDefault="true">
                    </canvas>
                </div>
            </div>

            <div class="map-editor-bottombar">
                <div class="map-editor-bottombar-block">
                    <div class="small text-muted">Map Items</div>
                    <div class="btn-group map-editor-icon-group" role="group" aria-label="Map item selection">
                        @foreach (var placement in PlacementDefinitions)
                        {
                            <button class="btn map-editor-icon-button @(_placementType == placement.PlacementType ? "btn-primary" : "btn-outline-primary")"
                                    aria-label="@placement.Label"
                                    @onclick="() => SelectPlacement(placement.PlacementType)">
                                <img src="@placement.ImageUrl" alt="" />
                            </button>
                        }
                    </div>
                </div>
            </div>
        </section>
    </div>
</div>

@if (_isCharacterEditorOpen && _editingCharacter is not null)
{
    <div class="character-editor-overlay">
        <div class="character-editor-card">
            <div class="character-editor-header">
                <div>
                    <div class="fw-semibold">@(_isCharacterEditorReadOnly ? "Character Details (Read-only)" : "Character Details")</div>
                    <div class="small text-muted">
                        @(_isCharacterEditorReadOnly
                            ? "Switch to the Edit tool to modify character details."
                            : "Edits are unsaved until you click Save All.")
                    </div>
                </div>
                <button class="btn btn-outline-secondary btn-sm" @onclick="() => ClearEditSelection(true)">
                    Close
                </button>
            </div>
            <div class="character-editor-body">
                <div class="character-editor-row">
                    <label class="form-label">Type</label>
                    <select class="form-select form-select-sm"
                            @bind="EditingCharacterType"
                            disabled="@IsCharacterEditorReadOnly">
                        @foreach (var style in CharacterStyles)
                        {
                            <option value="@style">@style</option>
                        }
                    </select>
                </div>
                <div class="character-editor-row character-editor-coordinates">
                    <div>
                        <label class="form-label">X</label>
                        <input class="form-control form-control-sm"
                               type="number"
                               step="1"
                               min="0"
                               max="@MapWidth"
                               @bind="EditingCharacterX"
                               @bind:event="oninput"
                               readonly="@IsCharacterEditorReadOnly" />
                    </div>
                    <div>
                        <label class="form-label">Y</label>
                        <input class="form-control form-control-sm"
                               type="number"
                               step="1"
                               min="0"
                               max="@MapHeight"
                               @bind="EditingCharacterY"
                               @bind:event="oninput"
                               readonly="@IsCharacterEditorReadOnly" />
                    </div>
                </div>
                <div class="character-editor-row">
                    <label class="form-label">Name</label>
                    <input class="form-control"
                           maxlength="@CharacterFieldMaxLength"
                           @bind="EditingCharacterName"
                           @bind:event="oninput"
                           readonly="@IsCharacterEditorReadOnly" />
                </div>
                <div class="character-editor-row">
                    <label class="form-label">Background</label>
                    <textarea class="form-control"
                              rows="3"
                              maxlength="@CharacterFieldMaxLength"
                              @bind="EditingCharacterBackground"
                              @bind:event="oninput"
                              readonly="@IsCharacterEditorReadOnly"></textarea>
                </div>
                <div class="character-editor-row">
                    <label class="form-label">Occupation</label>
                    <textarea class="form-control"
                              rows="2"
                              maxlength="@CharacterFieldMaxLength"
                              @bind="EditingCharacterOccupation"
                              @bind:event="oninput"
                              readonly="@IsCharacterEditorReadOnly"></textarea>
                </div>
                <div class="character-editor-row">
                    <label class="form-label">Personality</label>
                    <textarea class="form-control"
                              rows="2"
                              maxlength="@CharacterFieldMaxLength"
                              @bind="EditingCharacterPersonality"
                              @bind:event="oninput"
                              readonly="@IsCharacterEditorReadOnly"></textarea>
                </div>
                @{
                    var editingCharacter = _editingCharacter!;
                    var pendingRelationships = GetPendingRelationshipsForCharacter(editingCharacter.Id);
                    var pendingRelationshipUpdates = GetPendingRelationshipUpdatesForCharacter(editingCharacter.Id);
                }
                <div class="character-editor-row">
                    <label class="form-label">Relationships</label>
                    @if (editingCharacter.Relationships is not null && editingCharacter.Relationships.Count > 0)
                    {
                        <div class="small">
                            @foreach (var relationship in editingCharacter.Relationships)
                            {
                                <div class="mb-2">
                                    <div class="fw-semibold">@GetRelationshipTargetLabel(relationship.TargetFeatureId, relationship.TargetFeatureType)</div>
                                    <div>@FormatRelationshipTypes(relationship.RelationshipTypes)</div>
                                    @if (!string.IsNullOrWhiteSpace(relationship.Description))
                                    {
                                        <div class="text-muted small">@relationship.Description</div>
                                    }
                                    @if (IsRelationshipUpdateStaged(relationship.Id))
                                    {
                                        <div class="text-muted small">Pending update (unsaved)</div>
                                    }
                                    @if (!IsCharacterEditorReadOnly)
                                    {
                                        <div class="d-flex gap-2 mt-1">
                                            <button class="btn btn-outline-secondary btn-sm"
                                                    type="button"
                                                    @onclick="() => BeginRelationshipEdit(relationship)">
                                                Edit
                                            </button>
                                            <button class="btn btn-outline-danger btn-sm"
                                                    type="button"
                                                    @onclick="() => DeleteExistingRelationship(relationship)">
                                                Delete
                                            </button>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    }
                    else
                    {
                        <div class="small text-muted">No relationships yet.</div>
                    }
                    @if (pendingRelationships.Count > 0)
                    {
                        <div class="small text-muted mt-2">Pending (unsaved)</div>
                        <div class="small">
                            @foreach (var relationship in pendingRelationships)
                            {
                                <div class="mb-2">
                                    <div class="fw-semibold">@GetRelationshipTargetLabel(relationship.TargetFeatureId, "Pending")</div>
                                    <div>@FormatRelationshipTypes(relationship.RelationshipTypes)</div>
                                    @if (!string.IsNullOrWhiteSpace(relationship.Description))
                                    {
                                        <div class="text-muted small">@relationship.Description</div>
                                    }
                                    @if (!IsCharacterEditorReadOnly)
                                    {
                                        <button class="btn btn-outline-danger btn-sm mt-1"
                                                type="button"
                                                @onclick="() => RemovePendingRelationship(relationship)">
                                            Delete
                                        </button>
                                    }
                                </div>
                            }
                        </div>
                    }
                    @if (pendingRelationshipUpdates.Count > 0)
                    {
                        <div class="small text-muted mt-2">Pending updates (unsaved)</div>
                        <div class="small">
                            @foreach (var relationship in pendingRelationshipUpdates)
                            {
                                <div class="mb-2">
                                    <div class="fw-semibold">@GetRelationshipTargetLabel(relationship.TargetFeatureId, "Pending Update")</div>
                                    <div>@FormatRelationshipTypes(relationship.RelationshipTypes)</div>
                                    @if (!string.IsNullOrWhiteSpace(relationship.Description))
                                    {
                                        <div class="text-muted small">@relationship.Description</div>
                                    }
                                    @if (!IsCharacterEditorReadOnly)
                                    {
                                        <button class="btn btn-outline-danger btn-sm mt-1"
                                                type="button"
                                                @onclick="() => DeletePendingRelationshipUpdate(relationship)">
                                            Delete
                                        </button>
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
                @if (!IsCharacterEditorReadOnly)
                {
                    @if (_editingRelationshipId is not null)
                    {
                        <div class="character-editor-row">
                            <label class="form-label">Edit Relationship</label>
                            <div class="small text-muted mb-2">
                                @GetRelationshipTargetLabel(_editingRelationshipTargetFeatureId, _editingRelationshipTargetFeatureType)
                            </div>
                            <input class="form-control mb-2"
                                   placeholder="Relationship types (comma separated)"
                                   @bind="_relationshipEditTypesInput"
                                   @bind:event="oninput" />
                            <textarea class="form-control mb-2"
                                      rows="2"
                                      placeholder="Description (optional)"
                                      @bind="_relationshipEditDescription"
                                      @bind:event="oninput"></textarea>
                            <div class="d-flex gap-2">
                                <button class="btn btn-outline-primary btn-sm" type="button" @onclick="ApplyRelationshipEdit">
                                    Update Relationship
                                </button>
                                <button class="btn btn-outline-secondary btn-sm" type="button" @onclick="CancelRelationshipEdit">
                                    Cancel
                                </button>
                            </div>
                        </div>
                    }
                    <div class="character-editor-row">
                        <label class="form-label">Add Relationship</label>
                        @if (_selectedRelationshipTarget is null)
                        {
                            <button class="btn btn-outline-primary btn-sm" type="button" @onclick="BeginRelationshipTargetSelection">
                                Select Relationship Target
                            </button>
                            <div class="small text-muted mt-2">Pick a saved feature on the map before entering relationship details.</div>
                        }
                        else
                        {
                            <div class="small text-muted mb-2">Target</div>
                            <div class="fw-semibold mb-2">@GetRelationshipTargetLabel(_selectedRelationshipTarget.TargetId, _selectedRelationshipTarget.IsCharacter ? "Character" : "Feature")</div>
                            <div class="d-flex gap-2 mb-2">
                                <button class="btn btn-outline-secondary btn-sm" type="button" @onclick="BeginRelationshipTargetSelection">
                                    Change Target
                                </button>
                                <button class="btn btn-outline-secondary btn-sm" type="button" @onclick="ClearSelectedRelationshipTarget">
                                    Clear Target
                                </button>
                            </div>
                            <input class="form-control mb-2"
                                   placeholder="Relationship types (comma separated)"
                                   @bind="_relationshipTypesInput"
                                   @bind:event="oninput" />
                            <textarea class="form-control mb-2"
                                      rows="2"
                                      placeholder="Description (optional)"
                                      @bind="_relationshipDescription"
                                      @bind:event="oninput"></textarea>
                            <div class="form-check mb-2">
                                <input class="form-check-input"
                                       type="checkbox"
                                       id="relationship-reciprocal-toggle"
                                       @bind="_relationshipCreateReciprocal" />
                                <label class="form-check-label" for="relationship-reciprocal-toggle">
                                    Make reciprocal (character targets only)
                                </label>
                            </div>
                            @if (_relationshipCreateReciprocal)
                            {
                                <input class="form-control mb-2"
                                       placeholder="Reciprocal types (comma separated, optional)"
                                       @bind="_relationshipReciprocalTypesInput"
                                       @bind:event="oninput" />
                                <textarea class="form-control mb-2"
                                          rows="2"
                                          placeholder="Reciprocal description (optional)"
                                          @bind="_relationshipReciprocalDescription"
                                          @bind:event="oninput"></textarea>
                            }
                            <button class="btn btn-outline-primary btn-sm" type="button" @onclick="AddSelectedRelationship">
                                Add Relationship
                            </button>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
}

@if (_isRelationshipTreeOpen)
{
    <div class="relationship-tree-overlay">
        <div class="relationship-tree-card">
            <div class="relationship-tree-header">
                <div>
                    <div class="fw-semibold">Character Tree</div>
                    <div class="small text-muted">Saved relationship data for this map.</div>
                </div>
                <div class="relationship-tree-header-actions">
                    <div class="btn-group btn-group-sm" role="group" aria-label="Character Tree zoom">
                        <button class="btn btn-outline-secondary"
                                type="button"
                                @onclick="ZoomOutRelationshipTree">-</button>
                        <button class="btn btn-outline-secondary"
                                type="button"
                                @onclick="ResetRelationshipTreeZoom">Reset</button>
                        <button class="btn btn-outline-secondary"
                                type="button"
                                @onclick="ZoomInRelationshipTree">+</button>
                    </div>
                    <div class="small text-muted">@($"{_relationshipTreeZoom * 100:0}%")</div>
                    <button class="btn btn-outline-secondary btn-sm" @onclick="CloseRelationshipTree">
                        Close
                    </button>
                </div>
            </div>
            <div class="relationship-tree-body">
                @if (_isRelationshipTreeLoading)
                {
                }
                else if (_relationshipTreeNodes.Count == 0)
                {
                    <div class="text-muted">No saved characters found for this map.</div>
                }
                else
                {
                    <div class="@RelationshipTreeCanvasShellClass"
                         @onmousedown="BeginRelationshipTreePan"
                         @onmousemove="UpdateRelationshipTreePan"
                         @onmouseup="EndRelationshipTreePan"
                         @onmouseleave="EndRelationshipTreePan"
                         @onmousedown:preventDefault="true"
                         @onwheel="HandleRelationshipTreeWheel"
                         @onwheel:preventDefault="true"
                         @onwheel:stopPropagation="true">
                        <svg class="relationship-tree-canvas"
                             viewBox="@RelationshipTreeViewBox"
                             preserveAspectRatio="xMidYMid meet">
                            <defs>
                                <marker id="relationship-tree-arrowhead"
                                        viewBox="0 0 10 10"
                                        refX="8"
                                        refY="5"
                                        markerWidth="7"
                                        markerHeight="7"
                                        orient="auto-start-reverse">
                                    <path d="M 0 0 L 10 5 L 0 10 z" class="relationship-tree-arrowhead" />
                                </marker>
                            </defs>
                            @foreach (var edge in _relationshipTreeMergedEdges)
                            {
                                if (!_relationshipTreeNodeLookup.TryGetValue(edge.NodeAId, out var nodeA)
                                    || !_relationshipTreeNodeLookup.TryGetValue(edge.NodeBId, out var nodeB))
                                {
                                    continue;
                                }

                                <line x1="@nodeA.X"
                                      y1="@nodeA.Y"
                                      x2="@nodeB.X"
                                      y2="@nodeB.Y"
                                      class="relationship-tree-edge"
                                      marker-start="@GetRelationshipTreeMarkerStart(edge)"
                                      marker-end="@GetRelationshipTreeMarkerEnd(edge)">
                                    <title>@GetRelationshipTreeEdgeTooltip(edge)</title>
                                </line>

                                @if (edge.AToB is not null)
                                {
                                    var labelPosition = GetRelationshipTreeLabelPosition(nodeA, nodeB, 0.36f, -12f);
                                    var labelText = GetRelationshipTreeEdgeLabel(edge.AToB);
                                    if (!string.IsNullOrWhiteSpace(labelText))
                                    {
                                        <foreignObject x="@(labelPosition.X - 62f)"
                                                       y="@(labelPosition.Y - 10f)"
                                                       width="124"
                                                       height="20">
                                            <div xmlns="http://www.w3.org/1999/xhtml"
                                                 class="relationship-tree-edge-label">@labelText</div>
                                        </foreignObject>
                                    }
                                }

                                @if (edge.BToA is not null)
                                {
                                    var labelPosition = GetRelationshipTreeLabelPosition(nodeB, nodeA, 0.36f, 12f);
                                    var labelText = GetRelationshipTreeEdgeLabel(edge.BToA);
                                    if (!string.IsNullOrWhiteSpace(labelText))
                                    {
                                        <foreignObject x="@(labelPosition.X - 62f)"
                                                       y="@(labelPosition.Y - 10f)"
                                                       width="124"
                                                       height="20">
                                            <div xmlns="http://www.w3.org/1999/xhtml"
                                                 class="relationship-tree-edge-label">@labelText</div>
                                        </foreignObject>
                                    }
                                }

                            }

                            @foreach (var node in _relationshipTreeNodes)
                            {
                                <g class="@GetRelationshipTreeNodeClass(node)"
                                   @onclick="() => SelectRelationshipTreeNode(node)">
                                    <circle cx="@node.X"
                                            cy="@node.Y"
                                            r="@GetRelationshipTreeNodeRadius(node)">
                                        <title>@GetRelationshipTreeNodeTooltip(node)</title>
                                    </circle>
                                    <foreignObject x="@(node.X - 65f)"
                                                   y="@(node.Y + GetRelationshipTreeNodeRadius(node) + 4f)"
                                                   width="130"
                                                   height="28">
                                        <div xmlns="http://www.w3.org/1999/xhtml"
                                             class="relationship-tree-node-label">@GetRelationshipTreeNodeShortLabel(node)</div>
                                    </foreignObject>
                                </g>
                            }
                        </svg>
                    </div>
                    <div class="small text-muted mt-2">
                        Use mouse wheel over this graph to zoom. Click a character node to open Character Details in read-only mode.
                    </div>
                }
            </div>
        </div>
    </div>
}

@code {
    private const string CanvasId = "map-demo-canvas";
    private List<TreeFeatureDto> _trees = new();
    private List<HouseFeatureDto> _houses = new();
    private List<CharacterFeatureDto> _characters = new();
    private List<TitleFeatureDto> _titles = new();
    private readonly List<TreeFeatureDto> _stagedTrees = new();
    private readonly List<HouseFeatureDto> _stagedHouses = new();
    private readonly List<CharacterFeatureDto> _stagedCharacters = new();
    private readonly List<TitleFeatureDto> _stagedTitles = new();
    private readonly List<AddCharacterRelationshipDto> _stagedRelationships = new();
    private readonly Dictionary<int, UpdateCharacterRelationshipDto> _updatedRelationships = new();
    private readonly Dictionary<int, (int SourceCharacterId, int TargetFeatureId)> _deletedRelationships = new();
    private const float MapWidth = 2000f;
    private const float MapHeight = 1200f;
    private const float MinZoom = 0.5f;
    private const float MaxZoom = 3f;
    private const float CanvasWidth = 1000f;
    private const float CanvasHeight = 600f;
    private const float RelationshipTreeCanvasWidth = 1400f;
    private const float RelationshipTreeCanvasHeight = 900f;
    private const float RelationshipTreeMinZoom = 1f;
    private const float RelationshipTreeMaxZoom = 4f;
    private const float RelationshipTreeZoomStep = 1.12f;
    private float _canvasClientWidth = CanvasWidth;
    private float _canvasClientHeight = CanvasHeight;
    private float _lastX;
    private float _lastY;
    private bool _hasLastPlacement;
    private float _viewX;
    private float _viewY;
    private float _zoom = 1f;
    private bool _isPanning;
    private float _panStartX;
    private float _panStartY;
    private float _panOriginX;
    private float _panOriginY;
    private bool _isPanCandidate;
    private float _panCandidateStartX;
    private float _panCandidateStartY;
    private bool _isLoading;
    private bool _isSaving;
    private bool _hasMap;
    private string _statusMessage = string.Empty;
    private bool _isRelationshipTreeOpen;
    private bool _isRelationshipTreeLoading;
    private string _relationshipTreeStatusMessage = string.Empty;
    private float _relationshipTreeZoom = 1f;
    private float _relationshipTreeViewX;
    private float _relationshipTreeViewY;
    private bool _isRelationshipTreePanning;
    private bool _relationshipTreeSuppressNodeClick;
    private float _relationshipTreePanStartClientX;
    private float _relationshipTreePanStartClientY;
    private float _relationshipTreePanOriginX;
    private float _relationshipTreePanOriginY;
    private readonly List<RelationshipTreeNode> _relationshipTreeNodes = new();
    private readonly List<RelationshipTreeMergedEdge> _relationshipTreeMergedEdges = new();
    private readonly Dictionary<int, RelationshipTreeNode> _relationshipTreeNodeLookup = new();
    private readonly List<UndoState> _undoStack = new();
    private readonly List<UndoState> _redoStack = new();
    private UndoBatchKind _undoBatchKind = UndoBatchKind.None;
    private bool _undoBatchPushed;
    private bool _isUndoing;
    private bool _isRedoing;
    private DotNetObjectReference<MapEditor>? _undoShortcutRef;
    private bool IsLoggedIn => UserState.CurrentUser is not null;
    private PlacementType _placementType = PlacementType.Tree;
    private readonly Dictionary<PlacementType, string> _selectedStyleByPlacement = new()
    {
        { PlacementType.Tree, "Oak" },
        { PlacementType.House, "Cottage" },
        { PlacementType.Character, "Commoner" },
        { PlacementType.Water, "Water" },
        { PlacementType.Land, "Land" },
        { PlacementType.Title, "Title" }
    };
    private MapToolType _activeTool = MapToolType.Point;
    private bool _isBrushing;
    private bool _isErasing;
    private float _brushLastX;
    private float _brushLastY;
    private int _brushStrokeCount;
    private int _brushTightness = 6;
    private int _brushSize = 5;
    private int _polygonDensity = 6;
    private float _brushCursorX;
    private float _brushCursorY;
    private bool _hasBrushCursor;
    private float _eraseLastX;
    private float _eraseLastY;
    private int _eraseCount;
    private const float BrushMinSpacing = 16f;
    private const float BrushMaxSpacing = 90f;
    private const float BrushMinRadius = 2f;
    private const float BrushMaxRadius = 24f;
    private const int BrushMaxPointsPerStamp = 220;
    private const float PointSizeMin = 0.1f;
    private const float PointSizeMax = 5f;
    private const float PointSizeStep = 0.1f;
    private const int TitleNameMaxLength = 128;
    private const int CharacterFieldMaxLength = 512;
    private const float TitleSizeMin = 0.5f;
    private const float TitleSizeMax = 3f;
    private const float TitleSizeStep = 0.1f;
    private const float EraseMinSpacing = 8f;
    private const float PolygonMinSpacing = 18f;
    private const float PolygonMaxSpacing = 120f;
    private const int PolygonMaxPoints = 1600;
    private const float LandChaosSegmentLength = 28f;
    private const float LandChaosAmplitude = 7f;
    private readonly List<AreaLayerDto> _areaLayers = new();
    private AreaLayerDto? _activeAreaLayer;
    private readonly List<MapPointDto> _activePolygonPoints = new();
    private readonly List<AreaPolygonDto> _waterPolygons = new();
    private readonly List<AreaPolygonDto> _stagedWaterPolygons = new();
    private readonly Dictionary<int, AreaPolygonDto> _editedWaterPolygons = new();
    private readonly HashSet<int> _deletedWaterPolygonIds = new();
    private readonly List<AreaPolygonDto> _landPolygons = new();
    private readonly List<AreaPolygonDto> _stagedLandPolygons = new();
    private readonly Dictionary<int, AreaPolygonDto> _editedLandPolygons = new();
    private readonly HashSet<int> _deletedLandPolygonIds = new();
    private readonly Dictionary<int, TreeFeatureDto> _editedTrees = new();
    private readonly Dictionary<int, HouseFeatureDto> _editedHouses = new();
    private readonly Dictionary<int, CharacterFeatureDto> _editedCharacters = new();
    private readonly Dictionary<int, TitleFeatureDto> _editedTitles = new();
    private readonly HashSet<int> _deletedTreeIds = new();
    private readonly HashSet<int> _deletedHouseIds = new();
    private readonly HashSet<int> _deletedCharacterIds = new();
    private readonly HashSet<int> _deletedTitleIds = new();
    private AreaPolygonDto? _editingPolygon;
    private List<MapPointDto>? _editingOriginalPoints;
    private int _editingPointIndex = -1;
    private int _editingEdgeIndex = -1;
    private bool _isDraggingEditPoint;
    private bool _isDraggingEditPolygon;
    private MapPointDto? _editingPolygonDragOrigin;
    private List<MapPointDto>? _editingPolygonDragOriginPoints;
    private EditingPointFeature? _editingPointFeature;
    private MapPointDto? _editingPointOriginalPosition;
    private bool _isDraggingEditPointFeature;
    private CharacterFeatureDto? _editingCharacter;
    private bool _isCharacterEditorOpen;
    private bool _isCharacterEditorReadOnly;
    private string _relationshipTypesInput = string.Empty;
    private string _relationshipDescription = string.Empty;
    private bool _relationshipCreateReciprocal;
    private string _relationshipReciprocalTypesInput = string.Empty;
    private string _relationshipReciprocalDescription = string.Empty;
    private string _relationshipStatusMessage = string.Empty;
    private int? _editingRelationshipId;
    private int _editingRelationshipTargetFeatureId;
    private string _editingRelationshipTargetFeatureType = string.Empty;
    private string _relationshipEditTypesInput = string.Empty;
    private string _relationshipEditDescription = string.Empty;
    private bool _isSelectingRelationshipTarget;
    private CharacterFeatureDto? _relationshipSourceCharacter;
    private RelationshipTargetSelection? _selectedRelationshipTarget;
    private MapToolType _relationshipReturnTool;
    private PlacementType _relationshipReturnPlacement;
    private bool _relationshipReturnReadOnly;
    private EditingTitleFeature? _editingTitleFeature;
    private MapPointDto? _editingTitleOriginalPosition;
    private bool _isDraggingTitleFeature;
    private EraserTarget _eraserTarget = EraserTarget.All;
    private bool _useChaoticLandEdges = true;
    private int PendingCount => _stagedTrees.Count
        + _stagedHouses.Count
        + _stagedCharacters.Count
        + _stagedTitles.Count
        + _stagedWaterPolygons.Count
        + _editedWaterPolygons.Count
        + _deletedWaterPolygonIds.Count
        + _stagedLandPolygons.Count
        + _editedLandPolygons.Count
        + _deletedLandPolygonIds.Count
        + _editedTrees.Count
        + _editedHouses.Count
        + _editedCharacters.Count
        + _editedTitles.Count
        + _stagedRelationships.Count
        + _updatedRelationships.Count
        + _deletedRelationships.Count
        + _deletedTreeIds.Count
        + _deletedHouseIds.Count
        + _deletedCharacterIds.Count
        + _deletedTitleIds.Count;
    private bool CanUndo => _undoStack.Count > 0;
    private bool CanRedo => _redoStack.Count > 0;
    [Parameter] public int MapId { get; set; }
    private const float PanDragThreshold = 6f;
    private static readonly IReadOnlyList<string> TreeStyles = new List<string>
    {
        "Oak",
        "Pine",
        "Birch",
        "Palm"
    };
    private static readonly IReadOnlyList<string> HouseStyles = new List<string>
    {
        "Cottage",
        "Cabin",
        "Manor"
    };
    private static readonly IReadOnlyList<string> CharacterStyles = new List<string>
    {
        "Commoner"
    };
    private static readonly IReadOnlyList<string> WaterStyles = new List<string>
    {
        "Water"
    };
    private static readonly IReadOnlyList<string> LandStyles = new List<string>
    {
        "Land"
    };
    private static readonly IReadOnlyList<string> TitleStyles = new List<string>
    {
        "Title"
    };
    private static readonly IReadOnlyList<PlacementDefinition> PlacementDefinitions = new List<PlacementDefinition>
    {
        new(PlacementType.Tree, "Tree", "/assets/Summer%20Set/tree_1.png"),
        new(PlacementType.House, "House", "/assets/Summer%20Set/building_2.png"),
        new(PlacementType.Character, "Character", "/assets/character-placeholder.svg"),
        new(PlacementType.Title, "Title", "/assets/Summer%20Set/decor_1.png"),
        new(PlacementType.Land, "Land", "/assets/Summer%20Set/land_1.png"),
        new(PlacementType.Water, "Water", "/assets/Summer%20Set/river.png")
    };
    private static readonly IReadOnlyList<EraserTargetDefinition> EraserTargetDefinitions = new List<EraserTargetDefinition>
    {
        new(EraserTarget.All, "All"),
        new(EraserTarget.Tree, "Trees"),
        new(EraserTarget.House, "Houses"),
        new(EraserTarget.Character, "Characters"),
        new(EraserTarget.Land, "Land"),
        new(EraserTarget.Water, "Water")
    };
    private static readonly IReadOnlyList<FeatureStyleDefinition> FeatureStyleDefinitions = new List<FeatureStyleDefinition>
    {
        new(PlacementType.Tree, "Tree Style", TreeStyles),
        new(PlacementType.House, "House Style", HouseStyles),
        new(PlacementType.Character, "Character Style", CharacterStyles),
        new(PlacementType.Title, "Title", TitleStyles),
        new(PlacementType.Land, "Land Type", LandStyles),
        new(PlacementType.Water, "Water Type", WaterStyles)
    };
    private readonly Dictionary<PlacementType, float> _pointSizeByPlacement = new()
    {
        { PlacementType.Tree, 1f },
        { PlacementType.House, 1f },
        { PlacementType.Character, 1f }
    };
    private static readonly IReadOnlyList<ToolDefinition> ToolDefinitions = new List<ToolDefinition>
    {
        new(MapToolType.Pointer, "Pointer", "Pan the map or click a character to view details.", true),
        new(MapToolType.Point, "Point", "Place one feature per click.", true),
        new(MapToolType.Brush, "Brush", "Paint features while dragging across the map.", true),
        new(MapToolType.Polygon, "Polygon", "Fill a polygonal area with a feature.", true),
        new(MapToolType.Eraser, "Eraser", "Remove a feature from the map.", true),
        new(MapToolType.Edit, "Edit", "Move or update an existing feature.", true),
        new(MapToolType.Duplicate, "Duplicate", "Clone an existing feature.", true),
        new(MapToolType.Undo, "Undo", "Undo the most recent change.", true),
        new(MapToolType.Redo, "Redo", "Redo the most recent undone change.", true)
    };
    private ToolDefinition ActiveToolDefinition => ToolDefinitions.First(tool => tool.Tool == _activeTool);
    private string ActiveToolSummary => ActiveToolDefinition.IsImplemented
        ? _activeTool == MapToolType.Brush
            ? $"{ActiveToolDefinition.Description} (tightness {_brushTightness}/10, size {_brushSize}/10)."
            : _activeTool == MapToolType.Polygon && IsPointPlacement(_placementType) && _placementType != PlacementType.Character
                ? $"{ActiveToolDefinition.Description} (density {_polygonDensity}/10)."
            : ActiveToolDefinition.Description
        : $"{ActiveToolDefinition.Description} (coming soon).";
    private string ActiveAreaLayerLabel => _activeAreaLayer is null ? "None" : GetLayerLabel(_activeAreaLayer);
    private FeatureStyleDefinition ActiveStyleDefinition
        => FeatureStyleDefinitions.First(definition => definition.PlacementType == _placementType);
    private bool ShowPolygonDensity => _activeTool == MapToolType.Polygon
        && IsPointPlacement(_placementType)
        && _placementType != PlacementType.Character;
    private bool ShowPointSize => IsPointPlacement(_placementType) && _placementType != PlacementType.Character;
    private bool ShowTitleSize => _placementType == PlacementType.Title;
    private bool ShowChaoticEdgesToggle => _placementType == PlacementType.Land;
    private bool CanGenerateStarterLandMass => _placementType == PlacementType.Land && !_isLoading && !_isSaving && _hasMap;
    private string SelectedPlacementStyle
    {
        get => GetStyleForPlacement(_placementType);
        set => _selectedStyleByPlacement[_placementType] = value;
    }
    private float SelectedPointSize
    {
        get => GetPointSizeForPlacement(_placementType);
        set => SetPointSizeForPlacement(_placementType, value);
    }
    private float _selectedTitleSize = 1f;
    private float SelectedTitleSize
    {
        get => _selectedTitleSize;
        set
        {
            var normalized = NormalizeTitleSize(value);
            _selectedTitleSize = normalized;
            if (_editingTitleFeature is not null)
            {
                _editingTitleFeature.Title.Size = normalized;
                TrackEditedTitleFeature(_editingTitleFeature);
                _ = InvokeAsync(DrawAsync);
            }
        }
    }
    private bool UseChaoticLandEdges
    {
        get => _useChaoticLandEdges;
        set
        {
            if (_useChaoticLandEdges == value)
            {
                return;
            }

            _useChaoticLandEdges = value;
            _ = InvokeAsync(DrawAsync);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        UserState.Changed += OnUserChanged;
        EnsureAreaLayers();
        await LoadMapAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await UpdateCanvasClientSizeAsync();
            _undoShortcutRef ??= DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("inkAndRealmDemo.registerUndoShortcut", CanvasId, _undoShortcutRef);
            await DrawAsync();
        }
    }

    private async Task HandlePointerDown(MouseEventArgs args)
    {
        if (!ActiveToolDefinition.IsImplemented)
        {
            _statusMessage = $"{ActiveToolDefinition.Label} tool is not available yet.";
            return;
        }

        if (_isSelectingRelationshipTarget)
        {
            if (args.Button != 0)
            {
                return;
            }

            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            HandleRelationshipTargetSelection(mapX, mapY);
            return;
        }

        if (_activeTool == MapToolType.Pointer)
        {
            if (args.Button != 0)
            {
                return;
            }

            BeginPanCandidate(args);
            return;
        }

        if (_activeTool == MapToolType.Point)
        {
            BeginPanCandidate(args);
            return;
        }

        if (_activeTool == MapToolType.Brush)
        {
            if (args.Button != 0)
            {
                return;
            }

            if (_placementType == PlacementType.Character)
            {
                _statusMessage = "Characters can only be placed with the Point tool.";
                return;
            }

            if (_placementType == PlacementType.Title)
            {
                _statusMessage = "Titles can only be placed with the Point or Polygon tool.";
                return;
            }

            if (_placementType == PlacementType.Land)
            {
                _statusMessage = "Land can only be placed with the Polygon tool.";
                return;
            }

            if (_placementType == PlacementType.Water)
            {
                _statusMessage = "Water can only be placed with the Polygon tool.";
                return;
            }

            await StartBrushAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Polygon)
        {
            if (args.Button != 0)
            {
                return;
            }

            if (_placementType == PlacementType.Character)
            {
                _statusMessage = "Characters can only be placed with the Point tool.";
                return;
            }

            if (TryGetMapPoint(args, out var mapX, out var mapY))
            {
                EnsureAreaLayers();
                _activePolygonPoints.Add(new MapPointDto { X = mapX, Y = mapY });
                _statusMessage = $"Polygon point added ({_activePolygonPoints.Count}).";
                await DrawAsync();
            }
            return;
        }

        if (_activeTool == MapToolType.Eraser)
        {
            if (args.Button != 0)
            {
                return;
            }

            await StartEraserAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Edit)
        {
            if (args.Button != 0)
            {
                return;
            }

            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            var hitRadius = GetEditHitRadius();
            AreaPolygonDto? polygon = _editingPolygon;
            if (polygon is not null)
            {
                var pointIndex = FindPointIndex(polygon, mapX, mapY, hitRadius);
                if (pointIndex >= 0)
                {
                    _editingPointIndex = pointIndex;
                    _isDraggingEditPoint = true;
                    _statusMessage = IsEditingTitlePolygon()
                        ? "Adjusting title vertex..."
                        : "Adjusting polygon point...";
                    return;
                }

                if (IsPointNearPolygonCenter(polygon, mapX, mapY, hitRadius))
                {
                    BeginPolygonDrag(mapX, mapY);
                    _statusMessage = IsEditingTitlePolygon()
                        ? "Moving title area..."
                        : "Moving polygon...";
                    await DrawAsync();
                    return;
                }
            }

            var titlePolygon = FindTitlePolygonAtPoint(mapX, mapY, hitRadius, out var titlePointIndex, out var titleEdgeIndex);
            if (titlePolygon is not null)
            {
                ClearEditSelection(true);
                BeginUndoBatch(UndoBatchKind.Edit);
                _editingTitleFeature = titlePolygon;
                _editingTitleOriginalPosition = new MapPointDto { X = titlePolygon.Title.X, Y = titlePolygon.Title.Y };
                _editingPolygon = BuildTitlePolygon(titlePolygon.Title);
                _editingOriginalPoints = titlePolygon.Title.Points
                    .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                    .ToList();
                _editingPointIndex = -1;
                _editingEdgeIndex = -1;
                _isDraggingEditPoint = false;
                _isDraggingTitleFeature = false;
                _selectedTitleSize = NormalizeTitleSize(titlePolygon.Title.Size);

                if (titlePointIndex >= 0)
                {
                    _editingPointIndex = titlePointIndex;
                    _isDraggingEditPoint = true;
                    _statusMessage = "Adjusting title vertex...";
                    await DrawAsync();
                    return;
                }

                if (titleEdgeIndex >= 0)
                {
                    var closestPoint = GetClosestPointOnSegment(_editingPolygon, titleEdgeIndex, mapX, mapY);
                    var insertIndex = titleEdgeIndex + 1;
                    PushUndoState();
                    _editingPolygon.Points.Insert(insertIndex, closestPoint);
                    _editingPointIndex = insertIndex;
                    _editingEdgeIndex = -1;
                    _isDraggingEditPoint = true;
                    _statusMessage = "Title vertex added. Drag to position.";
                    await DrawAsync();
                    return;
                }

                _statusMessage = "Title area selected. Drag a point or center to edit; right-click to edit name.";
                await DrawAsync();
                return;
            }

            if (_placementType == PlacementType.Title)
            {
                var titleFeature = FindTitleFeatureAtPoint(mapX, mapY, hitRadius);
                if (titleFeature is not null)
                {
                    ClearEditSelection(true);
                    if (!titleFeature.Title.TargetFeatureId.HasValue)
                    {
                        BeginUndoBatch(UndoBatchKind.Edit);
                    }
                    _editingTitleFeature = titleFeature;
                    _editingTitleOriginalPosition = new MapPointDto { X = titleFeature.Title.X, Y = titleFeature.Title.Y };
                    _isDraggingTitleFeature = CanDragTitle(titleFeature.Title);
                    _selectedTitleSize = NormalizeTitleSize(titleFeature.Title.Size);
                    if (titleFeature.Title.Points is not null && titleFeature.Title.Points.Count >= 3)
                    {
                        _editingPolygon = BuildTitlePolygon(titleFeature.Title);
                        _editingOriginalPoints = titleFeature.Title.Points
                            .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                            .ToList();
                        _editingPointIndex = -1;
                        _editingEdgeIndex = -1;
                        var titleAreaPolygon = _editingPolygon;
                        if (titleAreaPolygon is not null && IsPointNearPolygonCenter(titleAreaPolygon, mapX, mapY, hitRadius))
                        {
                            BeginPolygonDrag(mapX, mapY);
                            _statusMessage = "Moving title area...";
                        }
                        else
                        {
                            _statusMessage = "Title area selected. Drag a point or center to edit; right-click to edit name.";
                        }
                    }
                    else
                    {
                        _statusMessage = _isDraggingTitleFeature
                            ? "Moving title..."
                            : "Title selected. Right-click to edit name.";
                    }
                    await DrawAsync();
                    return;
                }
            }

            var pointFeature = FindPointFeatureAtPoint(mapX, mapY, hitRadius);
            if (pointFeature is not null)
            {
                ClearEditSelection(true);
                _editingPointFeature = pointFeature;
                _editingPointOriginalPosition = GetPointFeaturePosition(pointFeature);
                if (pointFeature.Character is not null)
                {
                    OpenCharacterEditor(pointFeature.Character, readOnly: false, resetRelationshipForm: true);
                    _statusMessage = "Character selected. Edit details and close when done.";
                    await DrawAsync();
                    return;
                }

                BeginUndoBatch(UndoBatchKind.Edit);
                _isDraggingEditPointFeature = true;
                _statusMessage = "Moving point feature...";
                await DrawAsync();
                return;
            }

            if (_placementType != PlacementType.Title)
            {
                var titleFeature = FindTitleFeatureAtPoint(mapX, mapY, hitRadius);
                if (titleFeature is not null)
                {
                    ClearEditSelection(true);
                    if (!titleFeature.Title.TargetFeatureId.HasValue)
                    {
                        BeginUndoBatch(UndoBatchKind.Edit);
                    }
                    _editingTitleFeature = titleFeature;
                    _editingTitleOriginalPosition = new MapPointDto { X = titleFeature.Title.X, Y = titleFeature.Title.Y };
                    _isDraggingTitleFeature = CanDragTitle(titleFeature.Title);
                    _selectedTitleSize = NormalizeTitleSize(titleFeature.Title.Size);
                    if (titleFeature.Title.Points is not null && titleFeature.Title.Points.Count >= 3)
                    {
                        _editingPolygon = BuildTitlePolygon(titleFeature.Title);
                        _editingOriginalPoints = titleFeature.Title.Points
                            .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                            .ToList();
                        _editingPointIndex = -1;
                        _editingEdgeIndex = -1;
                        var titleAreaPolygon = _editingPolygon;
                        if (titleAreaPolygon is not null && IsPointNearPolygonCenter(titleAreaPolygon, mapX, mapY, hitRadius))
                        {
                            BeginPolygonDrag(mapX, mapY);
                            _statusMessage = "Moving title area...";
                        }
                        else
                        {
                            _statusMessage = "Title area selected. Drag a point or center to edit; right-click to edit name.";
                        }
                    }
                    else
                    {
                        _statusMessage = _isDraggingTitleFeature
                            ? "Moving title..."
                            : "Title selected. Right-click to edit name.";
                    }
                    await DrawAsync();
                    return;
                }
            }

            if (IsPointPlacement(_placementType))
            {
                return;
            }

            if (polygon is null)
            {
                polygon = FindPolygonAtPoint(mapX, mapY);
            }

            if (polygon is not null)
            {
                _editingPolygon = polygon;
                _editingOriginalPoints = polygon.Points
                    .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                    .ToList();
                BeginUndoBatch(UndoBatchKind.Edit);

                if (IsPointNearPolygonCenter(polygon, mapX, mapY, hitRadius))
                {
                    BeginPolygonDrag(mapX, mapY);
                    _statusMessage = "Moving polygon...";
                    await DrawAsync();
                    return;
                }

                var edgeIndex = FindEdgeIndex(polygon, mapX, mapY, hitRadius);
                if (edgeIndex >= 0)
                {
                    var closestPoint = GetClosestPointOnSegment(polygon, edgeIndex, mapX, mapY);
                    var insertIndex = edgeIndex + 1;
                    PushUndoState();
                    polygon.Points.Insert(insertIndex, closestPoint);
                    _editingPointIndex = insertIndex;
                    _editingEdgeIndex = -1;
                    _isDraggingEditPoint = true;
                    _statusMessage = "Vertex added. Drag to position.";
                    await DrawAsync();
                    return;
                }

                _editingPointIndex = -1;
                _editingEdgeIndex = -1;
                _isDraggingEditPoint = false;
                _statusMessage = "Polygon selected. Drag a point or center to edit.";
                await DrawAsync();
                return;
            }

            if (_editingPolygon is not null || _editingPointFeature is not null)
            {
                ClearEditSelection(false);
                _statusMessage = "Edit selection cleared.";
                await DrawAsync();
            }
            return;
        }

        if (_activeTool == MapToolType.Duplicate)
        {
            if (args.Button != 0)
            {
                return;
            }

            await DuplicateFeatureAsync(args);
            return;
        }

        _statusMessage = $"{ActiveToolDefinition.Label} tool is not available yet.";
    }

    private async Task HandlePointerMove(MouseEventArgs args)
    {
        if (_isPanning && (_activeTool == MapToolType.Pointer || _activeTool == MapToolType.Point))
        {
            UpdatePan(args);
            await DrawAsync();
            return;
        }

        if (_isPanCandidate && (_activeTool == MapToolType.Point || _activeTool == MapToolType.Pointer))
        {
            var dx = (float)args.OffsetX - _panCandidateStartX;
            var dy = (float)args.OffsetY - _panCandidateStartY;
            if ((dx * dx) + (dy * dy) >= (PanDragThreshold * PanDragThreshold))
            {
                StartPanFromCandidate();
                UpdatePan(args);
                await DrawAsync();
            }
            return;
        }

        if (_activeTool == MapToolType.Brush && _isBrushing)
        {
            await ContinueBrushAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Eraser && _isErasing)
        {
            await ContinueEraserAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPointFeature && _editingPointFeature is not null)
        {
            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            if (_undoBatchKind == UndoBatchKind.Edit && !_undoBatchPushed && _editingPointOriginalPosition is not null)
            {
                if (MathF.Abs(mapX - _editingPointOriginalPosition.X) > 0.01f
                    || MathF.Abs(mapY - _editingPointOriginalPosition.Y) > 0.01f)
                {
                    PushUndoState();
                }
            }

            UpdatePointFeaturePosition(_editingPointFeature, mapX, mapY);
            await DrawAsync();
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingTitleFeature && _editingTitleFeature is not null)
        {
            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            if (!_editingTitleFeature.Title.TargetFeatureId.HasValue)
            {
                if (_undoBatchKind == UndoBatchKind.Edit && !_undoBatchPushed && _editingTitleOriginalPosition is not null)
                {
                    if (MathF.Abs(mapX - _editingTitleOriginalPosition.X) > 0.01f
                        || MathF.Abs(mapY - _editingTitleOriginalPosition.Y) > 0.01f)
                    {
                        PushUndoState();
                    }
                }

                _editingTitleFeature.Title.X = mapX;
                _editingTitleFeature.Title.Y = mapY;
                await DrawAsync();
            }
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPoint && _editingPolygon is not null && _editingPointIndex >= 0)
        {
            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            if (_undoBatchKind == UndoBatchKind.Edit && !_undoBatchPushed && _editingOriginalPoints is not null)
            {
                var shouldPush = true;
                if (_editingPointIndex >= 0 && _editingPointIndex < _editingOriginalPoints.Count)
                {
                    var original = _editingOriginalPoints[_editingPointIndex];
                    shouldPush = MathF.Abs(mapX - original.X) > 0.01f || MathF.Abs(mapY - original.Y) > 0.01f;
                }

                if (shouldPush)
                {
                    PushUndoState();
                }
            }

            _editingPolygon.Points[_editingPointIndex] = new MapPointDto { X = mapX, Y = mapY };
            await DrawAsync();
            return;
        }

        if (_activeTool == MapToolType.Edit
            && _isDraggingEditPolygon
            && _editingPolygon is not null
            && _editingPolygonDragOrigin is not null
            && _editingPolygonDragOriginPoints is not null)
        {
            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            var dx = mapX - _editingPolygonDragOrigin.X;
            var dy = mapY - _editingPolygonDragOrigin.Y;

            if (_undoBatchKind == UndoBatchKind.Edit
                && !_undoBatchPushed
                && (MathF.Abs(dx) > 0.01f || MathF.Abs(dy) > 0.01f))
            {
                PushUndoState();
            }

            var pointCount = Math.Min(_editingPolygon.Points.Count, _editingPolygonDragOriginPoints.Count);
            for (var i = 0; i < pointCount; i += 1)
            {
                var original = _editingPolygonDragOriginPoints[i];
                _editingPolygon.Points[i] = new MapPointDto
                {
                    X = original.X + dx,
                    Y = original.Y + dy
                };
            }

            await DrawAsync();
            return;
        }

        if (_activeTool == MapToolType.Edit && !_isDraggingEditPoint && !_isDraggingEditPolygon)
        {
            var previousEdge = _editingEdgeIndex;
            if (_editingPolygon is not null && TryGetMapPoint(args, out var mapX, out var mapY))
            {
                _editingEdgeIndex = FindEdgeIndex(_editingPolygon, mapX, mapY, GetEditHitRadius());
            }
            else
            {
                _editingEdgeIndex = -1;
            }

            if (previousEdge != _editingEdgeIndex)
            {
                await DrawAsync();
            }
        }

        if (_activeTool == MapToolType.Brush && !_isBrushing)
        {
            var wasVisible = _hasBrushCursor;
            var previousX = _brushCursorX;
            var previousY = _brushCursorY;
            _hasBrushCursor = TryGetMapPoint(args, out _brushCursorX, out _brushCursorY);

            var moved = _hasBrushCursor
                && (MathF.Abs(previousX - _brushCursorX) > 0.5f || MathF.Abs(previousY - _brushCursorY) > 0.5f);

            if (wasVisible != _hasBrushCursor || moved)
            {
                await DrawAsync();
            }
            return;
        }

        return;
    }

    private async Task HandlePointerUp(MouseEventArgs args)
    {
        if (_isPanning && (_activeTool == MapToolType.Pointer || _activeTool == MapToolType.Point))
        {
            _isPanning = false;
            _isPanCandidate = false;
            return;
        }

        if (_isPanCandidate && _activeTool == MapToolType.Point)
        {
            _isPanCandidate = false;
            await HandlePointToolAsync(args);
            return;
        }

        if (_isPanCandidate && _activeTool == MapToolType.Pointer)
        {
            _isPanCandidate = false;
            await HandlePointerToolClickAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPolygon)
        {
            _isDraggingEditPolygon = false;
            _editingPolygonDragOrigin = null;
            _editingPolygonDragOriginPoints = null;
            _statusMessage = IsEditingTitlePolygon()
                ? "Title area updated. Right-click to confirm."
                : "Polygon updated. Right-click to confirm.";
            await DrawAsync();
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPoint)
        {
            _isDraggingEditPoint = false;
            _statusMessage = IsEditingTitlePolygon()
                ? "Title vertex updated. Right-click to confirm."
                : "Polygon point updated. Right-click to confirm.";
            return;
        }

        if (_activeTool == MapToolType.Brush && _isBrushing)
        {
            _isBrushing = false;
            _hasBrushCursor = false;
            _statusMessage = _brushStrokeCount == 0
                ? "Brush stroke canceled."
                : $"Brush stroke placed ({_brushStrokeCount} item{(_brushStrokeCount == 1 ? string.Empty : "s")}).";
            EndUndoBatch(_brushStrokeCount > 0);
            return;
        }

        if (_activeTool == MapToolType.Eraser && _isErasing)
        {
            StopEraser();
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPointFeature)
        {
            _isDraggingEditPointFeature = false;
            _statusMessage = "Point feature updated. Right-click to confirm.";
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingTitleFeature)
        {
            _isDraggingTitleFeature = false;
            _statusMessage = "Title updated. Right-click to confirm.";
            return;
        }

        return;
    }

    private async Task HandleContextMenu(MouseEventArgs args)
    {
        if (_activeTool == MapToolType.Edit)
        {
            if (_editingTitleFeature is not null)
            {
                var updated = false;
                if (IsEditingTitlePolygon())
                {
                    TrackEditedTitleFeature(_editingTitleFeature);
                    updated = true;
                }

                var newName = await PromptTitleRenameAsync(_editingTitleFeature.Title);
                if (newName is null)
                {
                    _statusMessage = updated ? "Title updated." : "Title edit canceled.";
                }
                else if (string.Equals(newName, _editingTitleFeature.Title.Name, StringComparison.Ordinal))
                {
                    _statusMessage = updated ? "Title updated." : "Title unchanged.";
                }
                else
                {
                    PushUndoState();
                    _editingTitleFeature.Title.Name = newName;
                    TrackEditedTitleFeature(_editingTitleFeature);
                    _statusMessage = "Title updated.";
                }

                ClearEditSelection(true);
                await DrawAsync();
            }
            else if (_editingPolygon is not null)
            {
                TrackEditedPolygon(_editingPolygon);
                ClearEditSelection(true);
                _statusMessage = "Polygon edit confirmed.";
                await DrawAsync();
            }
            else if (_editingPointFeature is not null)
            {
                TrackEditedPointFeature(_editingPointFeature);
                ClearEditSelection(true);
                _statusMessage = "Point feature edit confirmed.";
                await DrawAsync();
            }
            return;
        }

        if (_activeTool != MapToolType.Polygon)
        {
            return;
        }

        if (_activePolygonPoints.Count < 3)
        {
            _activePolygonPoints.Clear();
            _statusMessage = "Polygon cleared (need at least 3 points).";
            await DrawAsync();
            return;
        }

        if (_placementType == PlacementType.Character)
        {
            _activePolygonPoints.Clear();
            _statusMessage = "Characters can only be placed with the Point tool.";
            await DrawAsync();
            return;
        }

        if (_placementType == PlacementType.Title)
        {
            var centroid = GetPolygonCentroid(_activePolygonPoints);
            var points = _activePolygonPoints
                .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                .ToList();
            var placed = await PlaceTitleAtPointAsync(
                centroid.X,
                centroid.Y,
                allowTargetSearch: false,
                polygonPoints: points);
            _activePolygonPoints.Clear();
            _statusMessage = placed
                ? "Title placed for area (unsaved)."
                : "Title placement canceled.";
        }
        else if (IsPointPlacement(_placementType) && _placementType != PlacementType.Character)
        {
            PushUndoState();
            var placedCount = PlacePolygonPointFeatures(_activePolygonPoints);
            _activePolygonPoints.Clear();
            var label = _placementType == PlacementType.House ? "house" : "tree";
            _statusMessage = placedCount == 0
                ? "Polygon placed with no points (adjust density)."
                : $"Polygon filled with {placedCount} {label} item{(placedCount == 1 ? string.Empty : "s")} (unsaved).";
            if (placedCount == 0 && _undoStack.Count > 0)
            {
                _undoStack.RemoveAt(_undoStack.Count - 1);
            }
        }
        else
        {
            EnsureAreaLayers();
            var layer = _activeAreaLayer;
            if (layer is null)
            {
                _statusMessage = "Select a layer before placing polygons.";
                return;
            }

            PushUndoState();
            var featureType = GetAreaPlacementFeatureType();
            var polygonPoints = _activePolygonPoints
                .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                .ToList();
            if (_useChaoticLandEdges && IsLandFeatureType(featureType))
            {
                polygonPoints = BuildChaoticLandEdgePoints(polygonPoints);
            }

            var polygon = new AreaPolygonDto
            {
                FeatureType = featureType,
                LayerIndex = layer.LayerIndex,
                Points = polygonPoints
            };

            if (IsLandFeatureType(polygon.FeatureType))
            {
                _stagedLandPolygons.Add(polygon);
            }
            else
            {
                _stagedWaterPolygons.Add(polygon);
            }
            _activePolygonPoints.Clear();
            _statusMessage = $"Polygon placed on {GetLayerLabel(layer)} (unsaved).";
        }
        await DrawAsync();
    }

    private async Task HandlePointerLeave(MouseEventArgs args)
    {
        if ((_isPanning || _isPanCandidate) && (_activeTool == MapToolType.Pointer || _activeTool == MapToolType.Point))
        {
            _isPanning = false;
            _isPanCandidate = false;
            return;
        }

        if (_activeTool == MapToolType.Brush && _isBrushing)
        {
            _isBrushing = false;
            _hasBrushCursor = false;
            _statusMessage = _brushStrokeCount == 0
                ? "Brush stroke canceled."
                : $"Brush stroke placed ({_brushStrokeCount} item{(_brushStrokeCount == 1 ? string.Empty : "s")}).";
            EndUndoBatch(_brushStrokeCount > 0);
            return;
        }

        if (_activeTool == MapToolType.Eraser && _isErasing)
        {
            StopEraser();
            return;
        }

        if (_activeTool == MapToolType.Brush && _hasBrushCursor)
        {
            _hasBrushCursor = false;
            await DrawAsync();
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPoint)
        {
            _isDraggingEditPoint = false;
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPolygon)
        {
            _isDraggingEditPolygon = false;
            _editingPolygonDragOrigin = null;
            _editingPolygonDragOriginPoints = null;
            await DrawAsync();
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPointFeature)
        {
            _isDraggingEditPointFeature = false;
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingTitleFeature)
        {
            _isDraggingTitleFeature = false;
            return;
        }

        if (_activeTool == MapToolType.Edit && _editingEdgeIndex >= 0)
        {
            _editingEdgeIndex = -1;
            await DrawAsync();
        }

        return;
    }

    private async Task HandleWheel(WheelEventArgs args)
    {
        var zoomFactor = args.DeltaY < 0 ? 1.1f : 0.9f;
        var newZoom = Math.Clamp(_zoom * zoomFactor, MinZoom, MaxZoom);
        if (Math.Abs(newZoom - _zoom) < 0.001f)
        {
            return;
        }

        var before = ScreenToMap((float)args.OffsetX, (float)args.OffsetY);
        _zoom = newZoom;
        _viewX = before.X - ((float)args.OffsetX / _zoom);
        _viewY = before.Y - ((float)args.OffsetY / _zoom);
        ClampView();
        await DrawAsync();
    }

    private void StartPan(MouseEventArgs args)
    {
        _isPanning = true;
        _panStartX = (float)args.OffsetX;
        _panStartY = (float)args.OffsetY;
        _panOriginX = _viewX;
        _panOriginY = _viewY;
        _statusMessage = "Panning map...";
    }

    private void BeginPanCandidate(MouseEventArgs args)
    {
        _isPanCandidate = true;
        _panCandidateStartX = (float)args.OffsetX;
        _panCandidateStartY = (float)args.OffsetY;
    }

    private void StartPanFromCandidate()
    {
        _isPanning = true;
        _panStartX = _panCandidateStartX;
        _panStartY = _panCandidateStartY;
        _panOriginX = _viewX;
        _panOriginY = _viewY;
        _isPanCandidate = false;
        _statusMessage = "Panning map...";
    }

    private void UpdatePan(MouseEventArgs args)
    {
        var dx = ((float)args.OffsetX - _panStartX) / _zoom;
        var dy = ((float)args.OffsetY - _panStartY) / _zoom;
        _viewX = _panOriginX - dx;
        _viewY = _panOriginY - dy;
        ClampView();
    }

    private (float X, float Y) ScreenToMap(float screenX, float screenY)
    {
        var scaleX = GetCanvasScaleX();
        var scaleY = GetCanvasScaleY();
        return (_viewX + ((screenX * scaleX) / _zoom), _viewY + ((screenY * scaleY) / _zoom));
    }

    private MapPointDto GetViewportCenterMapPoint()
    {
        var center = ScreenToMap(CanvasWidth * 0.5f, CanvasHeight * 0.5f);
        return new MapPointDto
        {
            X = Math.Clamp(center.X, 0f, MapWidth),
            Y = Math.Clamp(center.Y, 0f, MapHeight)
        };
    }

    private bool TryGetMapPoint(MouseEventArgs args, out float mapX, out float mapY)
    {
        var (rawX, rawY) = ScreenToMap((float)args.OffsetX, (float)args.OffsetY);
        if (rawX < 0 || rawX > MapWidth || rawY < 0 || rawY > MapHeight)
        {
            mapX = 0;
            mapY = 0;
            return false;
        }

        mapX = Math.Clamp(rawX, 0, MapWidth);
        mapY = Math.Clamp(rawY, 0, MapHeight);
        return true;
    }

    private void ClampView()
    {
        var maxX = Math.Max(0f, MapWidth - (CanvasWidth / _zoom));
        var maxY = Math.Max(0f, MapHeight - (CanvasHeight / _zoom));
        _viewX = Math.Clamp(_viewX, 0f, maxX);
        _viewY = Math.Clamp(_viewY, 0f, maxY);
    }

    private async Task HandlePointToolAsync(MouseEventArgs args)
    {
        if (_placementType == PlacementType.Title)
        {
            if (!TryGetMapPoint(args, out var titleMapX, out var titleMapY))
            {
                return;
            }

            await PlaceTitleAtPointAsync(titleMapX, titleMapY);
            await DrawAsync();
            return;
        }

        if (_placementType == PlacementType.Land)
        {
            _statusMessage = "Land can only be placed with the Polygon tool.";
            return;
        }

        if (_placementType == PlacementType.Water)
        {
            _statusMessage = "Water can only be placed with the Polygon tool.";
            return;
        }

        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        PushUndoState();
        PlacePointFeature(mapX, mapY);
        if (_placementType == PlacementType.House)
        {
            _statusMessage = $"Placed house at {_lastX:0}, {_lastY:0} (unsaved).";
        }
        else if (_placementType == PlacementType.Character)
        {
            _statusMessage = $"Placed character at {_lastX:0}, {_lastY:0} (unsaved).";
        }
        else
        {
            _statusMessage = $"Placed tree at {_lastX:0}, {_lastY:0} (unsaved).";
        }

        await DrawAsync();
    }

    private async Task GenerateStarterLandMassAsync()
    {
        if (_placementType != PlacementType.Land)
        {
            _statusMessage = "Select Land before generating a starter land mass.";
            return;
        }

        EnsureAreaLayers();
        var layer = _activeAreaLayer;
        if (layer is null)
        {
            _statusMessage = "Select a layer before generating a starter land mass.";
            return;
        }

        var points = BuildStarterLandMassPoints();
        if (points.Count < 3)
        {
            _statusMessage = "Unable to generate a starter land mass.";
            return;
        }

        if (_useChaoticLandEdges)
        {
            points = BuildChaoticLandEdgePoints(points);
        }

        PushUndoState();
        _activePolygonPoints.Clear();
        _stagedLandPolygons.Add(new AreaPolygonDto
        {
            FeatureType = "Land",
            LayerIndex = layer.LayerIndex,
            Points = points
        });

        _statusMessage = $"Starter land mass placed on {GetLayerLabel(layer)} (unsaved).";
        await DrawAsync();
    }

    private async Task StartEraserAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        BeginUndoBatch(UndoBatchKind.Eraser);
        PushUndoState();
        _isErasing = true;
        _eraseCount = 0;
        _eraseLastX = mapX;
        _eraseLastY = mapY;

        string? status = null;
        var erased = TryEraseAtPoint(mapX, mapY, out status, showEmptyStatus: true);

        _statusMessage = erased
            ? "Erasing..."
            : status ?? "Nothing to erase.";

        if (!erased && status == "Select a layer before erasing.")
        {
            _isErasing = false;
            EndUndoBatch(false);
        }

        if (erased)
        {
            _eraseCount += 1;
            await DrawAsync();
        }
    }

    private async Task ContinueEraserAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        var dx = mapX - _eraseLastX;
        var dy = mapY - _eraseLastY;
        var distance = MathF.Sqrt((dx * dx) + (dy * dy));
        if (distance < EraseMinSpacing)
        {
            return;
        }

        _eraseLastX = mapX;
        _eraseLastY = mapY;

        if (TryEraseAtPoint(mapX, mapY, out _, showEmptyStatus: false))
        {
            _eraseCount += 1;
            await DrawAsync();
        }
    }

    private void StopEraser()
    {
        _isErasing = false;
        _statusMessage = _eraseCount == 0
            ? "Nothing erased."
            : $"Erased {_eraseCount} item{(_eraseCount == 1 ? string.Empty : "s")}.";
        EndUndoBatch(_eraseCount > 0);
    }

    private async Task SaveEditsAsync()
    {
        if (PendingCount == 0)
        {
            return;
        }

        if (!IsLoggedIn)
        {
            _statusMessage = "Please log in to save features to the map.";
            return;
        }

        if (!_hasMap)
        {
            _statusMessage = "Create a new map before saving features.";
            return;
        }

        _isSaving = true;
        var pendingCount = PendingCount;
        _statusMessage = $"Saving {pendingCount} item{(pendingCount == 1 ? string.Empty : "s")}...";

        var request = new MapEditsRequest
        {
            UserId = UserState.CurrentUser?.UserId,
            SessionToken = UserState.CurrentUser?.SessionToken,
            MapId = MapId,
            AreaLayers = _areaLayers
                .OrderBy(layer => layer.LayerIndex)
                .Select(layer => new AreaLayerDto
                {
                    LayerKey = layer.LayerKey,
                    LayerIndex = layer.LayerIndex,
                    FeatureType = layer.FeatureType
                })
                .ToList(),
            AddedTrees = new List<TreeFeatureDto>(_stagedTrees),
            AddedHouses = new List<HouseFeatureDto>(_stagedHouses),
            AddedCharacters = new List<CharacterFeatureDto>(_stagedCharacters),
            AddedTitles = new List<TitleFeatureDto>(_stagedTitles),
            UpdatedTrees = _editedTrees.Values.ToList(),
            UpdatedHouses = _editedHouses.Values.ToList(),
            UpdatedCharacters = _editedCharacters.Values.ToList(),
            UpdatedTitles = _editedTitles.Values.ToList(),
            AddedRelationships = new List<AddCharacterRelationshipDto>(_stagedRelationships),
            UpdatedRelationships = _updatedRelationships.Values.ToList(),
            DeletedRelationshipIds = _deletedRelationships.Keys.ToList(),
            DeletedTreeIds = _deletedTreeIds.ToList(),
            DeletedHouseIds = _deletedHouseIds.ToList(),
            DeletedCharacterIds = _deletedCharacterIds.ToList(),
            DeletedTitleIds = _deletedTitleIds.ToList(),
            AddedWaterPolygons = new List<AreaPolygonDto>(_stagedWaterPolygons),
            DeletedWaterPolygonIds = _deletedWaterPolygonIds.ToList(),
            UpdatedWaterPolygons = _editedWaterPolygons.Values
                .Select(ClonePolygon)
                .ToList(),
            AddedLandPolygons = new List<AreaPolygonDto>(_stagedLandPolygons),
            DeletedLandPolygonIds = _deletedLandPolygonIds.ToList(),
            UpdatedLandPolygons = _editedLandPolygons.Values
                .Select(ClonePolygon)
                .ToList()
        };

        using var response = await Http.PostAsJsonAsync("api/demo-map/edits", request);

        if (response.IsSuccessStatusCode)
        {
            var map = await response.Content.ReadFromJsonAsync<MapDto>();
            _trees = map?.Trees ?? new List<TreeFeatureDto>();
            _houses = map?.Houses ?? new List<HouseFeatureDto>();
            _characters = map?.Characters ?? new List<CharacterFeatureDto>();
            _titles = map?.Titles ?? new List<TitleFeatureDto>();
            _waterPolygons.Clear();
            _landPolygons.Clear();
            LoadAreaPolygons(map);
            _editedWaterPolygons.Clear();
            _deletedWaterPolygonIds.Clear();
            _editedLandPolygons.Clear();
            _deletedLandPolygonIds.Clear();
            _editedTrees.Clear();
            _editedHouses.Clear();
            _editedCharacters.Clear();
            _editedTitles.Clear();
            _deletedTreeIds.Clear();
            _deletedHouseIds.Clear();
            _deletedCharacterIds.Clear();
            _deletedTitleIds.Clear();
            LoadAreaLayers(map);
            _stagedTrees.Clear();
            _stagedHouses.Clear();
            _stagedCharacters.Clear();
            _stagedTitles.Clear();
            _stagedRelationships.Clear();
            _updatedRelationships.Clear();
            _deletedRelationships.Clear();
            CancelRelationshipEdit();
            _statusMessage = $"Saved {pendingCount} item{(pendingCount == 1 ? string.Empty : "s")}.";
            ClearEditSelection(true);
            await DrawAsync();
        }
        else if (response.StatusCode == HttpStatusCode.Unauthorized)
        {
            await UserState.SetUserAsync(null);
            _statusMessage = "Your session is no longer valid. Please log in again.";
        }
        else
        {
            var message = await response.Content.ReadAsStringAsync();
            _statusMessage = string.IsNullOrWhiteSpace(message)
                ? "Failed to save changes."
                : message;
        }

        _isSaving = false;
    }

    private async Task ReloadAsync()
    {
        await LoadMapAsync();
        await DrawAsync();
    }

    private async Task HandlePointerToolClickAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        var hitRadius = GetEditHitRadius();
        var pointFeature = FindPointFeatureAtPoint(mapX, mapY, hitRadius, EraserTarget.Character, false);
        if (pointFeature?.Character is null)
        {
            _statusMessage = "Click a character to view details.";
            return;
        }

        ClearEditSelection(true);
        _editingPointFeature = pointFeature;
        _editingPointOriginalPosition = GetPointFeaturePosition(pointFeature);
        OpenCharacterEditor(pointFeature.Character, readOnly: true, resetRelationshipForm: true);
        _statusMessage = "Viewing character details.";
        await DrawAsync();
    }

    private async Task PerformUndoAsync()
    {
        if (_undoStack.Count == 0)
        {
            _statusMessage = "Nothing to undo.";
            return;
        }

        _redoStack.Add(CaptureUndoState());
        _isUndoing = true;
        _undoBatchKind = UndoBatchKind.None;
        _undoBatchPushed = false;

        var state = _undoStack[^1];
        _undoStack.RemoveAt(_undoStack.Count - 1);
        ApplyUndoState(state);
        ClearEditSelection(true);
        _statusMessage = "Undo complete.";
        _isUndoing = false;
        await DrawAsync();
    }

    private async Task PerformRedoAsync()
    {
        if (_redoStack.Count == 0)
        {
            _statusMessage = "Nothing to redo.";
            return;
        }

        _undoStack.Add(CaptureUndoState());
        _isRedoing = true;
        _undoBatchKind = UndoBatchKind.None;
        _undoBatchPushed = false;

        var state = _redoStack[^1];
        _redoStack.RemoveAt(_redoStack.Count - 1);
        ApplyUndoState(state);
        ClearEditSelection(true);
        _statusMessage = "Redo complete.";
        _isRedoing = false;
        await DrawAsync();
    }

    private async Task LoadMapAsync()
    {
        CloseRelationshipTree();
        _isLoading = true;
        _statusMessage = "Loading map from the server...";

        if (!IsLoggedIn)
        {
            _trees = new List<TreeFeatureDto>();
            _houses = new List<HouseFeatureDto>();
            _characters = new List<CharacterFeatureDto>();
            _titles = new List<TitleFeatureDto>();
            _waterPolygons.Clear();
            _landPolygons.Clear();
            _hasMap = false;
            ResetAreaLayers();
            ClearStaged();
            ClearUndoHistory();
            _statusMessage = "Log in, then return to Start to create a map.";
            _isLoading = false;
            return;
        }

        if (MapId <= 0)
        {
            _trees = new List<TreeFeatureDto>();
            _houses = new List<HouseFeatureDto>();
            _characters = new List<CharacterFeatureDto>();
            _titles = new List<TitleFeatureDto>();
            _waterPolygons.Clear();
            _landPolygons.Clear();
            _hasMap = false;
            ResetAreaLayers();
            ClearStaged();
            ClearUndoHistory();
            _statusMessage = "Select a map from Start.";
            _isLoading = false;
            return;
        }

        using var response = await Http.GetAsync(GetMapUrl());
        if (response.StatusCode == HttpStatusCode.Unauthorized)
        {
            await UserState.SetUserAsync(null);
            _statusMessage = "Your session is no longer valid. Please log in again.";
            _isLoading = false;
            return;
        }

        if (!response.IsSuccessStatusCode)
        {
            var message = await response.Content.ReadAsStringAsync();
            _statusMessage = string.IsNullOrWhiteSpace(message)
                ? "Failed to load map."
                : message;
            _isLoading = false;
            return;
        }

        var map = await response.Content.ReadFromJsonAsync<MapDto>();
        _trees = map?.Trees ?? new List<TreeFeatureDto>();
        _houses = map?.Houses ?? new List<HouseFeatureDto>();
        _characters = map?.Characters ?? new List<CharacterFeatureDto>();
        _titles = map?.Titles ?? new List<TitleFeatureDto>();
        _waterPolygons.Clear();
        _landPolygons.Clear();
        LoadAreaPolygons(map);
        _editedWaterPolygons.Clear();
        _editedLandPolygons.Clear();
        _editedTrees.Clear();
        _editedHouses.Clear();
        _editedCharacters.Clear();
        _hasMap = map?.Id > 0;
        LoadAreaLayers(map);
        ClearStaged();
        ClearUndoHistory();

        _statusMessage = _hasMap
            ? "Map loaded from the database."
            : "No map found. Return to Start and click New Map.";
        _isLoading = false;
    }

    [JSInvokable]
    public Task HandleUndoShortcut()
    {
        return PerformUndoAsync();
    }

    private async Task DrawAsync()
    {
        var renderState = BuildRenderState();
        await JS.InvokeVoidAsync("inkAndRealmDemo.drawMap", CanvasId, renderState);
    }

    private Task SelectPlacement(PlacementType placementType)
    {
        _placementType = placementType;
        if (IsPointPlacement(placementType))
        {
            if (_editingPolygon is not null)
            {
                _editingPolygon = null;
                _editingOriginalPoints = null;
                _editingPointIndex = -1;
                _editingEdgeIndex = -1;
                _isDraggingEditPoint = false;
                _ = InvokeAsync(DrawAsync);
            }
        }
        return Task.CompletedTask;
    }

    private async Task SelectTool(MapToolType tool)
    {
        if (tool == MapToolType.Undo)
        {
            await PerformUndoAsync();
            return;
        }
        if (tool == MapToolType.Redo)
        {
            await PerformRedoAsync();
            return;
        }

        _activeTool = tool;
        if (_isBrushing)
        {
            var keepUndo = _brushStrokeCount > 0;
            _isBrushing = false;
            _brushStrokeCount = 0;
            if (_undoBatchKind == UndoBatchKind.Brush)
            {
                EndUndoBatch(keepUndo);
            }
        }
        if (_isErasing)
        {
            var keepUndo = _eraseCount > 0;
            _isErasing = false;
            _eraseCount = 0;
            if (_undoBatchKind == UndoBatchKind.Eraser)
            {
                EndUndoBatch(keepUndo);
            }
        }
        if (_activeTool != MapToolType.Brush)
        {
            _hasBrushCursor = false;
        }
        if (tool != MapToolType.Edit && (_editingPolygon is not null || _editingPointFeature is not null))
        {
            ClearEditSelection(false);
            _ = InvokeAsync(DrawAsync);
        }
        _statusMessage = ActiveToolDefinition.IsImplemented
            ? $"{ActiveToolDefinition.Label} tool selected."
            : $"{ActiveToolDefinition.Label} tool is not available yet.";

        if (tool == MapToolType.Edit)
        {
            _statusMessage = "Edit tool selected. Click a feature to edit; right-click to confirm.";
        }

        if (tool == MapToolType.Duplicate)
        {
            _statusMessage = "Duplicate tool selected. Click a feature to clone.";
        }
    }

    private void SelectEraserTarget(EraserTarget target)
    {
        _eraserTarget = target;
        _statusMessage = $"Eraser set to {GetEraserTargetLabel(target)}.";
    }

    private void EnsureAreaLayers()
    {
        if (_areaLayers.Count == 0)
        {
            var featureType = GetAreaPlacementFeatureType();
            var layer = new AreaLayerDto
            {
                LayerKey = $"{featureType.ToLowerInvariant()}-0",
                LayerIndex = 0,
                FeatureType = featureType
            };
            _areaLayers.Add(layer);
            _activeAreaLayer = layer;
        }
        else if (_activeAreaLayer is null)
        {
            _activeAreaLayer = _areaLayers.OrderBy(layer => layer.LayerIndex).First();
        }
    }

    private void LoadAreaLayers(MapDto? map)
    {
        var desiredLayerIndex = _activeAreaLayer?.LayerIndex;
        _areaLayers.Clear();
        if (map?.AreaLayers is not null && map.AreaLayers.Count > 0)
        {
            _areaLayers.AddRange(map.AreaLayers);
        }

        NormalizeAreaLayers();
        if (_areaLayers.Count > 0)
        {
            _activeAreaLayer = desiredLayerIndex is null
                ? null
                : _areaLayers.FirstOrDefault(layer => layer.LayerIndex == desiredLayerIndex.Value);
        }
        else
        {
            _activeAreaLayer = null;
        }
        EnsureAreaLayers();
    }

    private void LoadAreaPolygons(MapDto? map)
    {
        if (map?.AreaPolygons is null || map.AreaPolygons.Count == 0)
        {
            return;
        }

        foreach (var polygon in map.AreaPolygons)
        {
            if (polygon is null || polygon.Points.Count == 0)
            {
                continue;
            }

            if (IsLandFeatureType(polygon.FeatureType))
            {
                _landPolygons.Add(polygon);
            }
            else if (IsWaterFeatureType(polygon.FeatureType))
            {
                _waterPolygons.Add(polygon);
            }
        }
    }

    private void ResetAreaLayers()
    {
        _areaLayers.Clear();
        _activeAreaLayer = null;
        EnsureAreaLayers();
    }

    private void NormalizeAreaLayers()
    {
        if (_areaLayers.Count == 0)
        {
            return;
        }

        _areaLayers.Sort((left, right) =>
        {
            var indexCompare = left.LayerIndex.CompareTo(right.LayerIndex);
            return indexCompare != 0 ? indexCompare : string.CompareOrdinal(left.LayerKey, right.LayerKey);
        });
    }

    private void AddAreaLayer()
    {
        PushUndoState();
        var nextIndex = GetNextLayerIndex();
        var featureType = GetAreaPlacementFeatureType();
        var layer = new AreaLayerDto
        {
            LayerKey = $"{featureType.ToLowerInvariant()}-{nextIndex}",
            LayerIndex = nextIndex,
            FeatureType = featureType
        };
        _areaLayers.Add(layer);
        NormalizeAreaLayers();
        _activeAreaLayer = layer;
        _statusMessage = $"{GetLayerLabel(layer)} created.";
    }

    private void SelectAreaLayer(AreaLayerDto layer)
    {
        _activeAreaLayer = layer;
        _statusMessage = $"{GetLayerLabel(layer)} selected.";
    }

    private async Task PromptDeleteLayerAsync(AreaLayerDto layer)
    {
        var label = GetLayerLabel(layer);
        var confirmed = await JS.InvokeAsync<bool>(
            "confirm",
            $"Delete {label}? Deleting the layer removes everything on that layer. Continue?");
        if (!confirmed)
        {
            return;
        }

        PushUndoState();
        DeleteAreaLayer(layer);
        _statusMessage = $"{label} deleted.";
        await DrawAsync();
    }

    private void DeleteAreaLayer(AreaLayerDto layer)
    {
        var layerIndex = layer.LayerIndex;
        if (_activeAreaLayer?.LayerIndex == layerIndex)
        {
            _activePolygonPoints.Clear();
        }

        if (_editingPolygon is not null && _editingPolygon.LayerIndex == layerIndex)
        {
            ClearEditSelection(true);
        }

        _stagedWaterPolygons.RemoveAll(polygon => polygon.LayerIndex == layerIndex);
        _stagedLandPolygons.RemoveAll(polygon => polygon.LayerIndex == layerIndex);

        foreach (var polygonId in _editedWaterPolygons
                     .Where(entry => entry.Value.LayerIndex == layerIndex)
                     .Select(entry => entry.Key)
                     .ToList())
        {
            _editedWaterPolygons.Remove(polygonId);
        }

        foreach (var polygonId in _editedLandPolygons
                     .Where(entry => entry.Value.LayerIndex == layerIndex)
                     .Select(entry => entry.Key)
                     .ToList())
        {
            _editedLandPolygons.Remove(polygonId);
        }

        foreach (var polygonId in _waterPolygons
                     .Where(polygon => polygon.LayerIndex == layerIndex && polygon.Id > 0)
                     .Select(polygon => polygon.Id))
        {
            _deletedWaterPolygonIds.Add(polygonId);
            RemoveStagedRelationshipChangesForTarget(polygonId);
        }

        foreach (var polygonId in _landPolygons
                     .Where(polygon => polygon.LayerIndex == layerIndex && polygon.Id > 0)
                     .Select(polygon => polygon.Id))
        {
            _deletedLandPolygonIds.Add(polygonId);
            RemoveStagedRelationshipChangesForTarget(polygonId);
        }

        _waterPolygons.RemoveAll(polygon => polygon.LayerIndex == layerIndex);
        _landPolygons.RemoveAll(polygon => polygon.LayerIndex == layerIndex);
        _areaLayers.RemoveAll(existing => existing.LayerIndex == layerIndex);

        if (_activeAreaLayer == layer)
        {
            _activeAreaLayer = null;
        }

        NormalizeAreaLayers();
        EnsureAreaLayers();
    }

    private int GetNextLayerIndex()
    {
        return _areaLayers.Count == 0 ? 0 : _areaLayers.Max(layer => layer.LayerIndex) + 1;
    }

    private string GetLayerLabel(AreaLayerDto layer, int fallbackIndex = 0)
    {
        var index = layer.LayerIndex >= 0 ? layer.LayerIndex : fallbackIndex;
        return $"Layer {index + 1}";
    }

    private string GetEraserTargetLabel(EraserTarget target)
    {
        return EraserTargetDefinitions.First(definition => definition.Target == target).Label;
    }


    private string GetMapUrl()
    {
        var sessionToken = UserState.CurrentUser?.SessionToken;
        if (!string.IsNullOrWhiteSpace(sessionToken))
        {
            return $"api/demo-map/{MapId}?sessionToken={Uri.EscapeDataString(sessionToken)}";
        }

        var userId = UserState.CurrentUser?.UserId;
        return userId is null ? $"api/demo-map/{MapId}" : $"api/demo-map/{MapId}?userId={userId.Value}";
    }

    private string RelationshipTreeViewBox => FormattableString.Invariant(
        $"{_relationshipTreeViewX} {_relationshipTreeViewY} {RelationshipTreeCanvasWidth / _relationshipTreeZoom} {RelationshipTreeCanvasHeight / _relationshipTreeZoom}");
    private string RelationshipTreeCanvasShellClass => _isRelationshipTreePanning
        ? "relationship-tree-canvas-shell relationship-tree-canvas-shell-panning"
        : "relationship-tree-canvas-shell";

    private void BeginRelationshipTreePan(MouseEventArgs args)
    {
        if (_isRelationshipTreeLoading || _relationshipTreeNodes.Count == 0 || args.Button != 0)
        {
            return;
        }

        _isRelationshipTreePanning = true;
        _relationshipTreeSuppressNodeClick = false;
        _relationshipTreePanStartClientX = (float)args.ClientX;
        _relationshipTreePanStartClientY = (float)args.ClientY;
        _relationshipTreePanOriginX = _relationshipTreeViewX;
        _relationshipTreePanOriginY = _relationshipTreeViewY;
    }

    private void UpdateRelationshipTreePan(MouseEventArgs args)
    {
        if (!_isRelationshipTreePanning)
        {
            return;
        }

        if (args.Buttons == 0)
        {
            EndRelationshipTreePan(args);
            return;
        }

        var dx = (float)args.ClientX - _relationshipTreePanStartClientX;
        var dy = (float)args.ClientY - _relationshipTreePanStartClientY;
        if (MathF.Abs(dx) > 2f || MathF.Abs(dy) > 2f)
        {
            _relationshipTreeSuppressNodeClick = true;
        }

        _relationshipTreeViewX = _relationshipTreePanOriginX - (dx / _relationshipTreeZoom);
        _relationshipTreeViewY = _relationshipTreePanOriginY - (dy / _relationshipTreeZoom);
        ClampRelationshipTreeViewport();
    }

    private void EndRelationshipTreePan(MouseEventArgs _)
    {
        _isRelationshipTreePanning = false;
    }

    private void HandleRelationshipTreeWheel(WheelEventArgs args)
    {
        if (_isRelationshipTreeLoading || _relationshipTreeNodes.Count == 0)
        {
            return;
        }

        if (args.DeltaY < 0)
        {
            ZoomRelationshipTree(RelationshipTreeZoomStep);
            return;
        }

        if (args.DeltaY > 0)
        {
            ZoomRelationshipTree(1f / RelationshipTreeZoomStep);
        }
    }

    private void ZoomInRelationshipTree()
    {
        ZoomRelationshipTree(RelationshipTreeZoomStep);
    }

    private void ZoomOutRelationshipTree()
    {
        ZoomRelationshipTree(1f / RelationshipTreeZoomStep);
    }

    private void ResetRelationshipTreeZoom()
    {
        ResetRelationshipTreeViewport();
    }

    private void ZoomRelationshipTree(float factor)
    {
        if (factor <= 0f)
        {
            return;
        }

        var oldZoom = _relationshipTreeZoom;
        var nextZoom = Math.Clamp(oldZoom * factor, RelationshipTreeMinZoom, RelationshipTreeMaxZoom);
        if (MathF.Abs(nextZoom - oldZoom) < 0.001f)
        {
            return;
        }

        var oldViewWidth = RelationshipTreeCanvasWidth / oldZoom;
        var oldViewHeight = RelationshipTreeCanvasHeight / oldZoom;
        var centerX = _relationshipTreeViewX + (oldViewWidth * 0.5f);
        var centerY = _relationshipTreeViewY + (oldViewHeight * 0.5f);

        _relationshipTreeZoom = nextZoom;

        var nextViewWidth = RelationshipTreeCanvasWidth / _relationshipTreeZoom;
        var nextViewHeight = RelationshipTreeCanvasHeight / _relationshipTreeZoom;
        _relationshipTreeViewX = centerX - (nextViewWidth * 0.5f);
        _relationshipTreeViewY = centerY - (nextViewHeight * 0.5f);

        ClampRelationshipTreeViewport();
    }

    private void ResetRelationshipTreeViewport()
    {
        _relationshipTreeZoom = 1f;
        _relationshipTreeViewX = 0f;
        _relationshipTreeViewY = 0f;
        _isRelationshipTreePanning = false;
        _relationshipTreeSuppressNodeClick = false;
    }

    private void ClampRelationshipTreeViewport()
    {
        var viewWidth = RelationshipTreeCanvasWidth / _relationshipTreeZoom;
        var viewHeight = RelationshipTreeCanvasHeight / _relationshipTreeZoom;
        var maxViewX = MathF.Max(0f, RelationshipTreeCanvasWidth - viewWidth);
        var maxViewY = MathF.Max(0f, RelationshipTreeCanvasHeight - viewHeight);

        _relationshipTreeViewX = Math.Clamp(_relationshipTreeViewX, 0f, maxViewX);
        _relationshipTreeViewY = Math.Clamp(_relationshipTreeViewY, 0f, maxViewY);
    }

    private async Task OpenRelationshipTreeAsync()
    {
        if (_isRelationshipTreeOpen)
        {
            return;
        }

        if (!IsLoggedIn)
        {
            _statusMessage = "Log in to view the Character Tree.";
            return;
        }

        if (!_hasMap || MapId <= 0)
        {
            _statusMessage = "Load a map before opening the Character Tree.";
            return;
        }

        _isRelationshipTreeOpen = true;
        _isRelationshipTreeLoading = true;
        _relationshipTreeStatusMessage = string.Empty;
        _relationshipTreeNodes.Clear();
        _relationshipTreeMergedEdges.Clear();
        _relationshipTreeNodeLookup.Clear();
        ResetRelationshipTreeViewport();

        try
        {
            using var response = await Http.GetAsync(GetMapUrl());
            if (response.StatusCode == HttpStatusCode.Unauthorized)
            {
                await UserState.SetUserAsync(null);
                _relationshipTreeStatusMessage = "Your session is no longer valid. Please log in again.";
                return;
            }

            if (!response.IsSuccessStatusCode)
            {
                _relationshipTreeStatusMessage = "Failed to load saved relationship data.";
                return;
            }

            var map = await response.Content.ReadFromJsonAsync<MapDto>();
            if (map is null || map.Id <= 0)
            {
                _relationshipTreeStatusMessage = "Map data was not found.";
                return;
            }

            BuildRelationshipTree(map);
            if (PendingCount > 0)
            {
                _relationshipTreeStatusMessage = "Showing saved state only. Unsaved changes are not included.";
            }
        }
        catch
        {
            _relationshipTreeStatusMessage = "Failed to load saved relationship data.";
        }
        finally
        {
            _isRelationshipTreeLoading = false;
        }
    }

    private void CloseRelationshipTree()
    {
        _isRelationshipTreeOpen = false;
        _isRelationshipTreeLoading = false;
        _relationshipTreeStatusMessage = string.Empty;
        _relationshipTreeNodes.Clear();
        _relationshipTreeMergedEdges.Clear();
        _relationshipTreeNodeLookup.Clear();
        ResetRelationshipTreeViewport();
    }

    private void BuildRelationshipTree(MapDto map)
    {
        _relationshipTreeNodes.Clear();
        _relationshipTreeMergedEdges.Clear();
        _relationshipTreeNodeLookup.Clear();

        var characters = (map.Characters ?? new List<CharacterFeatureDto>())
            .Where(character => character is not null && character.Id > 0)
            .GroupBy(character => character.Id)
            .Select(group => group.First())
            .OrderBy(character => character.Id)
            .ToList();

        var characterById = characters.ToDictionary(character => character.Id);
        var treeIds = (map.Trees ?? new List<TreeFeatureDto>())
            .Where(tree => tree is not null && tree.Id > 0)
            .Select(tree => tree.Id)
            .ToHashSet();
        var houseIds = (map.Houses ?? new List<HouseFeatureDto>())
            .Where(house => house is not null && house.Id > 0)
            .Select(house => house.Id)
            .ToHashSet();
        var landIds = (map.AreaPolygons ?? new List<AreaPolygonDto>())
            .Where(polygon => polygon is not null && polygon.Id > 0 && IsLandFeatureType(polygon.FeatureType))
            .Select(polygon => polygon.Id)
            .ToHashSet();
        var waterIds = (map.AreaPolygons ?? new List<AreaPolygonDto>())
            .Where(polygon => polygon is not null && polygon.Id > 0 && IsWaterFeatureType(polygon.FeatureType))
            .Select(polygon => polygon.Id)
            .ToHashSet();

        var nodeById = new Dictionary<int, RelationshipTreeNode>();
        foreach (var character in characters)
        {
            nodeById[character.Id] = new RelationshipTreeNode
            {
                FeatureId = character.Id,
                FeatureType = "Character",
                Label = BuildRelationshipTreeCharacterLabel(character),
                IsCharacter = true,
                Character = CloneDto(character)
            };
        }

        var directedEdges = new List<RelationshipTreeDirectedEdge>();
        foreach (var character in characters)
        {
            if (character.Relationships is null || character.Relationships.Count == 0)
            {
                continue;
            }

            foreach (var relationship in character.Relationships)
            {
                if (relationship is null || relationship.TargetFeatureId <= 0)
                {
                    continue;
                }

                if (!TryResolveRelationshipTreeTargetNode(
                        relationship,
                        characterById,
                        treeIds,
                        houseIds,
                        landIds,
                        waterIds,
                        out var targetNode))
                {
                    continue;
                }

                if (character.Id == targetNode.FeatureId)
                {
                    continue;
                }

                if (!nodeById.ContainsKey(targetNode.FeatureId))
                {
                    nodeById[targetNode.FeatureId] = targetNode;
                }

                directedEdges.Add(new RelationshipTreeDirectedEdge
                {
                    SourceId = character.Id,
                    TargetId = targetNode.FeatureId,
                    RelationshipTypes = relationship.RelationshipTypes is null
                        ? new List<string>()
                        : relationship.RelationshipTypes
                            .Where(value => !string.IsNullOrWhiteSpace(value))
                            .ToList(),
                    Description = relationship.Description ?? string.Empty
                });
            }
        }

        var mergedByPair = new Dictionary<(int NodeAId, int NodeBId), RelationshipTreeMergedEdge>();
        foreach (var edge in directedEdges)
        {
            if (edge.SourceId <= 0 || edge.TargetId <= 0 || edge.SourceId == edge.TargetId)
            {
                continue;
            }

            var nodeAId = Math.Min(edge.SourceId, edge.TargetId);
            var nodeBId = Math.Max(edge.SourceId, edge.TargetId);
            var pairKey = (nodeAId, nodeBId);
            if (!mergedByPair.TryGetValue(pairKey, out var mergedEdge))
            {
                mergedEdge = new RelationshipTreeMergedEdge
                {
                    NodeAId = nodeAId,
                    NodeBId = nodeBId
                };
                mergedByPair[pairKey] = mergedEdge;
            }

            if (edge.SourceId == nodeAId && edge.TargetId == nodeBId)
            {
                mergedEdge.AToB = MergeRelationshipTreeDirectedEdge(mergedEdge.AToB, edge);
            }
            else
            {
                mergedEdge.BToA = MergeRelationshipTreeDirectedEdge(mergedEdge.BToA, edge);
            }
        }

        _relationshipTreeNodes.AddRange(nodeById.Values
            .OrderBy(node => node.IsCharacter ? 0 : 1)
            .ThenBy(node => node.FeatureType, StringComparer.Ordinal)
            .ThenBy(node => node.FeatureId));

        _relationshipTreeMergedEdges.AddRange(mergedByPair.Values
            .Where(edge => edge.AToB is not null || edge.BToA is not null)
            .OrderBy(edge => edge.NodeAId)
            .ThenBy(edge => edge.NodeBId));

        LayoutRelationshipTreeNodes(_relationshipTreeNodes, directedEdges);

        foreach (var node in _relationshipTreeNodes)
        {
            _relationshipTreeNodeLookup[node.FeatureId] = node;
        }
    }

    private static RelationshipTreeDirectedEdge MergeRelationshipTreeDirectedEdge(
        RelationshipTreeDirectedEdge? existing,
        RelationshipTreeDirectedEdge incoming)
    {
        if (existing is null)
        {
            return new RelationshipTreeDirectedEdge
            {
                SourceId = incoming.SourceId,
                TargetId = incoming.TargetId,
                RelationshipTypes = new List<string>(incoming.RelationshipTypes),
                Description = incoming.Description
            };
        }

        var mergedTypes = new List<string>(existing.RelationshipTypes);
        foreach (var type in incoming.RelationshipTypes)
        {
            if (mergedTypes.Any(existingType => string.Equals(existingType, type, StringComparison.Ordinal)))
            {
                continue;
            }

            mergedTypes.Add(type);
        }

        return new RelationshipTreeDirectedEdge
        {
            SourceId = existing.SourceId,
            TargetId = existing.TargetId,
            RelationshipTypes = mergedTypes,
            Description = string.IsNullOrWhiteSpace(incoming.Description)
                ? existing.Description
                : incoming.Description
        };
    }

    private static string BuildRelationshipTreeCharacterLabel(CharacterFeatureDto character)
    {
        if (character is null)
        {
            return "Character";
        }

        return string.IsNullOrWhiteSpace(character.Name)
            ? $"Character #{character.Id}"
            : character.Name;
    }

    private static bool TryResolveRelationshipTreeTargetNode(
        CharacterRelationshipDto relationship,
        IReadOnlyDictionary<int, CharacterFeatureDto> characterById,
        IReadOnlySet<int> treeIds,
        IReadOnlySet<int> houseIds,
        IReadOnlySet<int> landIds,
        IReadOnlySet<int> waterIds,
        out RelationshipTreeNode node)
    {
        node = new RelationshipTreeNode();

        if (relationship is null || relationship.TargetFeatureId <= 0)
        {
            return false;
        }

        var targetId = relationship.TargetFeatureId;
        if (characterById.TryGetValue(targetId, out var character))
        {
            node = new RelationshipTreeNode
            {
                FeatureId = targetId,
                FeatureType = "Character",
                Label = BuildRelationshipTreeCharacterLabel(character),
                IsCharacter = true,
                Character = CloneDto(character)
            };
            return true;
        }

        if (treeIds.Contains(targetId))
        {
            node = new RelationshipTreeNode
            {
                FeatureId = targetId,
                FeatureType = "Tree",
                Label = $"Tree #{targetId}",
                IsCharacter = false
            };
            return true;
        }

        if (houseIds.Contains(targetId))
        {
            node = new RelationshipTreeNode
            {
                FeatureId = targetId,
                FeatureType = "House",
                Label = $"House #{targetId}",
                IsCharacter = false
            };
            return true;
        }

        if (landIds.Contains(targetId))
        {
            node = new RelationshipTreeNode
            {
                FeatureId = targetId,
                FeatureType = "Land",
                Label = $"Land #{targetId}",
                IsCharacter = false
            };
            return true;
        }

        if (waterIds.Contains(targetId))
        {
            node = new RelationshipTreeNode
            {
                FeatureId = targetId,
                FeatureType = "Water",
                Label = $"Water #{targetId}",
                IsCharacter = false
            };
            return true;
        }

        var targetFeatureType = relationship.TargetFeatureType?.Trim() ?? string.Empty;
        if (string.Equals(targetFeatureType, "Title", StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }

        var displayType = string.IsNullOrWhiteSpace(targetFeatureType)
            ? "Feature"
            : targetFeatureType;
        node = new RelationshipTreeNode
        {
            FeatureId = targetId,
            FeatureType = displayType,
            Label = $"{displayType} #{targetId}",
            IsCharacter = false
        };
        return true;
    }

    private static void LayoutRelationshipTreeNodes(
        IReadOnlyList<RelationshipTreeNode> nodes,
        IReadOnlyList<RelationshipTreeDirectedEdge> edges)
    {
        if (nodes is null || nodes.Count == 0)
        {
            return;
        }

        var centerX = RelationshipTreeCanvasWidth * 0.5f;
        var centerY = RelationshipTreeCanvasHeight * 0.5f;
        var characterNodes = nodes
            .Where(node => node.IsCharacter)
            .OrderBy(node => node.FeatureId)
            .ToList();
        var featureNodes = nodes
            .Where(node => !node.IsCharacter)
            .OrderBy(node => node.FeatureType, StringComparer.Ordinal)
            .ThenBy(node => node.FeatureId)
            .ToList();
        if (characterNodes.Count <= 10)
        {
            LayoutRelationshipTreeCharactersCircular(characterNodes, centerX, centerY);
        }
        else
        {
            LayoutRelationshipTreeCharactersChaotic(characterNodes, edges, centerX, centerY);
        }

        var characterPositions = new Dictionary<int, MapPointDto>();
        foreach (var characterNode in characterNodes)
        {
            characterPositions[characterNode.FeatureId] = new MapPointDto
            {
                X = characterNode.X,
                Y = characterNode.Y
            };
        }

        LayoutRelationshipTreeFeatureNodes(featureNodes, edges, characterPositions, centerX, centerY);
    }

    private static void LayoutRelationshipTreeCharactersCircular(
        IReadOnlyList<RelationshipTreeNode> characterNodes,
        float centerX,
        float centerY)
    {
        if (characterNodes.Count == 0)
        {
            return;
        }

        if (characterNodes.Count == 1)
        {
            characterNodes[0].X = centerX;
            characterNodes[0].Y = centerY;
            return;
        }

        var radius = MathF.Min(RelationshipTreeCanvasWidth, RelationshipTreeCanvasHeight) * 0.26f;
        for (var index = 0; index < characterNodes.Count; index += 1)
        {
            var angle = (-MathF.PI / 2f) + ((2f * MathF.PI * index) / characterNodes.Count);
            var node = characterNodes[index];
            node.X = centerX + (radius * MathF.Cos(angle));
            node.Y = centerY + (radius * MathF.Sin(angle));
        }
    }

    private static void LayoutRelationshipTreeCharactersChaotic(
        IReadOnlyList<RelationshipTreeNode> characterNodes,
        IReadOnlyList<RelationshipTreeDirectedEdge> edges,
        float centerX,
        float centerY)
    {
        if (characterNodes.Count == 0)
        {
            return;
        }

        if (characterNodes.Count == 1)
        {
            characterNodes[0].X = centerX;
            characterNodes[0].Y = centerY;
            return;
        }

        var indexById = characterNodes
            .Select((node, index) => new { node.FeatureId, Index = index })
            .ToDictionary(entry => entry.FeatureId, entry => entry.Index);
        var characterIds = indexById.Keys.ToHashSet();
        var neighborsById = new Dictionary<int, HashSet<int>>();
        foreach (var node in characterNodes)
        {
            neighborsById[node.FeatureId] = new HashSet<int>();
        }

        var pairWeights = new Dictionary<(int NodeA, int NodeB), float>();
        if (edges is not null)
        {
            foreach (var edge in edges)
            {
                if (!characterIds.Contains(edge.SourceId)
                    || !characterIds.Contains(edge.TargetId)
                    || edge.SourceId == edge.TargetId)
                {
                    continue;
                }

                var nodeA = Math.Min(edge.SourceId, edge.TargetId);
                var nodeB = Math.Max(edge.SourceId, edge.TargetId);
                var key = (nodeA, nodeB);
                pairWeights[key] = pairWeights.TryGetValue(key, out var existing)
                    ? existing + 1f
                    : 1f;

                neighborsById[edge.SourceId].Add(edge.TargetId);
                neighborsById[edge.TargetId].Add(edge.SourceId);
            }
        }

        var x = new float[characterNodes.Count];
        var y = new float[characterNodes.Count];
        var velocityX = new float[characterNodes.Count];
        var velocityY = new float[characterNodes.Count];
        var forceX = new float[characterNodes.Count];
        var forceY = new float[characterNodes.Count];
        var maxRadius = MathF.Min(RelationshipTreeCanvasWidth, RelationshipTreeCanvasHeight) * 0.34f;
        var minRadius = maxRadius * 0.18f;
        for (var index = 0; index < characterNodes.Count; index += 1)
        {
            var node = characterNodes[index];
            var degree = neighborsById.TryGetValue(node.FeatureId, out var neighbors)
                ? neighbors.Count
                : 0;
            var degreeRatio = characterNodes.Count <= 1
                ? 0f
                : (degree / (float)(characterNodes.Count - 1));
            var angle = RelationshipTreeNoise01((node.FeatureId * 0.61f) + (characterNodes.Count * 1.37f)) * (2f * MathF.PI);
            var radialNoise = RelationshipTreeNoise01((node.FeatureId * 1.17f) + (degree * 13.11f));
            var radiusWeight = (1f - degreeRatio) * (0.55f + (0.45f * radialNoise));
            var radius = minRadius + (radiusWeight * (maxRadius - minRadius));
            x[index] = ClampRelationshipTreeX(centerX + (radius * MathF.Cos(angle)));
            y[index] = ClampRelationshipTreeY(centerY + (radius * MathF.Sin(angle)));
        }

        var springs = new List<(int IndexA, int IndexB, float Weight, float SharedRatio)>();
        foreach (var pair in pairWeights)
        {
            if (!indexById.TryGetValue(pair.Key.NodeA, out var indexA)
                || !indexById.TryGetValue(pair.Key.NodeB, out var indexB))
            {
                continue;
            }

            var neighborsA = neighborsById[pair.Key.NodeA];
            var neighborsB = neighborsById[pair.Key.NodeB];
            var sharedCount = neighborsA.Count < neighborsB.Count
                ? neighborsA.Count(candidate => neighborsB.Contains(candidate))
                : neighborsB.Count(candidate => neighborsA.Contains(candidate));
            var possibleShared = Math.Max(1, Math.Min(neighborsA.Count, neighborsB.Count));
            var sharedRatio = sharedCount / (float)possibleShared;
            springs.Add((indexA, indexB, pair.Value, sharedRatio));
        }

        var iterations = Math.Clamp(140 + (characterNodes.Count * 5), 180, 360);
        var repulsionStrength = 19000f + (characterNodes.Count * 160f);
        var baseEdgeLength = Math.Clamp(220f - (characterNodes.Count * 2.4f), 88f, 180f);
        const float springStrength = 0.055f;
        const float centeringStrength = 0.010f;
        const float damping = 0.84f;
        const float maxStep = 17f;

        for (var iteration = 0; iteration < iterations; iteration += 1)
        {
            Array.Fill(forceX, 0f);
            Array.Fill(forceY, 0f);

            for (var i = 0; i < characterNodes.Count; i += 1)
            {
                for (var j = i + 1; j < characterNodes.Count; j += 1)
                {
                    var dx = x[j] - x[i];
                    var dy = y[j] - y[i];
                    var distanceSquared = (dx * dx) + (dy * dy);
                    if (distanceSquared < 0.1f)
                    {
                        dx = (RelationshipTreeNoise01((iteration * 193f) + i + (j * 17f)) - 0.5f) * 0.3f;
                        dy = (RelationshipTreeNoise01((iteration * 311f) + j + (i * 13f)) - 0.5f) * 0.3f;
                        distanceSquared = (dx * dx) + (dy * dy);
                    }

                    distanceSquared = MathF.Max(distanceSquared, 0.1f);
                    var distance = MathF.Sqrt(distanceSquared);
                    var unitX = dx / distance;
                    var unitY = dy / distance;
                    var force = repulsionStrength / distanceSquared;
                    forceX[i] -= unitX * force;
                    forceY[i] -= unitY * force;
                    forceX[j] += unitX * force;
                    forceY[j] += unitY * force;
                }
            }

            foreach (var spring in springs)
            {
                var dx = x[spring.IndexB] - x[spring.IndexA];
                var dy = y[spring.IndexB] - y[spring.IndexA];
                var distanceSquared = (dx * dx) + (dy * dy);
                if (distanceSquared < 0.1f)
                {
                    continue;
                }

                var distance = MathF.Sqrt(distanceSquared);
                var desiredLength = baseEdgeLength * (1f - (spring.SharedRatio * 0.28f));
                var connectionStrength = springStrength
                    * (1f + ((spring.Weight - 1f) * 0.35f) + (spring.SharedRatio * 1.35f));
                var delta = distance - desiredLength;
                var force = connectionStrength * delta;
                var unitX = dx / distance;
                var unitY = dy / distance;
                forceX[spring.IndexA] += unitX * force;
                forceY[spring.IndexA] += unitY * force;
                forceX[spring.IndexB] -= unitX * force;
                forceY[spring.IndexB] -= unitY * force;
            }

            for (var index = 0; index < characterNodes.Count; index += 1)
            {
                forceX[index] += (centerX - x[index]) * centeringStrength;
                forceY[index] += (centerY - y[index]) * centeringStrength;

                velocityX[index] = (velocityX[index] + forceX[index]) * damping;
                velocityY[index] = (velocityY[index] + forceY[index]) * damping;
                var stepX = Math.Clamp(velocityX[index], -maxStep, maxStep);
                var stepY = Math.Clamp(velocityY[index], -maxStep, maxStep);
                x[index] = ClampRelationshipTreeX(x[index] + stepX);
                y[index] = ClampRelationshipTreeY(y[index] + stepY);
            }
        }

        for (var pass = 0; pass < 4; pass += 1)
        {
            for (var i = 0; i < characterNodes.Count; i += 1)
            {
                for (var j = i + 1; j < characterNodes.Count; j += 1)
                {
                    var dx = x[j] - x[i];
                    var dy = y[j] - y[i];
                    var distanceSquared = (dx * dx) + (dy * dy);
                    if (distanceSquared < 0.1f)
                    {
                        continue;
                    }

                    var distance = MathF.Sqrt(distanceSquared);
                    const float minDistance = 44f;
                    if (distance >= minDistance)
                    {
                        continue;
                    }

                    var push = (minDistance - distance) * 0.5f;
                    var unitX = dx / distance;
                    var unitY = dy / distance;
                    x[i] = ClampRelationshipTreeX(x[i] - (unitX * push));
                    y[i] = ClampRelationshipTreeY(y[i] - (unitY * push));
                    x[j] = ClampRelationshipTreeX(x[j] + (unitX * push));
                    y[j] = ClampRelationshipTreeY(y[j] + (unitY * push));
                }
            }
        }

        for (var index = 0; index < characterNodes.Count; index += 1)
        {
            var node = characterNodes[index];
            var jitterX = (RelationshipTreeNoise01((node.FeatureId * 31.7f) + 7f) - 0.5f) * 4f;
            var jitterY = (RelationshipTreeNoise01((node.FeatureId * 63.1f) + 11f) - 0.5f) * 4f;
            node.X = ClampRelationshipTreeX(x[index] + jitterX);
            node.Y = ClampRelationshipTreeY(y[index] + jitterY);
        }
    }

    private static void LayoutRelationshipTreeFeatureNodes(
        IReadOnlyList<RelationshipTreeNode> featureNodes,
        IReadOnlyList<RelationshipTreeDirectedEdge> edges,
        IReadOnlyDictionary<int, MapPointDto> characterPositions,
        float centerX,
        float centerY)
    {
        if (featureNodes.Count == 0)
        {
            return;
        }

        var featureIds = featureNodes
            .Select(node => node.FeatureId)
            .ToHashSet();
        var charactersByFeature = new Dictionary<int, HashSet<int>>();
        if (edges is not null && edges.Count > 0)
        {
            foreach (var edge in edges)
            {
                if (featureIds.Contains(edge.SourceId)
                    && characterPositions.ContainsKey(edge.TargetId))
                {
                    if (!charactersByFeature.TryGetValue(edge.SourceId, out var related))
                    {
                        related = new HashSet<int>();
                        charactersByFeature[edge.SourceId] = related;
                    }

                    related.Add(edge.TargetId);
                }

                if (featureIds.Contains(edge.TargetId)
                    && characterPositions.ContainsKey(edge.SourceId))
                {
                    if (!charactersByFeature.TryGetValue(edge.TargetId, out var related))
                    {
                        related = new HashSet<int>();
                        charactersByFeature[edge.TargetId] = related;
                    }

                    related.Add(edge.SourceId);
                }
            }
        }

        var occupiedNodes = new List<(float X, float Y, float Radius)>();
        foreach (var position in characterPositions.Values)
        {
            occupiedNodes.Add((position.X, position.Y, 18f));
        }

        var outerRadius = MathF.Min(RelationshipTreeCanvasWidth, RelationshipTreeCanvasHeight) * 0.42f;
        foreach (var node in featureNodes)
        {
            float anchorX;
            float anchorY;
            float placementRadius;
            if (charactersByFeature.TryGetValue(node.FeatureId, out var relatedCharacters)
                && relatedCharacters.Count > 0)
            {
                var relatedPositions = relatedCharacters
                    .Where(characterId => characterPositions.ContainsKey(characterId))
                    .Select(characterId => characterPositions[characterId])
                    .ToList();
                if (relatedPositions.Count == 0)
                {
                    anchorX = centerX;
                    anchorY = centerY;
                    placementRadius = 70f;
                }
                else
                {
                    anchorX = relatedPositions.Average(position => position.X);
                    anchorY = relatedPositions.Average(position => position.Y);
                    var density = MathF.Min(1f, relatedPositions.Count / 6f);
                    placementRadius = 40f + ((1f - density) * 60f);
                }
            }
            else
            {
                var angle = RelationshipTreeNoise01((node.FeatureId * 0.93f) + 17f) * (2f * MathF.PI);
                var radiusFactor = 0.82f + (0.15f * RelationshipTreeNoise01((node.FeatureId * 1.31f) + 3f));
                anchorX = centerX + ((outerRadius * radiusFactor) * MathF.Cos(angle));
                anchorY = centerY + ((outerRadius * radiusFactor) * MathF.Sin(angle));
                placementRadius = 30f + (35f * RelationshipTreeNoise01((node.FeatureId * 2.71f) + 5f));
            }

            var placement = FindRelationshipTreeOpenSpot(
                anchorX,
                anchorY,
                placementRadius,
                node.FeatureId,
                13f,
                occupiedNodes);
            node.X = placement.X;
            node.Y = placement.Y;
            occupiedNodes.Add((node.X, node.Y, 13f));
        }
    }

    private static MapPointDto FindRelationshipTreeOpenSpot(
        float anchorX,
        float anchorY,
        float baseRadius,
        int seed,
        float radius,
        IReadOnlyList<(float X, float Y, float Radius)> occupiedNodes)
    {
        var startAngle = RelationshipTreeNoise01((seed * 0.87f) + 19.1f) * (2f * MathF.PI);
        for (var ring = 0; ring <= 8; ring += 1)
        {
            var ringRadius = ring == 0 ? 0f : baseRadius + ((ring - 1) * 22f);
            var samples = ring == 0 ? 1 : 12;
            for (var sample = 0; sample < samples; sample += 1)
            {
                var angle = startAngle + ((2f * MathF.PI * sample) / samples) + (ring * 0.41f);
                var x = ClampRelationshipTreeX(anchorX + (ringRadius * MathF.Cos(angle)));
                var y = ClampRelationshipTreeY(anchorY + (ringRadius * MathF.Sin(angle)));
                if (!IsRelationshipTreePositionOpen(x, y, radius, occupiedNodes))
                {
                    continue;
                }

                return new MapPointDto { X = x, Y = y };
            }
        }

        return new MapPointDto
        {
            X = ClampRelationshipTreeX(anchorX),
            Y = ClampRelationshipTreeY(anchorY)
        };
    }

    private static bool IsRelationshipTreePositionOpen(
        float x,
        float y,
        float radius,
        IReadOnlyList<(float X, float Y, float Radius)> occupiedNodes)
    {
        const float minGap = 12f;
        foreach (var occupied in occupiedNodes)
        {
            var dx = x - occupied.X;
            var dy = y - occupied.Y;
            var requiredDistance = radius + occupied.Radius + minGap;
            if ((dx * dx) + (dy * dy) < (requiredDistance * requiredDistance))
            {
                return false;
            }
        }

        return true;
    }

    private static float ClampRelationshipTreeX(float x)
    {
        return Math.Clamp(x, 84f, RelationshipTreeCanvasWidth - 84f);
    }

    private static float ClampRelationshipTreeY(float y)
    {
        return Math.Clamp(y, 72f, RelationshipTreeCanvasHeight - 72f);
    }

    private static float RelationshipTreeNoise01(float value)
    {
        var raw = MathF.Sin(value * 12.9898f) * 43758.5453f;
        return raw - MathF.Floor(raw);
    }

    private static MapPointDto GetRelationshipTreeLabelPosition(
        RelationshipTreeNode from,
        RelationshipTreeNode to,
        float distanceFactor,
        float perpendicularOffset)
    {
        var x = from.X + ((to.X - from.X) * distanceFactor);
        var y = from.Y + ((to.Y - from.Y) * distanceFactor);
        var dx = to.X - from.X;
        var dy = to.Y - from.Y;
        var length = MathF.Sqrt((dx * dx) + (dy * dy));
        if (length <= 0.001f)
        {
            return new MapPointDto { X = x, Y = y };
        }

        var normalX = -dy / length;
        var normalY = dx / length;
        return new MapPointDto
        {
            X = x + (normalX * perpendicularOffset),
            Y = y + (normalY * perpendicularOffset)
        };
    }

    private static string? GetRelationshipTreeMarkerStart(RelationshipTreeMergedEdge edge)
    {
        return edge.BToA is null ? null : "url(#relationship-tree-arrowhead)";
    }

    private static string? GetRelationshipTreeMarkerEnd(RelationshipTreeMergedEdge edge)
    {
        return edge.AToB is null ? null : "url(#relationship-tree-arrowhead)";
    }

    private static string GetRelationshipTreeEdgeLabel(RelationshipTreeDirectedEdge edge)
    {
        var types = edge.RelationshipTypes is null || edge.RelationshipTypes.Count == 0
            ? string.Empty
            : string.Join(", ", edge.RelationshipTypes.Where(value => !string.IsNullOrWhiteSpace(value)));
        return string.IsNullOrWhiteSpace(types) ? "Relationship" : types;
    }

    private string GetRelationshipTreeEdgeTooltip(RelationshipTreeMergedEdge edge)
    {
        var lines = new List<string>();
        if (!_relationshipTreeNodeLookup.TryGetValue(edge.NodeAId, out var nodeA)
            || !_relationshipTreeNodeLookup.TryGetValue(edge.NodeBId, out var nodeB))
        {
            return "Relationship";
        }

        if (edge.AToB is not null)
        {
            var detail = GetRelationshipTreeEdgeLabel(edge.AToB);
            var description = string.IsNullOrWhiteSpace(edge.AToB.Description)
                ? string.Empty
                : $" ({edge.AToB.Description.Trim()})";
            lines.Add($"{nodeA.Label} -> {nodeB.Label}: {detail}{description}");
        }

        if (edge.BToA is not null)
        {
            var detail = GetRelationshipTreeEdgeLabel(edge.BToA);
            var description = string.IsNullOrWhiteSpace(edge.BToA.Description)
                ? string.Empty
                : $" ({edge.BToA.Description.Trim()})";
            lines.Add($"{nodeB.Label} -> {nodeA.Label}: {detail}{description}");
        }

        return lines.Count == 0 ? "Relationship" : string.Join(Environment.NewLine, lines);
    }

    private static string GetRelationshipTreeNodeClass(RelationshipTreeNode node)
    {
        return node.IsCharacter
            ? "relationship-tree-node relationship-tree-node-character"
            : "relationship-tree-node relationship-tree-node-feature";
    }

    private static float GetRelationshipTreeNodeRadius(RelationshipTreeNode node)
    {
        return node.IsCharacter ? 18f : 13f;
    }

    private static string GetRelationshipTreeNodeShortLabel(RelationshipTreeNode node)
    {
        if (node is null || string.IsNullOrWhiteSpace(node.Label))
        {
            return "Feature";
        }

        var label = node.Label.Trim();
        const int maxLength = 24;
        if (label.Length <= maxLength)
        {
            return label;
        }

        return $"{label[..(maxLength - 3)]}...";
    }

    private static string GetRelationshipTreeNodeTooltip(RelationshipTreeNode node)
    {
        return $"{node.Label} [{node.FeatureType}]";
    }

    private void SelectRelationshipTreeNode(RelationshipTreeNode node)
    {
        if (_relationshipTreeSuppressNodeClick)
        {
            _relationshipTreeSuppressNodeClick = false;
            return;
        }

        if (node is null || !node.IsCharacter || node.Character is null)
        {
            return;
        }

        var character = CloneDto(node.Character);
        CloseRelationshipTree();
        OpenCharacterEditor(character, readOnly: true, resetRelationshipForm: true);
        _statusMessage = "Viewing character details from Character Tree.";
    }

    private void OnUserChanged()
    {
        _ = InvokeAsync(async () =>
        {
            await LoadMapAsync();
            await DrawAsync();
            StateHasChanged();
        });
    }

    private void GoHome()
    {
        Navigation.NavigateTo("/");
    }

    public void Dispose()
    {
        UserState.Changed -= OnUserChanged;
        if (_undoShortcutRef is not null)
        {
            _ = JS.InvokeVoidAsync("inkAndRealmDemo.unregisterUndoShortcut", CanvasId);
            _undoShortcutRef.Dispose();
            _undoShortcutRef = null;
        }
    }

    private void ClearStaged()
    {
        _stagedTrees.Clear();
        _stagedHouses.Clear();
        _stagedCharacters.Clear();
        _stagedTitles.Clear();
        _stagedRelationships.Clear();
        _updatedRelationships.Clear();
        _deletedRelationships.Clear();
        _stagedWaterPolygons.Clear();
        _stagedLandPolygons.Clear();
        _editedWaterPolygons.Clear();
        _deletedWaterPolygonIds.Clear();
        _editedLandPolygons.Clear();
        _deletedLandPolygonIds.Clear();
        _editedTrees.Clear();
        _editedHouses.Clear();
        _editedCharacters.Clear();
        _editedTitles.Clear();
        _deletedTreeIds.Clear();
        _deletedHouseIds.Clear();
        _deletedCharacterIds.Clear();
        _deletedTitleIds.Clear();
        _activePolygonPoints.Clear();
        ClearEditSelection(false);
        _hasLastPlacement = false;
        _isBrushing = false;
        _brushStrokeCount = 0;
        _isErasing = false;
        _eraseCount = 0;
        _hasBrushCursor = false;
        _relationshipStatusMessage = string.Empty;
        _isSelectingRelationshipTarget = false;
        _relationshipSourceCharacter = null;
        _selectedRelationshipTarget = null;
        CancelRelationshipEdit();
    }

    private void ClearUndoHistory()
    {
        _undoStack.Clear();
        _redoStack.Clear();
        _undoBatchKind = UndoBatchKind.None;
        _undoBatchPushed = false;
    }

    private void BeginUndoBatch(UndoBatchKind kind)
    {
        _undoBatchKind = kind;
        _undoBatchPushed = false;
    }

    private void EndUndoBatch(bool keepChanges)
    {
        if (_undoBatchKind == UndoBatchKind.None)
        {
            return;
        }

        if (!keepChanges && _undoBatchPushed && _undoStack.Count > 0)
        {
            _undoStack.RemoveAt(_undoStack.Count - 1);
        }

        _undoBatchKind = UndoBatchKind.None;
        _undoBatchPushed = false;
    }

    private void PushUndoState()
    {
        if (_isUndoing)
        {
            return;
        }

        if (_undoBatchKind != UndoBatchKind.None && _undoBatchPushed)
        {
            return;
        }

        if (!_isRedoing && _redoStack.Count > 0)
        {
            _redoStack.Clear();
        }

        _undoStack.Add(CaptureUndoState());

        if (_undoBatchKind != UndoBatchKind.None)
        {
            _undoBatchPushed = true;
        }
    }

    private UndoState CaptureUndoState()
    {
        return new UndoState
        {
            Trees = CloneList(_trees),
            Houses = CloneList(_houses),
            Titles = CloneList(_titles),
            StagedTrees = CloneList(_stagedTrees),
            StagedHouses = CloneList(_stagedHouses),
            StagedTitles = CloneList(_stagedTitles),
            WaterPolygons = CloneList(_waterPolygons),
            StagedWaterPolygons = CloneList(_stagedWaterPolygons),
            EditedWaterPolygons = CloneDictionary(_editedWaterPolygons),
            DeletedWaterPolygonIds = new HashSet<int>(_deletedWaterPolygonIds),
            LandPolygons = CloneList(_landPolygons),
            StagedLandPolygons = CloneList(_stagedLandPolygons),
            EditedLandPolygons = CloneDictionary(_editedLandPolygons),
            DeletedLandPolygonIds = new HashSet<int>(_deletedLandPolygonIds),
            EditedTrees = CloneDictionary(_editedTrees),
            EditedHouses = CloneDictionary(_editedHouses),
            EditedTitles = CloneDictionary(_editedTitles),
            DeletedTreeIds = new HashSet<int>(_deletedTreeIds),
            DeletedHouseIds = new HashSet<int>(_deletedHouseIds),
            DeletedTitleIds = new HashSet<int>(_deletedTitleIds),
            AreaLayers = CloneList(_areaLayers),
            ActiveAreaLayerKey = _activeAreaLayer?.LayerKey,
            ActiveAreaLayerIndex = _activeAreaLayer?.LayerIndex,
            LastX = _lastX,
            LastY = _lastY,
            HasLastPlacement = _hasLastPlacement
        };
    }

    private void ApplyUndoState(UndoState state)
    {
        ReplaceListContents(_trees, state.Trees);
        ReplaceListContents(_houses, state.Houses);
        ReplaceListContents(_titles, state.Titles);
        ReplaceListContents(_stagedTrees, state.StagedTrees);
        ReplaceListContents(_stagedHouses, state.StagedHouses);
        ReplaceListContents(_stagedTitles, state.StagedTitles);
        ReplaceListContents(_waterPolygons, state.WaterPolygons);
        ReplaceListContents(_stagedWaterPolygons, state.StagedWaterPolygons);
        ReplaceDictionaryContents(_editedWaterPolygons, state.EditedWaterPolygons);
        ReplaceSetContents(_deletedWaterPolygonIds, state.DeletedWaterPolygonIds);
        ReplaceListContents(_landPolygons, state.LandPolygons);
        ReplaceListContents(_stagedLandPolygons, state.StagedLandPolygons);
        ReplaceDictionaryContents(_editedLandPolygons, state.EditedLandPolygons);
        ReplaceSetContents(_deletedLandPolygonIds, state.DeletedLandPolygonIds);
        ReplaceDictionaryContents(_editedTrees, state.EditedTrees);
        ReplaceDictionaryContents(_editedHouses, state.EditedHouses);
        ReplaceDictionaryContents(_editedTitles, state.EditedTitles);
        ReplaceSetContents(_deletedTreeIds, state.DeletedTreeIds);
        ReplaceSetContents(_deletedHouseIds, state.DeletedHouseIds);
        ReplaceSetContents(_deletedTitleIds, state.DeletedTitleIds);
        ReplaceListContents(_areaLayers, state.AreaLayers);

        _activeAreaLayer = null;
        if (!string.IsNullOrWhiteSpace(state.ActiveAreaLayerKey))
        {
            _activeAreaLayer = _areaLayers.FirstOrDefault(layer => layer.LayerKey == state.ActiveAreaLayerKey);
        }

        if (_activeAreaLayer is null && state.ActiveAreaLayerIndex is not null)
        {
            _activeAreaLayer = _areaLayers.FirstOrDefault(layer => layer.LayerIndex == state.ActiveAreaLayerIndex.Value);
        }

        if (_activeAreaLayer is null && _areaLayers.Count > 0)
        {
            _activeAreaLayer = _areaLayers.OrderBy(layer => layer.LayerIndex).First();
        }

        _lastX = state.LastX;
        _lastY = state.LastY;
        _hasLastPlacement = state.HasLastPlacement;

        _activePolygonPoints.Clear();
        _isBrushing = false;
        _brushStrokeCount = 0;
        _isErasing = false;
        _eraseCount = 0;
        _hasBrushCursor = false;
    }

    private static List<T> CloneList<T>(IEnumerable<T> source)
    {
        return CloneDto(source.ToList());
    }

    private static Dictionary<int, T> CloneDictionary<T>(Dictionary<int, T> source)
    {
        return source.ToDictionary(entry => entry.Key, entry => CloneDto(entry.Value));
    }

    private static void ReplaceListContents<T>(List<T> target, List<T> source)
    {
        target.Clear();
        target.AddRange(source);
    }

    private static void ReplaceDictionaryContents<T>(Dictionary<int, T> target, Dictionary<int, T> source)
    {
        target.Clear();
        foreach (var entry in source)
        {
            target[entry.Key] = entry.Value;
        }
    }

    private static void ReplaceSetContents<T>(HashSet<T> target, HashSet<T> source)
    {
        target.Clear();
        foreach (var value in source)
        {
            target.Add(value);
        }
    }

    private async Task UpdateCanvasClientSizeAsync()
    {
        var size = await JS.InvokeAsync<CanvasClientSize?>("inkAndRealmDemo.getCanvasClientSize", CanvasId);
        if (size is null || size.Width <= 0 || size.Height <= 0)
        {
            _canvasClientWidth = CanvasWidth;
            _canvasClientHeight = CanvasHeight;
            return;
        }

        _canvasClientWidth = size.Width;
        _canvasClientHeight = size.Height;
    }

    private string GetStyleForPlacement(PlacementType placementType)
    {
        return _selectedStyleByPlacement.TryGetValue(placementType, out var style)
            ? style
            : string.Empty;
    }

    private float GetPointSizeForPlacement(PlacementType placementType)
    {
        if (!IsPointPlacement(placementType))
        {
            return 1f;
        }

        return _pointSizeByPlacement.TryGetValue(placementType, out var size)
            ? size
            : 1f;
    }

    private void SetPointSizeForPlacement(PlacementType placementType, float value)
    {
        if (!IsPointPlacement(placementType))
        {
            return;
        }

        _pointSizeByPlacement[placementType] = NormalizePointSize(value);
    }

    private static bool IsPointPlacement(PlacementType placementType)
    {
        return placementType == PlacementType.Tree
            || placementType == PlacementType.House
            || placementType == PlacementType.Character;
    }

    private static bool IsTitlePlacement(PlacementType placementType)
    {
        return placementType == PlacementType.Title;
    }

    private static bool CanDragTitle(TitleFeatureDto title)
    {
        return !title.TargetFeatureId.HasValue
            && (title.Points is null || title.Points.Count < 3);
    }

    private bool IsEditingTitlePolygon()
    {
        return _editingTitleFeature is not null
            && _editingPolygon is not null
            && string.Equals(_editingPolygon.FeatureType, "Title", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsLandFeatureType(string? featureType)
    {
        return string.Equals(featureType, "Land", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsWaterFeatureType(string? featureType)
    {
        return string.Equals(featureType, "Water", StringComparison.OrdinalIgnoreCase);
    }

    private string GetAreaPlacementFeatureType()
    {
        return _placementType == PlacementType.Land ? "Land" : "Water";
    }

    private static float NormalizePointSize(float size)
    {
        return float.IsFinite(size) && size > 0f ? size : 1f;
    }

    private static string NormalizeTitleName(string? name)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return "Untitled";
        }

        var trimmed = name.Trim();
        return trimmed.Length <= TitleNameMaxLength ? trimmed : trimmed[..TitleNameMaxLength];
    }

    private static float NormalizeTitleSize(float size)
    {
        if (!float.IsFinite(size))
        {
            return 1f;
        }

        if (size < TitleSizeMin)
        {
            return TitleSizeMin;
        }

        if (size > TitleSizeMax)
        {
            return TitleSizeMax;
        }

        return size;
    }

    private float GetCanvasScaleX()
    {
        return _canvasClientWidth > 0 ? (CanvasWidth / _canvasClientWidth) : 1f;
    }

    private float GetCanvasScaleY()
    {
        return _canvasClientHeight > 0 ? (CanvasHeight / _canvasClientHeight) : 1f;
    }

    private void ClearEditSelection(bool keepChanges)
    {
        if (!keepChanges && _editingPolygon is not null && _editingOriginalPoints is not null)
        {
            var restoredPoints = _editingOriginalPoints
                .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                .ToList();
            if (IsEditingTitlePolygon() && _editingTitleFeature is not null)
            {
                _editingTitleFeature.Title.Points = restoredPoints;
                _editingPolygon.Points = _editingTitleFeature.Title.Points;
            }
            else
            {
                _editingPolygon.Points = restoredPoints;
            }
        }

        if (!keepChanges && _editingPointFeature is not null && _editingPointOriginalPosition is not null)
        {
            if (_editingPointFeature.Character is null)
            {
                UpdatePointFeaturePosition(_editingPointFeature, _editingPointOriginalPosition.X, _editingPointOriginalPosition.Y);
            }
        }

        if (!keepChanges && _editingTitleFeature is not null && _editingTitleOriginalPosition is not null)
        {
            _editingTitleFeature.Title.X = _editingTitleOriginalPosition.X;
            _editingTitleFeature.Title.Y = _editingTitleOriginalPosition.Y;
        }

        if (!_isUndoing && _undoBatchKind == UndoBatchKind.Edit)
        {
            EndUndoBatch(keepChanges && _undoBatchPushed);
        }

        _editingPolygon = null;
        _editingOriginalPoints = null;
        _editingPointIndex = -1;
        _editingEdgeIndex = -1;
        _isDraggingEditPoint = false;
        _isDraggingEditPolygon = false;
        _editingPolygonDragOrigin = null;
        _editingPolygonDragOriginPoints = null;
        _editingPointFeature = null;
        _editingPointOriginalPosition = null;
        _isDraggingEditPointFeature = false;
        CloseCharacterEditor();
        _editingTitleFeature = null;
        _editingTitleOriginalPosition = null;
        _isDraggingTitleFeature = false;
    }

    private void OpenCharacterEditor(CharacterFeatureDto character, bool readOnly, bool resetRelationshipForm)
    {
        CancelRelationshipEdit();
        _editingCharacter = character;
        _isCharacterEditorOpen = true;
        _isCharacterEditorReadOnly = readOnly;
        if (resetRelationshipForm)
        {
            ResetRelationshipForm();
        }
    }

    private void CloseCharacterEditor()
    {
        CancelRelationshipEdit();
        _editingCharacter = null;
        _isCharacterEditorOpen = false;
        _isCharacterEditorReadOnly = false;
        if (!_isSelectingRelationshipTarget)
        {
            ResetRelationshipForm();
        }
    }

    private void ResetRelationshipForm()
    {
        _relationshipTypesInput = string.Empty;
        _relationshipDescription = string.Empty;
        _relationshipCreateReciprocal = false;
        _relationshipReciprocalTypesInput = string.Empty;
        _relationshipReciprocalDescription = string.Empty;
        _relationshipStatusMessage = string.Empty;
        _relationshipSourceCharacter = null;
        _selectedRelationshipTarget = null;
    }

    private void TrackEditedCharacter(CharacterFeatureDto character, bool redraw)
    {
        if (character.Id > 0 && !_stagedCharacters.Contains(character))
        {
            _editedCharacters[character.Id] = character;
        }

        if (redraw)
        {
            _ = InvokeAsync(DrawAsync);
        }
    }

    private bool IsCharacterEditorReadOnly => _isCharacterEditorReadOnly;

    private void OnCharacterDetailsChanged()
    {
        if (_editingCharacter is null || _isCharacterEditorReadOnly)
        {
            return;
        }

        TrackEditedCharacter(_editingCharacter, redraw: false);
    }

    private void OnCharacterTypeChanged()
    {
        if (_editingCharacter is null || _isCharacterEditorReadOnly)
        {
            return;
        }

        TrackEditedCharacter(_editingCharacter, redraw: true);
    }

    private void OnCharacterPositionChanged()
    {
        if (_editingCharacter is null || _isCharacterEditorReadOnly)
        {
            return;
        }

        _editingCharacter.X = Math.Clamp(_editingCharacter.X, 0f, MapWidth);
        _editingCharacter.Y = Math.Clamp(_editingCharacter.Y, 0f, MapHeight);
        TrackEditedCharacter(_editingCharacter, redraw: true);
    }

    private string EditingCharacterType
    {
        get => _editingCharacter?.CharacterType ?? CharacterStyles.First();
        set
        {
            if (_editingCharacter is null || _isCharacterEditorReadOnly)
            {
                return;
            }

            _editingCharacter.CharacterType = value ?? CharacterStyles.First();
            OnCharacterTypeChanged();
        }
    }

    private float EditingCharacterX
    {
        get => _editingCharacter?.X ?? 0f;
        set
        {
            if (_editingCharacter is null || _isCharacterEditorReadOnly)
            {
                return;
            }

            _editingCharacter.X = value;
            OnCharacterPositionChanged();
        }
    }

    private float EditingCharacterY
    {
        get => _editingCharacter?.Y ?? 0f;
        set
        {
            if (_editingCharacter is null || _isCharacterEditorReadOnly)
            {
                return;
            }

            _editingCharacter.Y = value;
            OnCharacterPositionChanged();
        }
    }

    private string EditingCharacterName
    {
        get => _editingCharacter?.Name ?? string.Empty;
        set
        {
            if (_editingCharacter is null || _isCharacterEditorReadOnly)
            {
                return;
            }

            _editingCharacter.Name = value ?? string.Empty;
            OnCharacterDetailsChanged();
        }
    }

    private string EditingCharacterBackground
    {
        get => _editingCharacter?.Background ?? string.Empty;
        set
        {
            if (_editingCharacter is null || _isCharacterEditorReadOnly)
            {
                return;
            }

            _editingCharacter.Background = value ?? string.Empty;
            OnCharacterDetailsChanged();
        }
    }

    private string EditingCharacterOccupation
    {
        get => _editingCharacter?.Occupation ?? string.Empty;
        set
        {
            if (_editingCharacter is null || _isCharacterEditorReadOnly)
            {
                return;
            }

            _editingCharacter.Occupation = value ?? string.Empty;
            OnCharacterDetailsChanged();
        }
    }

    private string EditingCharacterPersonality
    {
        get => _editingCharacter?.Personality ?? string.Empty;
        set
        {
            if (_editingCharacter is null || _isCharacterEditorReadOnly)
            {
                return;
            }

            _editingCharacter.Personality = value ?? string.Empty;
            OnCharacterDetailsChanged();
        }
    }

    private void BeginRelationshipTargetSelection()
    {
        if (_isSelectingRelationshipTarget)
        {
            return;
        }

        if (_editingCharacter is null || _isCharacterEditorReadOnly)
        {
            return;
        }

        CancelRelationshipEdit();

        if (_editingCharacter.Id <= 0)
        {
            _relationshipStatusMessage = "Save this character before adding relationships.";
            return;
        }

        _relationshipSourceCharacter = _editingCharacter;
        _relationshipReturnTool = _activeTool;
        _relationshipReturnPlacement = _placementType;
        _relationshipReturnReadOnly = _isCharacterEditorReadOnly;
        _isSelectingRelationshipTarget = true;
        _isCharacterEditorOpen = false;
        _relationshipStatusMessage = "Click a target on the map.";
        _statusMessage = "Select a relationship target on the map. Click Cancel to stop.";
    }

    private void CancelRelationshipTargetSelection()
    {
        if (!_isSelectingRelationshipTarget)
        {
            return;
        }

        _isSelectingRelationshipTarget = false;
        _statusMessage = "Relationship target selection canceled.";
        _relationshipStatusMessage = "Relationship target selection canceled.";
        RestoreRelationshipReturnState();

        if (_relationshipSourceCharacter is not null)
        {
            OpenCharacterEditor(_relationshipSourceCharacter, _relationshipReturnReadOnly, resetRelationshipForm: false);
        }
    }

    private void HandleRelationshipTargetSelection(float mapX, float mapY)
    {
        if (!_isSelectingRelationshipTarget || _relationshipSourceCharacter is null)
        {
            _isSelectingRelationshipTarget = false;
            return;
        }

        var selection = TryGetRelationshipTargetAtPoint(mapX, mapY, out var error);
        if (selection is null)
        {
            if (!string.IsNullOrWhiteSpace(error))
            {
                _statusMessage = error;
                _relationshipStatusMessage = error;
            }
            return;
        }

        _isSelectingRelationshipTarget = false;
        _selectedRelationshipTarget = selection;
        RestoreRelationshipReturnState();
        OpenCharacterEditor(_relationshipSourceCharacter, _relationshipReturnReadOnly, resetRelationshipForm: false);
        _relationshipStatusMessage = "Target selected. Enter relationship details.";
        _statusMessage = "Relationship target selected. Enter relationship details and add the relationship.";
    }

    private void ClearSelectedRelationshipTarget()
    {
        _selectedRelationshipTarget = null;
        _relationshipTypesInput = string.Empty;
        _relationshipDescription = string.Empty;
        _relationshipReciprocalTypesInput = string.Empty;
        _relationshipReciprocalDescription = string.Empty;
        _relationshipCreateReciprocal = false;
        _relationshipStatusMessage = "Relationship target cleared.";
    }

    private void AddSelectedRelationship()
    {
        if (_editingCharacter is null || _isCharacterEditorReadOnly)
        {
            return;
        }

        if (_editingCharacter.Id <= 0)
        {
            _relationshipStatusMessage = "Save this character before adding relationships.";
            return;
        }

        if (_selectedRelationshipTarget is null)
        {
            _relationshipStatusMessage = "Select a relationship target first.";
            return;
        }

        _relationshipSourceCharacter = _editingCharacter;
        var request = BuildRelationshipRequest(_selectedRelationshipTarget.TargetId, _selectedRelationshipTarget.IsCharacter);
        if (request is null)
        {
            _relationshipStatusMessage = "Enter at least one relationship type.";
            return;
        }

        StageRelationship(request);
        _selectedRelationshipTarget = null;
        _relationshipTypesInput = string.Empty;
        _relationshipDescription = string.Empty;
        _relationshipReciprocalTypesInput = string.Empty;
        _relationshipReciprocalDescription = string.Empty;
        _relationshipCreateReciprocal = false;
        _relationshipStatusMessage = "Relationship staged. Save All to persist.";
        _statusMessage = "Relationship staged (unsaved).";
    }

    private void RestoreRelationshipReturnState()
    {
        _activeTool = _relationshipReturnTool;
        _placementType = _relationshipReturnPlacement;
    }

    private AddCharacterRelationshipDto? BuildRelationshipRequest(int targetId, bool isCharacterTarget)
    {
        if (_relationshipSourceCharacter is null)
        {
            return null;
        }

        var types = NormalizeRelationshipTypes(ParseRelationshipTypes(_relationshipTypesInput));
        if (types.Count == 0)
        {
            return null;
        }

        var description = NormalizeRelationshipDescription(_relationshipDescription);

        var request = new AddCharacterRelationshipDto
        {
            SourceCharacterId = _relationshipSourceCharacter.Id,
            TargetFeatureId = targetId,
            RelationshipTypes = types,
            Description = description,
            CreateReciprocal = _relationshipCreateReciprocal && isCharacterTarget
        };

        if (request.CreateReciprocal)
        {
            var reciprocalTypes = NormalizeRelationshipTypes(ParseRelationshipTypes(_relationshipReciprocalTypesInput));
            request.ReciprocalRelationshipTypes = reciprocalTypes.Count > 0 ? reciprocalTypes : null;
            request.ReciprocalDescription = string.IsNullOrWhiteSpace(_relationshipReciprocalDescription)
                ? null
                : _relationshipReciprocalDescription.Trim();
        }

        return request;
    }

    private RelationshipTargetSelection? TryGetRelationshipTargetAtPoint(float mapX, float mapY, out string? error)
    {
        error = null;
        var hitRadius = GetEditHitRadius();
        var pointFeature = FindPointFeatureAtPoint(mapX, mapY, hitRadius, EraserTarget.All, false, true);

        if (pointFeature is not null)
        {
            if (pointFeature.IsStaged)
            {
                error = "Target must be saved before adding relationships.";
                return null;
            }

            if (pointFeature.Character is not null)
            {
                if (pointFeature.Character.Id <= 0)
                {
                    error = "Target must be saved before adding relationships.";
                    return null;
                }

                if (_relationshipSourceCharacter is not null && pointFeature.Character.Id == _relationshipSourceCharacter.Id)
                {
                    error = "Pick a different character as the target.";
                    return null;
                }

                return new RelationshipTargetSelection(pointFeature.Character.Id, true);
            }

            if (pointFeature.Tree is not null)
            {
                if (pointFeature.Tree.Id <= 0)
                {
                    error = "Target must be saved before adding relationships.";
                    return null;
                }

                return new RelationshipTargetSelection(pointFeature.Tree.Id, false);
            }

            if (pointFeature.House is not null)
            {
                if (pointFeature.House.Id <= 0)
                {
                    error = "Target must be saved before adding relationships.";
                    return null;
                }

                return new RelationshipTargetSelection(pointFeature.House.Id, false);
            }
        }

        var polygon = FindSavedPolygonAtPoint(mapX, mapY);
        if (polygon is not null)
        {
            return new RelationshipTargetSelection(polygon.Id, false);
        }

        var titleFeature = FindTitleFeatureAtPoint(mapX, mapY, hitRadius);
        if (titleFeature is not null)
        {
            error = "Titles cannot be relationship targets.";
            return null;
        }

        error = "Click a saved feature to select it.";
        return null;
    }

    private AreaPolygonDto? FindSavedPolygonAtPoint(float mapX, float mapY)
    {
        AreaPolygonDto? selected = null;
        var selectedLayer = int.MinValue;
        var selectedOrder = -1;
        var candidates = _waterPolygons.Concat(_landPolygons).ToList();

        for (var i = 0; i < candidates.Count; i += 1)
        {
            var polygon = candidates[i];
            if (polygon.Id <= 0 || polygon.Points.Count < 3)
            {
                continue;
            }

            if (!IsPointInPolygon(mapX, mapY, polygon))
            {
                continue;
            }

            var layerIndex = polygon.LayerIndex;
            if (layerIndex > selectedLayer || (layerIndex == selectedLayer && i > selectedOrder))
            {
                selected = polygon;
                selectedLayer = layerIndex;
                selectedOrder = i;
            }
        }

        return selected;
    }

    private void StageRelationship(AddCharacterRelationshipDto request)
    {
        var existing = _stagedRelationships.FirstOrDefault(relationship =>
            relationship.SourceCharacterId == request.SourceCharacterId
            && relationship.TargetFeatureId == request.TargetFeatureId);

        if (existing is null)
        {
            _stagedRelationships.Add(request);
            return;
        }

        existing.RelationshipTypes = NormalizeRelationshipTypes(existing.RelationshipTypes.Concat(request.RelationshipTypes));
        if (!string.IsNullOrWhiteSpace(request.Description))
        {
            existing.Description = request.Description;
        }

        if (request.CreateReciprocal)
        {
            existing.CreateReciprocal = true;
            if (request.ReciprocalRelationshipTypes is not null && request.ReciprocalRelationshipTypes.Count > 0)
            {
                var current = existing.ReciprocalRelationshipTypes ?? new List<string>();
                existing.ReciprocalRelationshipTypes = NormalizeRelationshipTypes(current.Concat(request.ReciprocalRelationshipTypes));
            }
            if (!string.IsNullOrWhiteSpace(request.ReciprocalDescription))
            {
                existing.ReciprocalDescription = request.ReciprocalDescription;
            }
        }
    }

    private void DeleteExistingRelationship(CharacterRelationshipDto relationship)
    {
        if (_editingCharacter is null || _isCharacterEditorReadOnly || relationship is null || relationship.Id <= 0)
        {
            return;
        }

        StageRelationshipDeletion(relationship.Id, _editingCharacter.Id, relationship.TargetFeatureId);
        _editingCharacter.Relationships.RemoveAll(item => item.Id == relationship.Id);
        if (_characters.FirstOrDefault(character => character.Id == _editingCharacter.Id) is { } sourceCharacter
            && !ReferenceEquals(sourceCharacter, _editingCharacter))
        {
            sourceCharacter.Relationships.RemoveAll(item => item.Id == relationship.Id);
        }
        _relationshipStatusMessage = "Relationship deletion staged. Save All to persist.";
        _statusMessage = "Relationship deletion staged (unsaved).";
    }

    private void RemovePendingRelationship(AddCharacterRelationshipDto relationship)
    {
        if (_isCharacterEditorReadOnly || relationship is null)
        {
            return;
        }

        var removedCount = _stagedRelationships.RemoveAll(item =>
            item.SourceCharacterId == relationship.SourceCharacterId
            && item.TargetFeatureId == relationship.TargetFeatureId);
        if (removedCount == 0)
        {
            return;
        }

        _relationshipStatusMessage = "Pending relationship removed.";
        _statusMessage = "Pending relationship removed.";
    }

    private void DeletePendingRelationshipUpdate(UpdateCharacterRelationshipDto relationship)
    {
        if (_editingCharacter is null || _isCharacterEditorReadOnly || relationship is null || relationship.Id <= 0)
        {
            return;
        }

        var existing = _editingCharacter.Relationships
            .FirstOrDefault(item => item.Id == relationship.Id);
        if (existing is not null)
        {
            DeleteExistingRelationship(existing);
            return;
        }

        StageRelationshipDeletion(relationship.Id, relationship.SourceCharacterId, relationship.TargetFeatureId);
        _relationshipStatusMessage = "Relationship deletion staged. Save All to persist.";
        _statusMessage = "Relationship deletion staged (unsaved).";
    }

    private void StageRelationshipDeletion(int relationshipId, int sourceCharacterId, int targetFeatureId)
    {
        if (relationshipId <= 0 || sourceCharacterId <= 0 || targetFeatureId <= 0)
        {
            return;
        }

        _stagedRelationships.RemoveAll(item =>
            item.SourceCharacterId == sourceCharacterId
            && item.TargetFeatureId == targetFeatureId);
        _updatedRelationships.Remove(relationshipId);
        _deletedRelationships[relationshipId] = (sourceCharacterId, targetFeatureId);

        if (_editingRelationshipId == relationshipId)
        {
            CancelRelationshipEdit();
        }
    }

    private void BeginRelationshipEdit(CharacterRelationshipDto relationship)
    {
        if (_editingCharacter is null || _isCharacterEditorReadOnly || relationship is null || relationship.Id <= 0)
        {
            return;
        }

        _editingRelationshipId = relationship.Id;
        _editingRelationshipTargetFeatureId = relationship.TargetFeatureId;
        _editingRelationshipTargetFeatureType = relationship.TargetFeatureType;

        if (_updatedRelationships.TryGetValue(relationship.Id, out var pendingUpdate))
        {
            _relationshipEditTypesInput = string.Join(", ", pendingUpdate.RelationshipTypes);
            _relationshipEditDescription = pendingUpdate.Description ?? string.Empty;
        }
        else
        {
            _relationshipEditTypesInput = string.Join(", ", relationship.RelationshipTypes ?? new List<string>());
            _relationshipEditDescription = relationship.Description ?? string.Empty;
        }

        _relationshipStatusMessage = "Editing relationship details.";
    }

    private void ApplyRelationshipEdit()
    {
        if (_editingCharacter is null || _isCharacterEditorReadOnly || _editingRelationshipId is null)
        {
            return;
        }

        var relationship = _editingCharacter.Relationships
            .FirstOrDefault(item => item.Id == _editingRelationshipId.Value);
        if (relationship is null)
        {
            CancelRelationshipEdit();
            _relationshipStatusMessage = "Relationship not found.";
            return;
        }

        var types = NormalizeRelationshipTypes(ParseRelationshipTypes(_relationshipEditTypesInput));
        if (types.Count == 0)
        {
            _relationshipStatusMessage = "Enter at least one relationship type.";
            return;
        }

        var description = NormalizeRelationshipDescription(_relationshipEditDescription);
        relationship.RelationshipTypes = types;
        relationship.Description = description;

        _stagedRelationships.RemoveAll(item =>
            item.SourceCharacterId == _editingCharacter.Id
            && item.TargetFeatureId == relationship.TargetFeatureId);

        _updatedRelationships[relationship.Id] = new UpdateCharacterRelationshipDto
        {
            Id = relationship.Id,
            SourceCharacterId = _editingCharacter.Id,
            TargetFeatureId = relationship.TargetFeatureId,
            RelationshipTypes = new List<string>(types),
            Description = description
        };
        _deletedRelationships.Remove(relationship.Id);

        CancelRelationshipEdit();
        _relationshipStatusMessage = "Relationship update staged. Save All to persist.";
        _statusMessage = "Relationship update staged (unsaved).";
    }

    private void CancelRelationshipEdit()
    {
        _editingRelationshipId = null;
        _editingRelationshipTargetFeatureId = 0;
        _editingRelationshipTargetFeatureType = string.Empty;
        _relationshipEditTypesInput = string.Empty;
        _relationshipEditDescription = string.Empty;
    }

    private IReadOnlyList<AddCharacterRelationshipDto> GetPendingRelationshipsForCharacter(int characterId)
    {
        return _stagedRelationships
            .Where(relationship => relationship.SourceCharacterId == characterId)
            .ToList();
    }

    private IReadOnlyList<UpdateCharacterRelationshipDto> GetPendingRelationshipUpdatesForCharacter(int characterId)
    {
        return _updatedRelationships.Values
            .Where(relationship =>
                relationship.SourceCharacterId == characterId
                && !_deletedRelationships.ContainsKey(relationship.Id))
            .OrderBy(relationship => relationship.Id)
            .ToList();
    }

    private bool IsRelationshipUpdateStaged(int relationshipId)
    {
        return relationshipId > 0 && _updatedRelationships.ContainsKey(relationshipId);
    }

    private void RemoveStagedRelationshipChangesForTarget(int targetFeatureId)
    {
        if (targetFeatureId <= 0)
        {
            return;
        }

        _stagedRelationships.RemoveAll(relationship =>
            relationship.SourceCharacterId == targetFeatureId
            || relationship.TargetFeatureId == targetFeatureId);

        var pendingUpdateIds = _updatedRelationships.Values
            .Where(relationship =>
                relationship.SourceCharacterId == targetFeatureId
                || relationship.TargetFeatureId == targetFeatureId)
            .Select(relationship => relationship.Id)
            .ToList();

        foreach (var relationshipId in pendingUpdateIds)
        {
            _updatedRelationships.Remove(relationshipId);
        }

        var pendingDeleteIds = _deletedRelationships
            .Where(item =>
                item.Value.SourceCharacterId == targetFeatureId
                || item.Value.TargetFeatureId == targetFeatureId)
            .Select(item => item.Key)
            .ToList();

        foreach (var relationshipId in pendingDeleteIds)
        {
            _deletedRelationships.Remove(relationshipId);
        }

        if (_editingRelationshipId is not null
            && (pendingUpdateIds.Contains(_editingRelationshipId.Value) || pendingDeleteIds.Contains(_editingRelationshipId.Value)))
        {
            CancelRelationshipEdit();
        }
    }

    private string GetRelationshipTargetLabel(int targetId, string targetType)
    {
        if (targetId <= 0)
        {
            return "Unknown target";
        }

        var existingLabel = TryGetTargetLabelById(targetId);
        if (!string.IsNullOrWhiteSpace(existingLabel))
        {
            return existingLabel;
        }

        if (string.IsNullOrWhiteSpace(targetType) || string.Equals(targetType, "Pending", StringComparison.OrdinalIgnoreCase))
        {
            return $"Feature #{targetId}";
        }

        return $"{targetType} #{targetId}";
    }

    private string? TryGetTargetLabelById(int targetId)
    {
        var character = _characters.FirstOrDefault(item => item.Id == targetId);
        if (character is not null)
        {
            return string.IsNullOrWhiteSpace(character.Name)
                ? $"Character #{character.Id}"
                : $"{character.Name} (Character #{character.Id})";
        }

        if (_trees.Any(item => item.Id == targetId))
        {
            return $"Tree #{targetId}";
        }

        if (_houses.Any(item => item.Id == targetId))
        {
            return $"House #{targetId}";
        }

        if (_landPolygons.Any(item => item.Id == targetId))
        {
            return $"Land #{targetId}";
        }

        if (_waterPolygons.Any(item => item.Id == targetId))
        {
            return $"Water #{targetId}";
        }

        return null;
    }

    private static List<string> ParseRelationshipTypes(string? input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return new List<string>();
        }

        return input
            .Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
            .ToList();
    }

    private static List<string> NormalizeRelationshipTypes(IEnumerable<string>? values)
    {
        if (values is null)
        {
            return new List<string>();
        }

        return values
            .Select(value => value?.Trim())
            .Where(value => !string.IsNullOrWhiteSpace(value))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .Select(value => value!)
            .ToList();
    }

    private static string NormalizeRelationshipDescription(string? description)
    {
        return string.IsNullOrWhiteSpace(description) ? string.Empty : description.Trim();
    }

    private static string FormatRelationshipTypes(IEnumerable<string>? values)
    {
        if (values is null)
        {
            return string.Empty;
        }

        var list = values.Where(value => !string.IsNullOrWhiteSpace(value)).ToList();
        return list.Count == 0 ? string.Empty : string.Join(", ", list);
    }

    private void TrackEditedPolygon(AreaPolygonDto polygon)
    {
        if (polygon.Id <= 0)
        {
            return;
        }

        if (IsLandFeatureType(polygon.FeatureType))
        {
            _editedLandPolygons[polygon.Id] = ClonePolygon(polygon);
        }
        else
        {
            _editedWaterPolygons[polygon.Id] = ClonePolygon(polygon);
        }
    }

    private void TrackEditedPointFeature(EditingPointFeature feature)
    {
        if (feature.Tree is not null)
        {
            if (feature.IsStaged || feature.Tree.Id <= 0)
            {
                return;
            }

            _editedTrees[feature.Tree.Id] = feature.Tree;
            return;
        }

        if (feature.House is not null)
        {
            if (feature.IsStaged || feature.House.Id <= 0)
            {
                return;
            }

            _editedHouses[feature.House.Id] = feature.House;
            return;
        }

        if (feature.Character is not null)
        {
            if (feature.IsStaged || feature.Character.Id <= 0)
            {
                return;
            }

            _editedCharacters[feature.Character.Id] = feature.Character;
        }
    }

    private void TrackEditedTitleFeature(EditingTitleFeature feature)
    {
        if (feature.IsStaged || feature.Title.Id <= 0)
        {
            return;
        }

        _editedTitles[feature.Title.Id] = feature.Title;
    }

    private static AreaPolygonDto ClonePolygon(AreaPolygonDto polygon)
    {
        return CloneDto(polygon);
    }

    private AreaPolygonDto? FindPolygonAtPoint(float mapX, float mapY)
    {
        return FindPolygonAtPoint(mapX, mapY, true, null);
    }

    private AreaPolygonDto? FindPolygonAtPoint(float mapX, float mapY, bool restrictToActiveLayer)
    {
        return FindPolygonAtPoint(mapX, mapY, restrictToActiveLayer, null);
    }

    private AreaPolygonDto? FindPolygonAtPoint(float mapX, float mapY, bool restrictToActiveLayer, string? featureTypeFilter)
    {
        var activeLayerIndex = restrictToActiveLayer ? _activeAreaLayer?.LayerIndex : null;
        var candidates = GetPolygonCandidates(featureTypeFilter);
        AreaPolygonDto? selected = null;
        var selectedLayer = int.MinValue;
        var selectedOrder = -1;

        for (var i = 0; i < candidates.Count; i += 1)
        {
            var polygon = candidates[i];
            if (polygon.Points.Count < 3)
            {
                continue;
            }

            if (activeLayerIndex is not null && polygon.LayerIndex != activeLayerIndex.Value)
            {
                continue;
            }

            if (!IsPointInPolygon(mapX, mapY, polygon))
            {
                continue;
            }

            var layerIndex = polygon.LayerIndex;
            if (layerIndex > selectedLayer || (layerIndex == selectedLayer && i > selectedOrder))
            {
                selected = polygon;
                selectedLayer = layerIndex;
                selectedOrder = i;
            }
        }

        return selected;
    }

    private List<AreaPolygonDto> GetPolygonCandidates(string? featureTypeFilter)
    {
        IEnumerable<AreaPolygonDto> candidates = _waterPolygons.Concat(_stagedWaterPolygons)
            .Concat(_landPolygons)
            .Concat(_stagedLandPolygons);

        if (!string.IsNullOrWhiteSpace(featureTypeFilter))
        {
            candidates = candidates.Where(polygon => string.Equals(
                polygon.FeatureType,
                featureTypeFilter,
                StringComparison.OrdinalIgnoreCase));
        }

        return candidates.ToList();
    }

    private async Task DuplicateFeatureAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        var hitRadius = GetEditHitRadius();
        if (_placementType == PlacementType.Title)
        {
            var titleFeature = FindTitleFeatureAtPoint(mapX, mapY, hitRadius);
            if (titleFeature is not null)
            {
                var placed = DuplicateTitleFeature(titleFeature);
                _statusMessage = placed
                    ? "Title duplicated (unsaved)."
                    : "Duplicate failed (feature out of bounds).";
                if (placed)
                {
                    await DrawAsync();
                }
                return;
            }
        }

        var pointFeature = FindPointFeatureAtPoint(mapX, mapY, hitRadius);
        if (pointFeature is not null)
        {
            var placed = DuplicatePointFeature(pointFeature);
            _statusMessage = placed
                ? "Feature duplicated (unsaved)."
                : "Duplicate failed (feature out of bounds).";
            if (placed)
            {
                await DrawAsync();
            }
            return;
        }

        if (_placementType != PlacementType.Title)
        {
            var titleFeature = FindTitleFeatureAtPoint(mapX, mapY, hitRadius);
            if (titleFeature is not null)
            {
                var placed = DuplicateTitleFeature(titleFeature);
                _statusMessage = placed
                    ? "Title duplicated (unsaved)."
                    : "Duplicate failed (feature out of bounds).";
                if (placed)
                {
                    await DrawAsync();
                }
                return;
            }
        }

        var polygon = FindPolygonAtPoint(mapX, mapY, false);
        if (polygon is not null)
        {
            DuplicatePolygon(polygon);
            _statusMessage = "Polygon duplicated (unsaved).";
            await DrawAsync();
            return;
        }

        _statusMessage = "No feature found to duplicate.";
    }

    private bool DuplicatePointFeature(EditingPointFeature feature)
    {
        var source = GetPointFeaturePosition(feature);
        if (source is null)
        {
            return false;
        }

        PushUndoState();
        var (newX, newY) = GetAdjacentPoint(source.X, source.Y);

        if (feature.Tree is not null)
        {
            var clone = CloneDto(feature.Tree);
            clone.Id = 0;
            clone.X = newX;
            clone.Y = newY;
            _stagedTrees.Add(clone);
            return true;
        }

        if (feature.House is not null)
        {
            var clone = CloneDto(feature.House);
            clone.Id = 0;
            clone.X = newX;
            clone.Y = newY;
            _stagedHouses.Add(clone);
            return true;
        }

        if (feature.Character is not null)
        {
            var clone = CloneDto(feature.Character);
            clone.Id = 0;
            clone.X = newX;
            clone.Y = newY;
            _stagedCharacters.Add(clone);
            return true;
        }

        return false;
    }

    private bool DuplicateTitleFeature(EditingTitleFeature feature)
    {
        PushUndoState();
        var clone = CloneDto(feature.Title);
        clone.Id = 0;

        if (clone.Points is not null && clone.Points.Count >= 3)
        {
            var (offsetX, offsetY) = GetAdjacentOffsetForPoints(clone.Points);
            foreach (var point in clone.Points)
            {
                point.X = Math.Clamp(point.X + offsetX, 0f, MapWidth);
                point.Y = Math.Clamp(point.Y + offsetY, 0f, MapHeight);
            }
            clone.X = Math.Clamp(clone.X + offsetX, 0f, MapWidth);
            clone.Y = Math.Clamp(clone.Y + offsetY, 0f, MapHeight);
        }
        else if (!clone.TargetFeatureId.HasValue)
        {
            var position = GetTitlePosition(feature.Title);
            var (newX, newY) = GetAdjacentPoint(position.X, position.Y);
            clone.X = newX;
            clone.Y = newY;
        }

        _stagedTitles.Add(clone);
        return true;
    }

    private void DuplicatePolygon(AreaPolygonDto polygon)
    {
        PushUndoState();
        var clone = CloneDto(polygon);
        clone.Id = 0;
        var (offsetX, offsetY) = GetAdjacentOffsetForPolygon(clone);

        foreach (var point in clone.Points)
        {
            point.X = Math.Clamp(point.X + offsetX, 0f, MapWidth);
            point.Y = Math.Clamp(point.Y + offsetY, 0f, MapHeight);
        }

        if (IsLandFeatureType(clone.FeatureType))
        {
            _stagedLandPolygons.Add(clone);
        }
        else
        {
            _stagedWaterPolygons.Add(clone);
        }
    }

    private static T CloneDto<T>(T source)
    {
        var json = JsonSerializer.Serialize(source);
        var clone = JsonSerializer.Deserialize<T>(json);
        if (clone is null)
        {
            throw new InvalidOperationException("Failed to clone map feature.");
        }
        return clone;
    }

    private (float X, float Y) GetAdjacentPoint(float x, float y)
    {
        var offset = GetDuplicateOffset();
        var candidates = new (float Dx, float Dy)[]
        {
            (offset, 0f),
            (0f, offset),
            (-offset, 0f),
            (0f, -offset),
            (offset, offset),
            (-offset, offset),
            (offset, -offset),
            (-offset, -offset)
        };

        foreach (var (dx, dy) in candidates)
        {
            var nx = x + dx;
            var ny = y + dy;
            if (nx >= 0f && nx <= MapWidth && ny >= 0f && ny <= MapHeight)
            {
                return (nx, ny);
            }
        }

        return (Math.Clamp(x + offset, 0f, MapWidth), Math.Clamp(y + offset, 0f, MapHeight));
    }

    private (float Dx, float Dy) GetAdjacentOffsetForPolygon(AreaPolygonDto polygon)
    {
        if (polygon.Points.Count == 0)
        {
            return (0f, 0f);
        }

        var offset = GetDuplicateOffset();
        var minX = polygon.Points.Min(point => point.X);
        var maxX = polygon.Points.Max(point => point.X);
        var minY = polygon.Points.Min(point => point.Y);
        var maxY = polygon.Points.Max(point => point.Y);
        var minDx = -minX;
        var maxDx = MapWidth - maxX;
        var minDy = -minY;
        var maxDy = MapHeight - maxY;

        var candidates = new (float Dx, float Dy)[]
        {
            (offset, 0f),
            (0f, offset),
            (-offset, 0f),
            (0f, -offset),
            (offset, offset),
            (-offset, offset),
            (offset, -offset),
            (-offset, -offset)
        };

        foreach (var (dx, dy) in candidates)
        {
            if (dx >= minDx && dx <= maxDx && dy >= minDy && dy <= maxDy)
            {
                return (dx, dy);
            }
        }

        return (Math.Clamp(offset, minDx, maxDx), Math.Clamp(offset, minDy, maxDy));
    }

    private (float Dx, float Dy) GetAdjacentOffsetForPoints(IReadOnlyList<MapPointDto> points)
    {
        if (points is null || points.Count == 0)
        {
            return (0f, 0f);
        }

        var offset = GetDuplicateOffset();
        var minX = points.Min(point => point.X);
        var maxX = points.Max(point => point.X);
        var minY = points.Min(point => point.Y);
        var maxY = points.Max(point => point.Y);
        var minDx = -minX;
        var maxDx = MapWidth - maxX;
        var minDy = -minY;
        var maxDy = MapHeight - maxY;

        var candidates = new (float Dx, float Dy)[]
        {
            (offset, 0f),
            (0f, offset),
            (-offset, 0f),
            (0f, -offset),
            (offset, offset),
            (-offset, offset),
            (offset, -offset),
            (-offset, -offset)
        };

        foreach (var (dx, dy) in candidates)
        {
            if (dx >= minDx && dx <= maxDx && dy >= minDy && dy <= maxDy)
            {
                return (dx, dy);
            }
        }

        return (Math.Clamp(offset, minDx, maxDx), Math.Clamp(offset, minDy, maxDy));
    }

    private float GetDuplicateOffset()
    {
        return MathF.Max(16f, GetEditHitRadius() * 1.5f);
    }

    private bool TryErasePolygonAtPoint(float mapX, float mapY, string? featureTypeFilter = null)
    {
        var polygon = FindPolygonAtPoint(mapX, mapY, true, featureTypeFilter);
        if (polygon is null)
        {
            return false;
        }

        if (_editingPolygon == polygon)
        {
            ClearEditSelection(true);
        }

        if (IsLandFeatureType(polygon.FeatureType))
        {
            if (polygon.Id > 0)
            {
                _deletedLandPolygonIds.Add(polygon.Id);
                _editedLandPolygons.Remove(polygon.Id);
            }

            _landPolygons.Remove(polygon);
            _stagedLandPolygons.Remove(polygon);
        }
        else
        {
            if (polygon.Id > 0)
            {
                _deletedWaterPolygonIds.Add(polygon.Id);
                _editedWaterPolygons.Remove(polygon.Id);
            }

            _waterPolygons.Remove(polygon);
            _stagedWaterPolygons.Remove(polygon);
        }

        RemoveStagedRelationshipChangesForTarget(polygon.Id);

        return true;
    }

    private bool TryErasePointFeatureAtPoint(float mapX, float mapY, EraserTarget target, out string? status)
    {
        status = null;
        EnsureAreaLayers();
        var feature = FindPointFeatureAtPoint(mapX, mapY, GetEditHitRadius(), target, true);
        if (feature is null)
        {
            return false;
        }

        if (_editingPointFeature is not null
            && ((_editingPointFeature.Tree is not null && _editingPointFeature.Tree == feature.Tree)
                || (_editingPointFeature.House is not null && _editingPointFeature.House == feature.House)
                || (_editingPointFeature.Character is not null && _editingPointFeature.Character == feature.Character)))
        {
            ClearEditSelection(true);
        }

        if (feature.Tree is not null)
        {
            if (feature.IsStaged)
            {
                _stagedTrees.Remove(feature.Tree);
            }
            else
            {
                if (feature.Tree.Id > 0)
                {
                    _deletedTreeIds.Add(feature.Tree.Id);
                }
                _editedTrees.Remove(feature.Tree.Id);
                _trees.Remove(feature.Tree);
                RemoveTitlesForTargetFeature(feature.Tree.Id);
            }

            RemoveStagedRelationshipChangesForTarget(feature.Tree.Id);

            status = "Tree erased (unsaved).";
            return true;
        }

        if (feature.House is not null)
        {
            if (feature.IsStaged)
            {
                _stagedHouses.Remove(feature.House);
            }
            else
            {
                if (feature.House.Id > 0)
                {
                    _deletedHouseIds.Add(feature.House.Id);
                }
                _editedHouses.Remove(feature.House.Id);
                _houses.Remove(feature.House);
                RemoveTitlesForTargetFeature(feature.House.Id);
            }

            RemoveStagedRelationshipChangesForTarget(feature.House.Id);

            status = "House erased (unsaved).";
            return true;
        }

        if (feature.Character is not null)
        {
            if (feature.IsStaged)
            {
                _stagedCharacters.Remove(feature.Character);
            }
            else
            {
                if (feature.Character.Id > 0)
                {
                    _deletedCharacterIds.Add(feature.Character.Id);
                }
                _editedCharacters.Remove(feature.Character.Id);
                _characters.Remove(feature.Character);
            }

            RemoveStagedRelationshipChangesForTarget(feature.Character.Id);

            if (_editingCharacter == feature.Character)
            {
                CloseCharacterEditor();
            }

            status = "Character erased (unsaved).";
            return true;
        }

        return false;
    }

    private bool TryEraseTitleAtPoint(float mapX, float mapY, out string? status)
    {
        status = null;
        var title = FindTitleFeatureAtPoint(mapX, mapY, GetEditHitRadius());
        if (title is null)
        {
            return false;
        }

        if (_editingTitleFeature is not null && _editingTitleFeature.Title == title.Title)
        {
            ClearEditSelection(true);
        }

        if (title.IsStaged)
        {
            _stagedTitles.Remove(title.Title);
        }
        else
        {
            if (title.Title.Id > 0)
            {
                _deletedTitleIds.Add(title.Title.Id);
            }
            _editedTitles.Remove(title.Title.Id);
            _titles.Remove(title.Title);
        }

        status = "Title erased (unsaved).";
        return true;
    }

    private void RemoveTitlesForTargetFeature(int featureId)
    {
        if (featureId <= 0)
        {
            return;
        }

        var stagedMatches = _stagedTitles
            .Where(title => title.TargetFeatureId == featureId)
            .ToList();
        foreach (var title in stagedMatches)
        {
            _stagedTitles.Remove(title);
        }

        var matches = _titles
            .Where(title => title.TargetFeatureId == featureId)
            .ToList();
        foreach (var title in matches)
        {
            _titles.Remove(title);
            if (title.Id > 0)
            {
                _deletedTitleIds.Add(title.Id);
            }
            _editedTitles.Remove(title.Id);
        }
    }

    private bool TryEraseAtPoint(float mapX, float mapY, out string? status, bool showEmptyStatus)
    {
        status = null;
        var erased = false;

        if (_eraserTarget == EraserTarget.Tree
            || _eraserTarget == EraserTarget.House
            || _eraserTarget == EraserTarget.Character)
        {
            erased = TryErasePointFeatureAtPoint(mapX, mapY, _eraserTarget, out status);
            if (!erased && showEmptyStatus)
            {
                status = $"Nothing to erase for {GetEraserTargetLabel(_eraserTarget)}.";
            }

            return erased;
        }

        if (_eraserTarget == EraserTarget.Water)
        {
            EnsureAreaLayers();
            if (_activeAreaLayer is null)
            {
                status = "Select a layer before erasing.";
                return false;
            }

            erased = TryErasePolygonAtPoint(mapX, mapY, "Water");
            if (showEmptyStatus)
            {
                status = erased
                    ? $"Polygon erased from {GetLayerLabel(_activeAreaLayer)} (unsaved)."
                    : $"Nothing to erase on {GetLayerLabel(_activeAreaLayer)}.";
            }

            return erased;
        }

        if (_eraserTarget == EraserTarget.Land)
        {
            EnsureAreaLayers();
            if (_activeAreaLayer is null)
            {
                status = "Select a layer before erasing.";
                return false;
            }

            erased = TryErasePolygonAtPoint(mapX, mapY, "Land");
            if (showEmptyStatus)
            {
                status = erased
                    ? $"Polygon erased from {GetLayerLabel(_activeAreaLayer)} (unsaved)."
                    : $"Nothing to erase on {GetLayerLabel(_activeAreaLayer)}.";
            }

            return erased;
        }

        erased = TryEraseTitleAtPoint(mapX, mapY, out status);
        if (!erased)
        {
            erased = TryErasePointFeatureAtPoint(mapX, mapY, EraserTarget.All, out status);
        }

        if (!erased)
        {
            EnsureAreaLayers();
            if (_activeAreaLayer is null)
            {
                status = "Select a layer before erasing.";
                return false;
            }

            erased = TryErasePolygonAtPoint(mapX, mapY);
            if (showEmptyStatus)
            {
                status = erased
                    ? $"Polygon erased from {GetLayerLabel(_activeAreaLayer)} (unsaved)."
                    : $"Nothing to erase on {GetLayerLabel(_activeAreaLayer)}.";
            }
        }

        return erased;
    }

    private EditingPointFeature? FindPointFeatureAtPoint(float mapX, float mapY, float threshold)
    {
        return FindPointFeatureAtPoint(mapX, mapY, threshold, EraserTarget.All, false, true);
    }

    private EditingPointFeature? FindPointFeatureAtPoint(
        float mapX,
        float mapY,
        float threshold,
        EraserTarget target,
        bool restrictToActiveLayer,
        bool includeCharacters = true)
    {
        if (target == EraserTarget.Water)
        {
            return null;
        }

        if (target == EraserTarget.Land)
        {
            return null;
        }

        var thresholdSquared = threshold * threshold;
        EditingPointFeature? best = null;
        var bestDistance = float.MaxValue;
        var considerTrees = target == EraserTarget.All || target == EraserTarget.Tree;
        var considerHouses = target == EraserTarget.All || target == EraserTarget.House;
        var considerCharacters = includeCharacters && (target == EraserTarget.All || target == EraserTarget.Character);
        var activeLayerIndex = restrictToActiveLayer ? _activeAreaLayer?.LayerIndex : null;

        void ConsiderTree(TreeFeatureDto tree, bool isStaged)
        {
            if (activeLayerIndex is not null && tree.LayerIndex != activeLayerIndex.Value)
            {
                return;
            }

            var dx = tree.X - mapX;
            var dy = tree.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance > thresholdSquared || distance >= bestDistance)
            {
                return;
            }

            bestDistance = distance;
            best = new EditingPointFeature
            {
                Tree = tree,
                House = null,
                Character = null,
                IsStaged = isStaged
            };
        }

        void ConsiderHouse(HouseFeatureDto house, bool isStaged)
        {
            if (activeLayerIndex is not null && house.LayerIndex != activeLayerIndex.Value)
            {
                return;
            }

            var dx = house.X - mapX;
            var dy = house.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance > thresholdSquared || distance >= bestDistance)
            {
                return;
            }

            bestDistance = distance;
            best = new EditingPointFeature
            {
                Tree = null,
                House = house,
                Character = null,
                IsStaged = isStaged
            };
        }

        void ConsiderCharacter(CharacterFeatureDto character, bool isStaged)
        {
            if (activeLayerIndex is not null && character.LayerIndex != activeLayerIndex.Value)
            {
                return;
            }

            var dx = character.X - mapX;
            var dy = character.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance > thresholdSquared || distance >= bestDistance)
            {
                return;
            }

            bestDistance = distance;
            best = new EditingPointFeature
            {
                Tree = null,
                House = null,
                Character = character,
                IsStaged = isStaged
            };
        }

        if (considerTrees)
        {
            foreach (var tree in _trees)
            {
                ConsiderTree(tree, false);
            }

            foreach (var tree in _stagedTrees)
            {
                ConsiderTree(tree, true);
            }
        }

        if (considerHouses)
        {
            foreach (var house in _houses)
            {
                ConsiderHouse(house, false);
            }

            foreach (var house in _stagedHouses)
            {
                ConsiderHouse(house, true);
            }
        }

        if (considerCharacters)
        {
            foreach (var character in _characters)
            {
                ConsiderCharacter(character, false);
            }

            foreach (var character in _stagedCharacters)
            {
                ConsiderCharacter(character, true);
            }
        }

        return best;
    }

    private EditingTitleFeature? FindTitleFeatureAtPoint(float mapX, float mapY, float threshold)
    {
        var thresholdSquared = threshold * threshold;
        EditingTitleFeature? best = null;
        var bestDistance = float.MaxValue;

        void ConsiderTitle(TitleFeatureDto title, bool isStaged)
        {
            var position = GetTitlePosition(title);
            var dx = position.X - mapX;
            var dy = position.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance > thresholdSquared || distance >= bestDistance)
            {
                return;
            }

            bestDistance = distance;
            best = new EditingTitleFeature
            {
                Title = title,
                IsStaged = isStaged
            };
        }

        foreach (var title in _titles)
        {
            ConsiderTitle(title, false);
        }

        foreach (var title in _stagedTitles)
        {
            ConsiderTitle(title, true);
        }

        return best;
    }

    private static AreaPolygonDto BuildTitlePolygon(TitleFeatureDto title)
    {
        return new AreaPolygonDto
        {
            FeatureType = "Title",
            LayerIndex = 0,
            Points = title.Points
        };
    }

    private EditingTitleFeature? FindTitlePolygonAtPoint(
        float mapX,
        float mapY,
        float threshold,
        out int pointIndex,
        out int edgeIndex)
    {
        pointIndex = -1;
        edgeIndex = -1;
        var thresholdSquared = threshold * threshold;
        EditingTitleFeature? best = null;
        var bestDistance = float.MaxValue;
        var bestPointIndex = -1;
        var bestEdgeIndex = -1;

        void ConsiderTitle(TitleFeatureDto title, bool isStaged)
        {
            if (title.TargetFeatureId.HasValue)
            {
                return;
            }

            if (title.Points is null || title.Points.Count < 3)
            {
                return;
            }

            for (var i = 0; i < title.Points.Count; i += 1)
            {
                var point = title.Points[i];
                var dx = point.X - mapX;
                var dy = point.Y - mapY;
                var distance = (dx * dx) + (dy * dy);
                if (distance <= thresholdSquared && distance < bestDistance)
                {
                    bestDistance = distance;
                    bestPointIndex = i;
                    bestEdgeIndex = -1;
                    best = new EditingTitleFeature
                    {
                        Title = title,
                        IsStaged = isStaged
                    };
                }
            }

            for (var i = 0; i < title.Points.Count; i += 1)
            {
                var j = (i + 1) % title.Points.Count;
                var closest = GetClosestPointOnSegment(title.Points[i], title.Points[j], mapX, mapY);
                var dx = closest.X - mapX;
                var dy = closest.Y - mapY;
                var distance = (dx * dx) + (dy * dy);
                if (distance <= thresholdSquared && distance < bestDistance)
                {
                    bestDistance = distance;
                    bestPointIndex = -1;
                    bestEdgeIndex = i;
                    best = new EditingTitleFeature
                    {
                        Title = title,
                        IsStaged = isStaged
                    };
                }
            }
        }

        foreach (var title in _titles)
        {
            ConsiderTitle(title, false);
        }

        foreach (var title in _stagedTitles)
        {
            ConsiderTitle(title, true);
        }

        if (best is null)
        {
            return null;
        }

        pointIndex = bestPointIndex;
        edgeIndex = bestEdgeIndex;
        return best;
    }

    private static MapPointDto? GetPointFeaturePosition(EditingPointFeature feature)
    {
        if (feature.Tree is not null)
        {
            return new MapPointDto { X = feature.Tree.X, Y = feature.Tree.Y };
        }

        if (feature.House is not null)
        {
            return new MapPointDto { X = feature.House.X, Y = feature.House.Y };
        }

        if (feature.Character is not null)
        {
            return new MapPointDto { X = feature.Character.X, Y = feature.Character.Y };
        }

        return null;
    }

    private static bool IsPointNearPolygonCenter(AreaPolygonDto polygon, float mapX, float mapY, float threshold)
    {
        if (polygon.Points.Count == 0)
        {
            return false;
        }

        var center = GetPolygonCentroid(polygon.Points);
        var dx = center.X - mapX;
        var dy = center.Y - mapY;
        return (dx * dx) + (dy * dy) <= (threshold * threshold);
    }

    private void BeginPolygonDrag(float mapX, float mapY)
    {
        if (_editingPolygon is null)
        {
            return;
        }

        if (_undoBatchKind == UndoBatchKind.None)
        {
            BeginUndoBatch(UndoBatchKind.Edit);
        }

        _editingPointIndex = -1;
        _editingEdgeIndex = -1;
        _isDraggingEditPoint = false;
        _isDraggingEditPolygon = true;
        _editingPolygonDragOrigin = new MapPointDto { X = mapX, Y = mapY };
        _editingPolygonDragOriginPoints = _editingPolygon.Points
            .Select(point => new MapPointDto { X = point.X, Y = point.Y })
            .ToList();
        _editingOriginalPoints ??= _editingPolygonDragOriginPoints
            .Select(point => new MapPointDto { X = point.X, Y = point.Y })
            .ToList();
    }

    private MapPointDto GetTitlePosition(TitleFeatureDto title)
    {
        if (title.TargetFeatureId.HasValue)
        {
            var targetId = title.TargetFeatureId.Value;
            var tree = _trees.FirstOrDefault(candidate => candidate.Id == targetId);
            if (tree is not null)
            {
                return new MapPointDto { X = tree.X, Y = tree.Y };
            }

            var house = _houses.FirstOrDefault(candidate => candidate.Id == targetId);
            if (house is not null)
            {
                return new MapPointDto { X = house.X, Y = house.Y };
            }
        }

        if (title.Points is not null && title.Points.Count >= 3)
        {
            return GetPolygonCentroid(title.Points);
        }

        return new MapPointDto { X = title.X, Y = title.Y };
    }

    private static void UpdatePointFeaturePosition(EditingPointFeature feature, float mapX, float mapY)
    {
        if (feature.Tree is not null)
        {
            feature.Tree.X = mapX;
            feature.Tree.Y = mapY;
            return;
        }

        if (feature.House is not null)
        {
            feature.House.X = mapX;
            feature.House.Y = mapY;
            return;
        }

        if (feature.Character is not null)
        {
            feature.Character.X = mapX;
            feature.Character.Y = mapY;
        }
    }

    private int FindPointIndex(AreaPolygonDto polygon, float mapX, float mapY, float threshold)
    {
        if (polygon.Points.Count == 0)
        {
            return -1;
        }

        var thresholdSquared = threshold * threshold;
        var bestIndex = -1;
        var bestDistance = float.MaxValue;

        for (var i = 0; i < polygon.Points.Count; i += 1)
        {
            var point = polygon.Points[i];
            var dx = point.X - mapX;
            var dy = point.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance <= thresholdSquared && distance < bestDistance)
            {
                bestDistance = distance;
                bestIndex = i;
            }
        }

        return bestIndex;
    }

    private int FindEdgeIndex(AreaPolygonDto polygon, float mapX, float mapY, float threshold)
    {
        if (polygon.Points.Count < 2)
        {
            return -1;
        }

        var thresholdSquared = threshold * threshold;
        var bestIndex = -1;
        var bestDistance = float.MaxValue;

        for (var i = 0; i < polygon.Points.Count; i += 1)
        {
            var j = (i + 1) % polygon.Points.Count;
            var closest = GetClosestPointOnSegment(polygon.Points[i], polygon.Points[j], mapX, mapY);
            var dx = closest.X - mapX;
            var dy = closest.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance <= thresholdSquared && distance < bestDistance)
            {
                bestDistance = distance;
                bestIndex = i;
            }
        }

        return bestIndex;
    }

    private static MapPointDto GetClosestPointOnSegment(AreaPolygonDto polygon, int edgeIndex, float mapX, float mapY)
    {
        var start = polygon.Points[edgeIndex];
        var end = polygon.Points[(edgeIndex + 1) % polygon.Points.Count];
        return GetClosestPointOnSegment(start, end, mapX, mapY);
    }

    private static MapPointDto GetClosestPointOnSegment(MapPointDto start, MapPointDto end, float mapX, float mapY)
    {
        var dx = end.X - start.X;
        var dy = end.Y - start.Y;
        var lengthSquared = (dx * dx) + (dy * dy);
        if (lengthSquared <= float.Epsilon)
        {
            return new MapPointDto { X = start.X, Y = start.Y };
        }

        var t = ((mapX - start.X) * dx + (mapY - start.Y) * dy) / lengthSquared;
        t = Math.Clamp(t, 0f, 1f);
        return new MapPointDto { X = start.X + (t * dx), Y = start.Y + (t * dy) };
    }

    private float GetEditHitRadius()
    {
        var scale = (GetCanvasScaleX() + GetCanvasScaleY()) / 2f;
        return (10f * scale) / _zoom;
    }

    private float GetBrushSpacing()
    {
        var normalized = (_brushTightness - 1f) / 9f;
        return BrushMaxSpacing - ((BrushMaxSpacing - BrushMinSpacing) * normalized);
    }

    private float GetBrushRadius()
    {
        var normalized = (_brushSize - 1f) / 9f;
        return BrushMinRadius + ((BrushMaxRadius - BrushMinRadius) * normalized);
    }

    private float GetBrushStampSpacing()
    {
        var radius = GetBrushRadius();
        var spacing = GetBrushSpacing();
        return MathF.Max(spacing, radius * 0.55f);
    }

    private float GetPolygonSpacing()
    {
        var normalized = (_polygonDensity - 1f) / 9f;
        return PolygonMaxSpacing - ((PolygonMaxSpacing - PolygonMinSpacing) * normalized);
    }

    private void PlacePointFeature(float mapX, float mapY)
    {
        if (!IsPointPlacement(_placementType))
        {
            return;
        }

        EnsureAreaLayers();
        var layerIndex = _activeAreaLayer?.LayerIndex ?? 0;
        _lastX = mapX;
        _lastY = mapY;
        _hasLastPlacement = true;

        var selectedStyle = GetStyleForPlacement(_placementType);
        var selectedSize = GetPointSizeForPlacement(_placementType);
        if (_placementType == PlacementType.House)
        {
            _stagedHouses.Add(new HouseFeatureDto
            {
                X = mapX,
                Y = mapY,
                HouseType = selectedStyle,
                LayerIndex = layerIndex,
                Size = selectedSize
            });
        }
        else if (_placementType == PlacementType.Character)
        {
            _stagedCharacters.Add(new CharacterFeatureDto
            {
                X = mapX,
                Y = mapY,
                CharacterType = selectedStyle,
                LayerIndex = layerIndex,
                Name = string.Empty,
                Background = string.Empty,
                Occupation = string.Empty,
                Personality = string.Empty
            });
        }
        else
        {
            _stagedTrees.Add(new TreeFeatureDto
            {
                X = mapX,
                Y = mapY,
                TreeType = selectedStyle,
                LayerIndex = layerIndex,
                Size = selectedSize
            });
        }
    }

    private async Task<bool> PlaceTitleAtPointAsync(
        float mapX,
        float mapY,
        bool allowTargetSearch = true,
        IReadOnlyList<MapPointDto>? polygonPoints = null)
    {
        int? targetId = null;

        if (allowTargetSearch)
        {
            var hitRadius = GetEditHitRadius();
            var target = FindPointFeatureAtPoint(mapX, mapY, hitRadius, EraserTarget.All, false, includeCharacters: false);
            if (target is null)
            {
                _statusMessage = "Click a tree or house to attach a title, or use Polygon for area titles.";
                return false;
            }

            var targetIdValue = target.Tree?.Id ?? target.House?.Id ?? 0;
            if (target.IsStaged || targetIdValue <= 0)
            {
                _statusMessage = "Save the feature before adding a title.";
                return false;
            }

            targetId = targetIdValue;
            var targetPosition = GetPointFeaturePosition(target);
            if (targetPosition is not null)
            {
                mapX = targetPosition.X;
                mapY = targetPosition.Y;
            }
        }

        var name = await PromptTitleNameAsync("New Title");
        if (name is null)
        {
            _statusMessage = "Title placement canceled.";
            return false;
        }

        var title = new TitleFeatureDto
        {
            X = mapX,
            Y = mapY,
            Name = name,
            TargetFeatureId = targetId,
            Size = _selectedTitleSize,
            Points = polygonPoints is null
                ? new List<MapPointDto>()
                : polygonPoints.Select(point => new MapPointDto { X = point.X, Y = point.Y }).ToList()
        };
        PushUndoState();
        _lastX = mapX;
        _lastY = mapY;
        _hasLastPlacement = true;
        _stagedTitles.Add(title);
        _statusMessage = "Title placed (unsaved).";
        return true;
    }

    private async Task<string?> PromptTitleNameAsync(string initialName)
    {
        var result = await JS.InvokeAsync<string?>("prompt", "Title name:", initialName);
        if (result is null)
        {
            return null;
        }

        return NormalizeTitleName(result);
    }

    private async Task<string?> PromptTitleRenameAsync(TitleFeatureDto title)
    {
        var result = await JS.InvokeAsync<string?>("prompt", "Edit title name:", title.Name);
        if (result is null)
        {
            return null;
        }

        return NormalizeTitleName(result);
    }

    private int PlacePolygonPointFeatures(IReadOnlyList<MapPointDto> points)
    {
        if (points is null || points.Count < 3)
        {
            return 0;
        }

        var minX = points.Min(point => point.X);
        var maxX = points.Max(point => point.X);
        var minY = points.Min(point => point.Y);
        var maxY = points.Max(point => point.Y);
        if (maxX <= minX || maxY <= minY)
        {
            return 0;
        }

        var spacing = GetPolygonSpacing();
        if (spacing <= 0.5f)
        {
            spacing = 0.5f;
        }

        var polygon = new AreaPolygonDto
        {
            Points = points.Select(point => new MapPointDto { X = point.X, Y = point.Y }).ToList()
        };

        var jitter = spacing * 0.35f;
        var placed = 0;

        if ((maxX - minX) < spacing && (maxY - minY) < spacing)
        {
            var centerX = (minX + maxX) / 2f;
            var centerY = (minY + maxY) / 2f;
            if (IsPointInPolygon(centerX, centerY, polygon))
            {
                PlacePointFeature(centerX, centerY);
                return 1;
            }
        }

        for (var y = minY; y <= maxY; y += spacing)
        {
            for (var x = minX; x <= maxX; x += spacing)
            {
                var candidateX = x + (float)((Random.Shared.NextDouble() * 2 - 1) * jitter);
                var candidateY = y + (float)((Random.Shared.NextDouble() * 2 - 1) * jitter);
                candidateX = Math.Clamp(candidateX, minX, maxX);
                candidateY = Math.Clamp(candidateY, minY, maxY);

                if (!IsPointInPolygon(candidateX, candidateY, polygon))
                {
                    continue;
                }

                PlacePointFeature(candidateX, candidateY);
                placed += 1;

                if (placed >= PolygonMaxPoints)
                {
                    return placed;
                }
            }
        }

        return placed;
    }

    private List<MapPointDto> BuildStarterLandMassPoints()
    {
        const float mapEdgePadding = 24f;
        var maxAllowedRadius = MathF.Min((MapWidth * 0.5f) - mapEdgePadding, (MapHeight * 0.5f) - mapEdgePadding);
        if (maxAllowedRadius < 50f)
        {
            return new List<MapPointDto>();
        }

        var targetRadius = 220f + (float)(Random.Shared.NextDouble() * 110f);
        targetRadius = MathF.Min(targetRadius, maxAllowedRadius);

        var viewCenter = GetViewportCenterMapPoint();
        var minCenterX = targetRadius + mapEdgePadding;
        var maxCenterX = MapWidth - targetRadius - mapEdgePadding;
        var minCenterY = targetRadius + mapEdgePadding;
        var maxCenterY = MapHeight - targetRadius - mapEdgePadding;

        var centerX = minCenterX <= maxCenterX ? Math.Clamp(viewCenter.X, minCenterX, maxCenterX) : (MapWidth * 0.5f);
        var centerY = minCenterY <= maxCenterY ? Math.Clamp(viewCenter.Y, minCenterY, maxCenterY) : (MapHeight * 0.5f);

        var vertexCount = Random.Shared.Next(22, 36);
        var angleStep = (2f * MathF.PI) / vertexCount;
        var phaseA = (float)(Random.Shared.NextDouble() * Math.PI * 2d);
        var phaseB = (float)(Random.Shared.NextDouble() * Math.PI * 2d);
        var waveA = 0.16f + (float)(Random.Shared.NextDouble() * 0.1d);
        var waveB = 0.06f + (float)(Random.Shared.NextDouble() * 0.07d);

        var points = new List<MapPointDto>(vertexCount);
        for (var i = 0; i < vertexCount; i += 1)
        {
            var baseAngle = i * angleStep;
            var angleJitter = ((float)Random.Shared.NextDouble() - 0.5f) * angleStep * 0.45f;
            var radialNoise = ((float)Random.Shared.NextDouble() - 0.5f) * 0.26f;
            var scale = 1f
                + (waveA * MathF.Sin((baseAngle * 2f) + phaseA))
                + (waveB * MathF.Sin((baseAngle * 5f) + phaseB))
                + radialNoise;
            scale = Math.Clamp(scale, 0.58f, 1.32f);

            var radius = targetRadius * scale;
            var angle = baseAngle + angleJitter;
            var x = Math.Clamp(centerX + (MathF.Cos(angle) * radius), mapEdgePadding, MapWidth - mapEdgePadding);
            var y = Math.Clamp(centerY + (MathF.Sin(angle) * radius), mapEdgePadding, MapHeight - mapEdgePadding);

            points.Add(new MapPointDto { X = x, Y = y });
        }

        return SmoothClosedPolygon(points);
    }

    private static List<MapPointDto> SmoothClosedPolygon(IReadOnlyList<MapPointDto> points)
    {
        if (points is null || points.Count < 3)
        {
            return points?.Select(point => new MapPointDto { X = point.X, Y = point.Y }).ToList() ?? new List<MapPointDto>();
        }

        var smoothed = new List<MapPointDto>(points.Count * 2);
        for (var i = 0; i < points.Count; i += 1)
        {
            var current = points[i];
            var next = points[(i + 1) % points.Count];
            smoothed.Add(new MapPointDto
            {
                X = (current.X * 0.75f) + (next.X * 0.25f),
                Y = (current.Y * 0.75f) + (next.Y * 0.25f)
            });
            smoothed.Add(new MapPointDto
            {
                X = (current.X * 0.25f) + (next.X * 0.75f),
                Y = (current.Y * 0.25f) + (next.Y * 0.75f)
            });
        }

        return smoothed;
    }

    private static List<MapPointDto> BuildChaoticLandEdgePoints(IReadOnlyList<MapPointDto> points)
    {
        if (points is null || points.Count < 3)
        {
            return points?.Select(point => new MapPointDto { X = point.X, Y = point.Y }).ToList() ?? new List<MapPointDto>();
        }

        var seed = points.Sum(point => (point.X * 0.13f) + (point.Y * 0.71f));
        var chaoticPoints = new List<MapPointDto>(points.Count * 2);

        for (var i = 0; i < points.Count; i += 1)
        {
            var current = points[i];
            var next = points[(i + 1) % points.Count];
            var dx = next.X - current.X;
            var dy = next.Y - current.Y;
            var length = MathF.Sqrt((dx * dx) + (dy * dy));
            if (!float.IsFinite(length) || length <= 0.001f)
            {
                chaoticPoints.Add(new MapPointDto { X = current.X, Y = current.Y });
                continue;
            }

            var steps = Math.Max(1, (int)MathF.Floor(length / LandChaosSegmentLength));
            var nx = -dy / length;
            var ny = dx / length;
            chaoticPoints.Add(new MapPointDto { X = current.X, Y = current.Y });

            for (var step = 1; step < steps; step += 1)
            {
                var t = step / (float)steps;
                var baseX = current.X + (dx * t);
                var baseY = current.Y + (dy * t);
                var noise = HashNoise01(seed + (i * 127.1f) + (step * 311.7f));
                var offset = ((noise * 2f) - 1f) * LandChaosAmplitude;
                chaoticPoints.Add(new MapPointDto
                {
                    X = baseX + (nx * offset),
                    Y = baseY + (ny * offset)
                });
            }
        }

        return chaoticPoints;
    }

    private static float HashNoise01(float value)
    {
        var raw = MathF.Sin(value) * 10000f;
        return raw - MathF.Floor(raw);
    }

    private int PlaceBrushStamp(float centerX, float centerY)
    {
        var radius = GetBrushRadius();
        var spacing = GetBrushSpacing();
        if (radius <= 0.1f || spacing <= 0.1f)
        {
            PlacePointFeature(centerX, centerY);
            return 1;
        }

        if (radius < spacing * 0.75f)
        {
            PlacePointFeature(centerX, centerY);
            return 1;
        }

        var radiusSquared = radius * radius;
        var jitter = spacing * 0.35f;
        var placed = 0;
        var centerPlaced = false;

        for (var y = -radius; y <= radius; y += spacing)
        {
            for (var x = -radius; x <= radius; x += spacing)
            {
                if ((x * x) + (y * y) > radiusSquared)
                {
                    continue;
                }

                var jx = (float)((Random.Shared.NextDouble() * 2 - 1) * jitter);
                var jy = (float)((Random.Shared.NextDouble() * 2 - 1) * jitter);
                var offsetX = x + jx;
                var offsetY = y + jy;
                if (!centerPlaced && (offsetX * offsetX) + (offsetY * offsetY) <= (spacing * spacing * 0.25f))
                {
                    offsetX = 0f;
                    offsetY = 0f;
                    centerPlaced = true;
                }

                var mapX = Math.Clamp(centerX + offsetX, 0f, MapWidth);
                var mapY = Math.Clamp(centerY + offsetY, 0f, MapHeight);
                PlacePointFeature(mapX, mapY);
                placed += 1;

                if (placed >= BrushMaxPointsPerStamp)
                {
                    return placed;
                }
            }
        }

        if (!centerPlaced)
        {
            PlacePointFeature(centerX, centerY);
            placed += 1;
        }

        return placed;
    }

    private async Task StartBrushAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        BeginUndoBatch(UndoBatchKind.Brush);
        PushUndoState();
        _isBrushing = true;
        _hasBrushCursor = true;
        _brushCursorX = mapX;
        _brushCursorY = mapY;
        _brushLastX = mapX;
        _brushLastY = mapY;
        _brushStrokeCount = 0;
        _brushStrokeCount += PlaceBrushStamp(mapX, mapY);
        _statusMessage = "Brushing features...";
        await DrawAsync();
    }

    private async Task ContinueBrushAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        _hasBrushCursor = true;
        _brushCursorX = mapX;
        _brushCursorY = mapY;
        var spacing = GetBrushStampSpacing();
        var dx = mapX - _brushLastX;
        var dy = mapY - _brushLastY;
        var distance = MathF.Sqrt((dx * dx) + (dy * dy));
        if (distance < spacing)
        {
            await DrawAsync();
            return;
        }

        var steps = Math.Max(1, (int)MathF.Floor(distance / spacing));
        var stepX = (dx / distance) * spacing;
        var stepY = (dy / distance) * spacing;

        for (var i = 0; i < steps; i += 1)
        {
            _brushLastX += stepX;
            _brushLastY += stepY;
            _brushStrokeCount += PlaceBrushStamp(_brushLastX, _brushLastY);
        }

        await DrawAsync();
    }

    private static bool IsPointInPolygon(float x, float y, AreaPolygonDto polygon)
    {
        var inside = false;
        var points = polygon.Points;
        for (var i = 0; i < points.Count; i += 1)
        {
            var j = (i == 0) ? points.Count - 1 : i - 1;
            var xi = points[i].X;
            var yi = points[i].Y;
            var xj = points[j].X;
            var yj = points[j].Y;
            var intersect = ((yi > y) != (yj > y))
                && (x < ((xj - xi) * (y - yi) / (yj - yi + float.Epsilon) + xi));
            if (intersect)
            {
                inside = !inside;
            }
        }

        return inside;
    }

    private static MapPointDto GetPolygonCentroid(IReadOnlyList<MapPointDto> points)
    {
        if (points is null || points.Count == 0)
        {
            return new MapPointDto();
        }

        if (points.Count == 1)
        {
            return new MapPointDto { X = points[0].X, Y = points[0].Y };
        }

        float area = 0f;
        float cx = 0f;
        float cy = 0f;

        for (var i = 0; i < points.Count; i += 1)
        {
            var j = (i + 1) % points.Count;
            var p1 = points[i];
            var p2 = points[j];
            var cross = (p1.X * p2.Y) - (p2.X * p1.Y);
            area += cross;
            cx += (p1.X + p2.X) * cross;
            cy += (p1.Y + p2.Y) * cross;
        }

        area *= 0.5f;
        if (MathF.Abs(area) < 0.001f)
        {
            var avgX = points.Average(point => point.X);
            var avgY = points.Average(point => point.Y);
            return new MapPointDto { X = avgX, Y = avgY };
        }

        var factor = 1f / (6f * area);
        return new MapPointDto { X = cx * factor, Y = cy * factor };
    }

    private MapRenderStateDto BuildRenderState()
    {
        var pointFeatures = new List<MapPointFeatureDto>();
        var titleFeatures = new List<MapTitleFeatureDto>();

        foreach (var tree in _trees)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "Tree",
                X = tree.X,
                Y = tree.Y,
                StyleKey = tree.TreeType,
                IsStaged = false,
                Size = NormalizePointSize(tree.Size)
            });
        }

        foreach (var house in _houses)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "House",
                X = house.X,
                Y = house.Y,
                StyleKey = house.HouseType,
                IsStaged = false,
                Size = NormalizePointSize(house.Size)
            });
        }

        foreach (var character in _characters)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "Character",
                X = character.X,
                Y = character.Y,
                StyleKey = character.CharacterType,
                IsStaged = false,
                Size = 1f
            });
        }

        foreach (var tree in _stagedTrees)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "Tree",
                X = tree.X,
                Y = tree.Y,
                StyleKey = tree.TreeType,
                IsStaged = true,
                Size = NormalizePointSize(tree.Size)
            });
        }

        foreach (var house in _stagedHouses)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "House",
                X = house.X,
                Y = house.Y,
                StyleKey = house.HouseType,
                IsStaged = true,
                Size = NormalizePointSize(house.Size)
            });
        }

        foreach (var character in _stagedCharacters)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "Character",
                X = character.X,
                Y = character.Y,
                StyleKey = character.CharacterType,
                IsStaged = true,
                Size = 1f
            });
        }

        foreach (var title in _titles)
        {
            var position = GetTitlePosition(title);
            titleFeatures.Add(new MapTitleFeatureDto
            {
                Id = title.Id,
                Name = title.Name,
                X = position.X,
                Y = position.Y,
                IsStaged = false,
                Size = NormalizeTitleSize(title.Size),
                Points = title.Points
                    .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                    .ToList()
            });
        }

        foreach (var title in _stagedTitles)
        {
            var position = GetTitlePosition(title);
            titleFeatures.Add(new MapTitleFeatureDto
            {
                Id = title.Id,
                Name = title.Name,
                X = position.X,
                Y = position.Y,
                IsStaged = true,
                Size = NormalizeTitleSize(title.Size),
                Points = title.Points
                    .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                    .ToList()
            });
        }

        return new MapRenderStateDto
        {
            PointFeatures = pointFeatures,
            TitleFeatures = titleFeatures,
            AreaLayers = _areaLayers
                .OrderBy(layer => layer.LayerIndex)
                .ToList(),
            AreaPolygons = _waterPolygons
                .Concat(_stagedWaterPolygons)
                .Concat(_landPolygons)
                .Concat(_stagedLandPolygons)
                .OrderBy(polygon => polygon.LayerIndex)
                .ToList(),
            ActivePolygon = _activePolygonPoints.Count >= 1
                ? new AreaPolygonDto
                {
                    FeatureType = IsTitlePlacement(_placementType)
                        ? "Title"
                        : IsPointPlacement(_placementType)
                            ? _placementType.ToString()
                            : GetAreaPlacementFeatureType(),
                    LayerIndex = _activeAreaLayer?.LayerIndex ?? 0,
                    Points = _activePolygonPoints
                        .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                        .ToList()
                }
                : null,
            EditPolygon = _editingPolygon is null
                ? null
                : new AreaPolygonDto
                {
                    FeatureType = _editingPolygon.FeatureType,
                    LayerIndex = _editingPolygon.LayerIndex,
                    Points = _editingPolygon.Points
                        .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                        .ToList()
                },
            EditPointFeature = _editingPointFeature is null
                ? null
                : _editingPointFeature.Tree is not null
                    ? new MapPointFeatureDto
                    {
                        FeatureType = "Tree",
                        X = _editingPointFeature.Tree.X,
                        Y = _editingPointFeature.Tree.Y,
                        StyleKey = _editingPointFeature.Tree.TreeType,
                        IsStaged = _editingPointFeature.IsStaged,
                        Size = NormalizePointSize(_editingPointFeature.Tree.Size)
                    }
                    : _editingPointFeature.House is not null
                        ? new MapPointFeatureDto
                        {
                            FeatureType = "House",
                            X = _editingPointFeature.House.X,
                            Y = _editingPointFeature.House.Y,
                            StyleKey = _editingPointFeature.House.HouseType,
                            IsStaged = _editingPointFeature.IsStaged,
                            Size = NormalizePointSize(_editingPointFeature.House.Size)
                        }
                        : _editingPointFeature.Character is not null
                            ? new MapPointFeatureDto
                            {
                                FeatureType = "Character",
                                X = _editingPointFeature.Character.X,
                                Y = _editingPointFeature.Character.Y,
                                StyleKey = _editingPointFeature.Character.CharacterType,
                                IsStaged = _editingPointFeature.IsStaged,
                                Size = 1f
                            }
                        : null,
            EditPolygonPointIndex = _editingPointIndex >= 0 ? _editingPointIndex : null,
            EditPolygonEdgeIndex = _editingEdgeIndex >= 0 ? _editingEdgeIndex : null,
            EditPolygonCenterActive = _isDraggingEditPolygon,
            BrushPreview = _activeTool == MapToolType.Brush && _hasBrushCursor
                ? new BrushPreviewDto
                {
                    X = _brushCursorX,
                    Y = _brushCursorY,
                    Radius = GetBrushRadius(),
                    IsActive = _isBrushing
                }
                : null,
            ViewState = new MapViewStateDto
            {
                ViewX = _viewX,
                ViewY = _viewY,
                Zoom = _zoom,
                MapWidth = MapWidth,
                MapHeight = MapHeight
            }
        };
    }

    private enum PlacementType
    {
        Tree,
        House,
        Character,
        Title,
        Land,
        Water
    }

    private enum EraserTarget
    {
        All,
        Tree,
        House,
        Character,
        Land,
        Water
    }

    private enum MapToolType
    {
        Pointer,
        Point,
        Brush,
        Polygon,
        Eraser,
        Edit,
        Duplicate,
        Undo,
        Redo
    }

    private enum UndoBatchKind
    {
        None,
        Brush,
        Eraser,
        Edit
    }

    private sealed class UndoState
    {
        public List<TreeFeatureDto> Trees { get; init; } = new();
        public List<HouseFeatureDto> Houses { get; init; } = new();
        public List<TitleFeatureDto> Titles { get; init; } = new();
        public List<TreeFeatureDto> StagedTrees { get; init; } = new();
        public List<HouseFeatureDto> StagedHouses { get; init; } = new();
        public List<TitleFeatureDto> StagedTitles { get; init; } = new();
        public List<AreaPolygonDto> WaterPolygons { get; init; } = new();
        public List<AreaPolygonDto> StagedWaterPolygons { get; init; } = new();
        public Dictionary<int, AreaPolygonDto> EditedWaterPolygons { get; init; } = new();
        public HashSet<int> DeletedWaterPolygonIds { get; init; } = new();
        public List<AreaPolygonDto> LandPolygons { get; init; } = new();
        public List<AreaPolygonDto> StagedLandPolygons { get; init; } = new();
        public Dictionary<int, AreaPolygonDto> EditedLandPolygons { get; init; } = new();
        public HashSet<int> DeletedLandPolygonIds { get; init; } = new();
        public Dictionary<int, TreeFeatureDto> EditedTrees { get; init; } = new();
        public Dictionary<int, HouseFeatureDto> EditedHouses { get; init; } = new();
        public Dictionary<int, TitleFeatureDto> EditedTitles { get; init; } = new();
        public HashSet<int> DeletedTreeIds { get; init; } = new();
        public HashSet<int> DeletedHouseIds { get; init; } = new();
        public HashSet<int> DeletedTitleIds { get; init; } = new();
        public List<AreaLayerDto> AreaLayers { get; init; } = new();
        public string? ActiveAreaLayerKey { get; init; }
        public int? ActiveAreaLayerIndex { get; init; }
        public float LastX { get; init; }
        public float LastY { get; init; }
        public bool HasLastPlacement { get; init; }
    }

    private sealed class EditingPointFeature
    {
        public TreeFeatureDto? Tree { get; init; }
        public HouseFeatureDto? House { get; init; }
        public CharacterFeatureDto? Character { get; init; }
        public bool IsStaged { get; init; }
    }

    private sealed class EditingTitleFeature
    {
        public TitleFeatureDto Title { get; init; } = new();
        public bool IsStaged { get; init; }
    }

    private sealed class RelationshipTreeNode
    {
        public int FeatureId { get; init; }
        public string FeatureType { get; init; } = string.Empty;
        public string Label { get; init; } = string.Empty;
        public bool IsCharacter { get; init; }
        public CharacterFeatureDto? Character { get; init; }
        public float X { get; set; }
        public float Y { get; set; }
    }

    private sealed class RelationshipTreeDirectedEdge
    {
        public int SourceId { get; init; }
        public int TargetId { get; init; }
        public List<string> RelationshipTypes { get; init; } = new();
        public string Description { get; init; } = string.Empty;
    }

    private sealed class RelationshipTreeMergedEdge
    {
        public int NodeAId { get; init; }
        public int NodeBId { get; init; }
        public RelationshipTreeDirectedEdge? AToB { get; set; }
        public RelationshipTreeDirectedEdge? BToA { get; set; }
    }

    private sealed record ToolDefinition(MapToolType Tool, string Label, string Description, bool IsImplemented);
    private sealed record PlacementDefinition(PlacementType PlacementType, string Label, string ImageUrl);
    private sealed record EraserTargetDefinition(EraserTarget Target, string Label);
    private sealed record FeatureStyleDefinition(PlacementType PlacementType, string MenuLabel, IReadOnlyList<string> Styles);
    private sealed record RelationshipTargetSelection(int TargetId, bool IsCharacter);
    private sealed record CanvasClientSize(float Width, float Height);
}










