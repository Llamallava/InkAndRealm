@page "/map-demo/{MapId:int}"
@using System
@using System.Net.Http.Json
@using System.Linq
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Web
@using InkAndRealm.Shared
@using InkAndRealm.Client.State
@inject HttpClient Http
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject UserState UserState
@implements IDisposable

<PageTitle>Ink & Realm Map Editor</PageTitle>

<div class="container-fluid map-editor-page">
    <div class="map-editor-layout">
        <aside class="map-editor-sidebar">
            <div class="map-editor-sidebar-header">
                <div class="fw-semibold">Tools</div>
                <button class="btn btn-outline-secondary btn-sm" @onclick="GoHome">
                    Back
                </button>
            </div>
            <div class="btn-group-vertical w-100" role="group" aria-label="Tool selection">
                @foreach (var tool in ToolDefinitions)
                {
                    <button class="btn btn-sm @(_activeTool == tool.Tool ? "btn-primary" : "btn-outline-primary")"
                            disabled="@(tool.Tool == MapToolType.Undo && !CanUndo || tool.Tool == MapToolType.Redo && !CanRedo)"
                            @onclick="() => SelectTool(tool.Tool)">
                        @tool.Label
                    </button>
                }
            </div>
            <div class="map-editor-sidebar-section">
                <div class="small text-muted">Active Tool</div>
                <div class="fw-semibold">@ActiveToolDefinition.Label</div>
                <div class="small text-muted">@ActiveToolSummary</div>
            </div>
            <div class="map-editor-sidebar-section">
                <div class="d-flex align-items-center justify-content-between">
                    <div class="fw-semibold">Layers</div>
                    <button class="btn btn-sm btn-outline-secondary" @onclick="AddAreaLayer">
                        Add
                    </button>
                </div>
                <div class="btn-group-vertical w-100 mt-2" role="group" aria-label="Area layers">
                    @for (var i = 0; i < _areaLayers.Count; i += 1)
                    {
                        var layer = _areaLayers[i];
                        <button class="btn btn-sm map-layer-button @(_activeAreaLayer == layer ? "btn-primary" : "btn-outline-primary")"
                                @onclick="() => SelectAreaLayer(layer)">
                            <span>@GetLayerLabel(layer, i)</span>
                            <span class="map-layer-delete"
                                  role="button"
                                  title="Delete layer"
                                  aria-label="Delete layer"
                                  @onclick="() => PromptDeleteLayerAsync(layer)"
                                  @onclick:stopPropagation="true">
                                &#128465;
                            </span>
                        </button>
                    }
                </div>
            </div>
            <div class="map-editor-sidebar-section map-editor-sidebar-metrics">
                <div class="small text-muted">Last Placement</div>
                <div>@(_hasLastPlacement ? $"{_lastX:0}, {_lastY:0}" : "No placements yet.")</div>
                <div class="small text-muted mt-2">View</div>
                <div>@($"Zoom {_zoom * 100:0}% | Origin {_viewX:0}, {_viewY:0}")</div>
                <div class="small text-muted mt-2">Unsaved Items</div>
                <div>@PendingCount</div>
            </div>
            @if (!string.IsNullOrWhiteSpace(_statusMessage))
            {
                <div class="alert alert-info mt-3 mb-0">@_statusMessage</div>
            }
        </aside>

        <section class="map-editor-main">
            <div class="map-editor-topbar">
                @if (_activeTool == MapToolType.Eraser)
                {
                    <div class="map-editor-topbar-block">
                        <div class="small text-muted">Eraser Target</div>
                        <div class="btn-group btn-group-sm" role="group" aria-label="Eraser target selection">
                            @foreach (var target in EraserTargetDefinitions)
                            {
                                <button class="btn @(_eraserTarget == target.Target ? "btn-primary" : "btn-outline-primary")"
                                        @onclick="() => SelectEraserTarget(target.Target)">
                                    @target.Label
                                </button>
                            }
                        </div>
                    </div>
                }
                <div class="map-editor-topbar-block">
                    <div class="small text-muted">@ActiveStyleDefinition.MenuLabel</div>
                    <select class="form-select form-select-sm" @bind="SelectedPlacementStyle">
                        @foreach (var style in ActiveStyleDefinition.Styles)
                        {
                            <option value="@style">@style</option>
                        }
                    </select>
                </div>
                @if (ShowPointSize)
                {
                    <div class="map-editor-topbar-block">
                        <div class="small text-muted">Point Size (@($"{SelectedPointSize:0.0}x"))</div>
                        <input class="form-range"
                               type="range"
                               min="@PointSizeMin"
                               max="@PointSizeMax"
                               step="@PointSizeStep"
                               @bind="SelectedPointSize"
                               @bind:event="oninput" />
                    </div>
                }
                @if (ShowTitleSize)
                {
                    <div class="map-editor-topbar-block">
                        <div class="small text-muted">Title Size (@($"{SelectedTitleSize:0.0}x"))</div>
                        <input class="form-range"
                               type="range"
                               min="@TitleSizeMin"
                               max="@TitleSizeMax"
                               step="@TitleSizeStep"
                               @bind="SelectedTitleSize"
                               @bind:event="oninput" />
                    </div>
                }
                <div class="map-editor-topbar-block">
                    <div class="small text-muted">Brush Tightness</div>
                    <input class="form-range"
                           type="range"
                           min="1"
                           max="10"
                           step="1"
                           disabled="@(_activeTool != MapToolType.Brush)"
                           @bind="_brushTightness" />
                </div>
                <div class="map-editor-topbar-block">
                    <div class="small text-muted">Brush Size</div>
                    <input class="form-range"
                           type="range"
                           min="1"
                           max="10"
                           step="1"
                           disabled="@(_activeTool != MapToolType.Brush)"
                           @bind="_brushSize" />
                </div>
                <div class="map-editor-topbar-block">
                    <div class="small text-muted">Polygon Density</div>
                    <input class="form-range"
                           type="range"
                           min="1"
                           max="10"
                           step="1"
                           disabled="@(!ShowPolygonDensity)"
                           @bind="_polygonDensity" />
                </div>
                @if (ShowChaoticEdgesToggle)
                {
                    <div class="map-editor-topbar-block">
                        <div class="small text-muted">Chaotic Edges</div>
                        <div class="form-check form-switch">
                            <input class="form-check-input"
                                   type="checkbox"
                                   id="land-chaos-toggle"
                                   @bind="UseChaoticLandEdges" />
                            <label class="form-check-label" for="land-chaos-toggle">
                                @(_useChaoticLandEdges ? "On" : "Off")
                            </label>
                        </div>
                    </div>
                }
                <div class="map-editor-topbar-actions">
                    <button class="btn btn-primary btn-sm"
                            disabled="@(PendingCount == 0 || _isSaving || !IsLoggedIn || !_hasMap)"
                            @onclick="SaveEditsAsync">
                        Save All
                    </button>
                    <button class="btn btn-outline-secondary btn-sm"
                            disabled="@(_isLoading)"
                            @onclick="ReloadAsync">
                        Reload
                    </button>
                </div>
            </div>

            <div class="map-editor-canvas-card">
                <div class="map-editor-canvas-shell">
                    <canvas id="@CanvasId"
                            width="1000"
                            height="600"
                            class="map-editor-canvas"
                            style="touch-action:none;"
                            @onmousedown="HandlePointerDown"
                            @onmousemove="HandlePointerMove"
                            @onmouseup="HandlePointerUp"
                            @onmouseleave="HandlePointerLeave"
                            @oncontextmenu="HandleContextMenu"
                            @oncontextmenu:preventDefault="true"
                            @onwheel="HandleWheel"
                            @onwheel:preventDefault="true">
                    </canvas>
                </div>
            </div>

            <div class="map-editor-bottombar">
                <div class="map-editor-bottombar-block">
                    <div class="small text-muted">Map Items</div>
                    <div class="btn-group map-editor-icon-group" role="group" aria-label="Map item selection">
                        @foreach (var placement in PlacementDefinitions)
                        {
                            <button class="btn map-editor-icon-button @(_placementType == placement.PlacementType ? "btn-primary" : "btn-outline-primary")"
                                    aria-label="@placement.Label"
                                    @onclick="() => SelectPlacement(placement.PlacementType)">
                                <img src="@placement.ImageUrl" alt="" />
                            </button>
                        }
                    </div>
                </div>
            </div>
        </section>
    </div>
</div>

@code {
    private const string CanvasId = "map-demo-canvas";
    private List<TreeFeatureDto> _trees = new();
    private List<HouseFeatureDto> _houses = new();
    private List<TitleFeatureDto> _titles = new();
    private readonly List<TreeFeatureDto> _stagedTrees = new();
    private readonly List<HouseFeatureDto> _stagedHouses = new();
    private readonly List<TitleFeatureDto> _stagedTitles = new();
    private const float MapWidth = 2000f;
    private const float MapHeight = 1200f;
    private const float MinZoom = 0.5f;
    private const float MaxZoom = 3f;
    private const float CanvasWidth = 1000f;
    private const float CanvasHeight = 600f;
    private float _canvasClientWidth = CanvasWidth;
    private float _canvasClientHeight = CanvasHeight;
    private float _lastX;
    private float _lastY;
    private bool _hasLastPlacement;
    private float _viewX;
    private float _viewY;
    private float _zoom = 1f;
    private bool _isPanning;
    private float _panStartX;
    private float _panStartY;
    private float _panOriginX;
    private float _panOriginY;
    private bool _isPanCandidate;
    private float _panCandidateStartX;
    private float _panCandidateStartY;
    private bool _isLoading;
    private bool _isSaving;
    private bool _hasMap;
    private string _statusMessage = string.Empty;
    private readonly List<UndoState> _undoStack = new();
    private readonly List<UndoState> _redoStack = new();
    private UndoBatchKind _undoBatchKind = UndoBatchKind.None;
    private bool _undoBatchPushed;
    private bool _isUndoing;
    private bool _isRedoing;
    private DotNetObjectReference<MapEditor>? _undoShortcutRef;
    private bool IsLoggedIn => UserState.CurrentUser is not null;
    private PlacementType _placementType = PlacementType.Tree;
    private readonly Dictionary<PlacementType, string> _selectedStyleByPlacement = new()
    {
        { PlacementType.Tree, "Oak" },
        { PlacementType.House, "Cottage" },
        { PlacementType.Water, "Water" },
        { PlacementType.Land, "Land" },
        { PlacementType.Title, "Title" }
    };
    private MapToolType _activeTool = MapToolType.Point;
    private bool _isBrushing;
    private bool _isErasing;
    private float _brushLastX;
    private float _brushLastY;
    private int _brushStrokeCount;
    private int _brushTightness = 6;
    private int _brushSize = 5;
    private int _polygonDensity = 6;
    private float _brushCursorX;
    private float _brushCursorY;
    private bool _hasBrushCursor;
    private float _eraseLastX;
    private float _eraseLastY;
    private int _eraseCount;
    private const float BrushMinSpacing = 16f;
    private const float BrushMaxSpacing = 90f;
    private const float BrushMinRadius = 2f;
    private const float BrushMaxRadius = 24f;
    private const int BrushMaxPointsPerStamp = 220;
    private const float PointSizeMin = 0.1f;
    private const float PointSizeMax = 5f;
    private const float PointSizeStep = 0.1f;
    private const int TitleNameMaxLength = 128;
    private const float TitleSizeMin = 0.5f;
    private const float TitleSizeMax = 3f;
    private const float TitleSizeStep = 0.1f;
    private const float EraseMinSpacing = 8f;
    private const float PolygonMinSpacing = 18f;
    private const float PolygonMaxSpacing = 120f;
    private const int PolygonMaxPoints = 1600;
    private readonly List<AreaLayerDto> _areaLayers = new();
    private AreaLayerDto? _activeAreaLayer;
    private readonly List<MapPointDto> _activePolygonPoints = new();
    private readonly List<AreaPolygonDto> _waterPolygons = new();
    private readonly List<AreaPolygonDto> _stagedWaterPolygons = new();
    private readonly Dictionary<int, AreaPolygonDto> _editedWaterPolygons = new();
    private readonly HashSet<int> _deletedWaterPolygonIds = new();
    private readonly List<AreaPolygonDto> _landPolygons = new();
    private readonly List<AreaPolygonDto> _stagedLandPolygons = new();
    private readonly Dictionary<int, AreaPolygonDto> _editedLandPolygons = new();
    private readonly HashSet<int> _deletedLandPolygonIds = new();
    private readonly Dictionary<int, TreeFeatureDto> _editedTrees = new();
    private readonly Dictionary<int, HouseFeatureDto> _editedHouses = new();
    private readonly Dictionary<int, TitleFeatureDto> _editedTitles = new();
    private readonly HashSet<int> _deletedTreeIds = new();
    private readonly HashSet<int> _deletedHouseIds = new();
    private readonly HashSet<int> _deletedTitleIds = new();
    private AreaPolygonDto? _editingPolygon;
    private List<MapPointDto>? _editingOriginalPoints;
    private int _editingPointIndex = -1;
    private int _editingEdgeIndex = -1;
    private bool _isDraggingEditPoint;
    private EditingPointFeature? _editingPointFeature;
    private MapPointDto? _editingPointOriginalPosition;
    private bool _isDraggingEditPointFeature;
    private EditingTitleFeature? _editingTitleFeature;
    private MapPointDto? _editingTitleOriginalPosition;
    private bool _isDraggingTitleFeature;
    private EraserTarget _eraserTarget = EraserTarget.All;
    private bool _useChaoticLandEdges = true;
    private int PendingCount => _stagedTrees.Count
        + _stagedHouses.Count
        + _stagedTitles.Count
        + _stagedWaterPolygons.Count
        + _editedWaterPolygons.Count
        + _deletedWaterPolygonIds.Count
        + _stagedLandPolygons.Count
        + _editedLandPolygons.Count
        + _deletedLandPolygonIds.Count
        + _editedTrees.Count
        + _editedHouses.Count
        + _editedTitles.Count
        + _deletedTreeIds.Count
        + _deletedHouseIds.Count
        + _deletedTitleIds.Count;
    private bool CanUndo => _undoStack.Count > 0;
    private bool CanRedo => _redoStack.Count > 0;
    [Parameter] public int MapId { get; set; }
    private const float PanDragThreshold = 6f;
    private static readonly IReadOnlyList<string> TreeStyles = new List<string>
    {
        "Oak",
        "Pine",
        "Birch",
        "Palm"
    };
    private static readonly IReadOnlyList<string> HouseStyles = new List<string>
    {
        "Cottage",
        "Cabin",
        "Manor"
    };
    private static readonly IReadOnlyList<string> WaterStyles = new List<string>
    {
        "Water"
    };
    private static readonly IReadOnlyList<string> LandStyles = new List<string>
    {
        "Land"
    };
    private static readonly IReadOnlyList<string> TitleStyles = new List<string>
    {
        "Title"
    };
    private static readonly IReadOnlyList<PlacementDefinition> PlacementDefinitions = new List<PlacementDefinition>
    {
        new(PlacementType.Tree, "Tree", "/assets/Summer%20Set/tree_1.png"),
        new(PlacementType.House, "House", "/assets/Summer%20Set/building_2.png"),
        new(PlacementType.Title, "Title", "/assets/Summer%20Set/decor_1.png"),
        new(PlacementType.Land, "Land", "/assets/Summer%20Set/land_1.png"),
        new(PlacementType.Water, "Water", "/assets/Summer%20Set/river.png")
    };
    private static readonly IReadOnlyList<EraserTargetDefinition> EraserTargetDefinitions = new List<EraserTargetDefinition>
    {
        new(EraserTarget.All, "All"),
        new(EraserTarget.Tree, "Trees"),
        new(EraserTarget.House, "Houses"),
        new(EraserTarget.Land, "Land"),
        new(EraserTarget.Water, "Water")
    };
    private static readonly IReadOnlyList<FeatureStyleDefinition> FeatureStyleDefinitions = new List<FeatureStyleDefinition>
    {
        new(PlacementType.Tree, "Tree Style", TreeStyles),
        new(PlacementType.House, "House Style", HouseStyles),
        new(PlacementType.Title, "Title", TitleStyles),
        new(PlacementType.Land, "Land Type", LandStyles),
        new(PlacementType.Water, "Water Type", WaterStyles)
    };
    private readonly Dictionary<PlacementType, float> _pointSizeByPlacement = new()
    {
        { PlacementType.Tree, 1f },
        { PlacementType.House, 1f }
    };
    private static readonly IReadOnlyList<ToolDefinition> ToolDefinitions = new List<ToolDefinition>
    {
        new(MapToolType.Pointer, "Pointer", "Pan the map without placing items.", true),
        new(MapToolType.Point, "Point", "Place one feature per click.", true),
        new(MapToolType.Brush, "Brush", "Paint features while dragging across the map.", true),
        new(MapToolType.Polygon, "Polygon", "Fill a polygonal area with a feature.", true),
        new(MapToolType.Eraser, "Eraser", "Remove a feature from the map.", true),
        new(MapToolType.Edit, "Edit", "Move or update an existing feature.", true),
        new(MapToolType.Duplicate, "Duplicate", "Clone an existing feature.", true),
        new(MapToolType.Undo, "Undo", "Undo the most recent change.", true),
        new(MapToolType.Redo, "Redo", "Redo the most recent undone change.", true)
    };
    private ToolDefinition ActiveToolDefinition => ToolDefinitions.First(tool => tool.Tool == _activeTool);
    private string ActiveToolSummary => ActiveToolDefinition.IsImplemented
        ? _activeTool == MapToolType.Brush
            ? $"{ActiveToolDefinition.Description} (tightness {_brushTightness}/10, size {_brushSize}/10)."
            : _activeTool == MapToolType.Polygon && IsPointPlacement(_placementType)
                ? $"{ActiveToolDefinition.Description} (density {_polygonDensity}/10)."
            : ActiveToolDefinition.Description
        : $"{ActiveToolDefinition.Description} (coming soon).";
    private string ActiveAreaLayerLabel => _activeAreaLayer is null ? "None" : GetLayerLabel(_activeAreaLayer);
    private FeatureStyleDefinition ActiveStyleDefinition
        => FeatureStyleDefinitions.First(definition => definition.PlacementType == _placementType);
    private bool ShowPolygonDensity => _activeTool == MapToolType.Polygon && IsPointPlacement(_placementType);
    private bool ShowPointSize => IsPointPlacement(_placementType);
    private bool ShowTitleSize => _placementType == PlacementType.Title;
    private bool ShowChaoticEdgesToggle => _placementType == PlacementType.Land;
    private string SelectedPlacementStyle
    {
        get => GetStyleForPlacement(_placementType);
        set => _selectedStyleByPlacement[_placementType] = value;
    }
    private float SelectedPointSize
    {
        get => GetPointSizeForPlacement(_placementType);
        set => SetPointSizeForPlacement(_placementType, value);
    }
    private float _selectedTitleSize = 1f;
    private float SelectedTitleSize
    {
        get => _selectedTitleSize;
        set
        {
            var normalized = NormalizeTitleSize(value);
            _selectedTitleSize = normalized;
            if (_editingTitleFeature is not null)
            {
                _editingTitleFeature.Title.Size = normalized;
                TrackEditedTitleFeature(_editingTitleFeature);
                _ = InvokeAsync(DrawAsync);
            }
        }
    }
    private bool UseChaoticLandEdges
    {
        get => _useChaoticLandEdges;
        set
        {
            if (_useChaoticLandEdges == value)
            {
                return;
            }

            _useChaoticLandEdges = value;
            _ = InvokeAsync(DrawAsync);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        UserState.Changed += OnUserChanged;
        EnsureAreaLayers();
        await LoadMapAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await UpdateCanvasClientSizeAsync();
            _undoShortcutRef ??= DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("inkAndRealmDemo.registerUndoShortcut", CanvasId, _undoShortcutRef);
            await DrawAsync();
        }
    }

    private async Task HandlePointerDown(MouseEventArgs args)
    {
        if (!ActiveToolDefinition.IsImplemented)
        {
            _statusMessage = $"{ActiveToolDefinition.Label} tool is not available yet.";
            return;
        }

        if (_activeTool == MapToolType.Pointer)
        {
            StartPan(args);
            return;
        }

        if (_activeTool == MapToolType.Point)
        {
            BeginPanCandidate(args);
            return;
        }

        if (_activeTool == MapToolType.Brush)
        {
            if (args.Button != 0)
            {
                return;
            }

            if (_placementType == PlacementType.Title)
            {
                _statusMessage = "Titles can only be placed with the Point or Polygon tool.";
                return;
            }

            if (_placementType == PlacementType.Land)
            {
                _statusMessage = "Land can only be placed with the Polygon tool.";
                return;
            }

            if (_placementType == PlacementType.Water)
            {
                _statusMessage = "Water can only be placed with the Polygon tool.";
                return;
            }

            await StartBrushAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Polygon)
        {
            if (args.Button != 0)
            {
                return;
            }

            if (TryGetMapPoint(args, out var mapX, out var mapY))
            {
                EnsureAreaLayers();
                _activePolygonPoints.Add(new MapPointDto { X = mapX, Y = mapY });
                _statusMessage = $"Polygon point added ({_activePolygonPoints.Count}).";
                await DrawAsync();
            }
            return;
        }

        if (_activeTool == MapToolType.Eraser)
        {
            if (args.Button != 0)
            {
                return;
            }

            await StartEraserAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Edit)
        {
            if (args.Button != 0)
            {
                return;
            }

            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            var hitRadius = GetEditHitRadius();
            AreaPolygonDto? polygon = _editingPolygon;
            if (polygon is not null)
            {
                var pointIndex = FindPointIndex(polygon, mapX, mapY, hitRadius);
                if (pointIndex >= 0)
                {
                    _editingPointIndex = pointIndex;
                    _isDraggingEditPoint = true;
                    _statusMessage = "Adjusting polygon point...";
                    return;
                }
            }

            if (_placementType == PlacementType.Title)
            {
                var titleFeature = FindTitleFeatureAtPoint(mapX, mapY, hitRadius);
                if (titleFeature is not null)
                {
                    ClearEditSelection(true);
                    if (!titleFeature.Title.TargetFeatureId.HasValue)
                    {
                        BeginUndoBatch(UndoBatchKind.Edit);
                    }
                    _editingTitleFeature = titleFeature;
                    _editingTitleOriginalPosition = new MapPointDto { X = titleFeature.Title.X, Y = titleFeature.Title.Y };
                    _isDraggingTitleFeature = CanDragTitle(titleFeature.Title);
                    _selectedTitleSize = NormalizeTitleSize(titleFeature.Title.Size);
                    _statusMessage = _isDraggingTitleFeature
                        ? "Moving title..."
                        : "Title selected. Right-click to edit name.";
                    await DrawAsync();
                    return;
                }
            }

            var pointFeature = FindPointFeatureAtPoint(mapX, mapY, hitRadius);
            if (pointFeature is not null)
            {
                ClearEditSelection(true);
                BeginUndoBatch(UndoBatchKind.Edit);
                _editingPointFeature = pointFeature;
                _editingPointOriginalPosition = GetPointFeaturePosition(pointFeature);
                _isDraggingEditPointFeature = true;
                _statusMessage = "Moving point feature...";
                await DrawAsync();
                return;
            }

            if (_placementType != PlacementType.Title)
            {
                var titleFeature = FindTitleFeatureAtPoint(mapX, mapY, hitRadius);
                if (titleFeature is not null)
                {
                    ClearEditSelection(true);
                    if (!titleFeature.Title.TargetFeatureId.HasValue)
                    {
                        BeginUndoBatch(UndoBatchKind.Edit);
                    }
                    _editingTitleFeature = titleFeature;
                    _editingTitleOriginalPosition = new MapPointDto { X = titleFeature.Title.X, Y = titleFeature.Title.Y };
                    _isDraggingTitleFeature = CanDragTitle(titleFeature.Title);
                    _selectedTitleSize = NormalizeTitleSize(titleFeature.Title.Size);
                    _statusMessage = _isDraggingTitleFeature
                        ? "Moving title..."
                        : "Title selected. Right-click to edit name.";
                    await DrawAsync();
                    return;
                }
            }

            if (IsPointPlacement(_placementType))
            {
                return;
            }

            if (polygon is null)
            {
                polygon = FindPolygonAtPoint(mapX, mapY);
            }

            if (polygon is not null)
            {
                _editingPolygon = polygon;
                _editingOriginalPoints = polygon.Points
                    .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                    .ToList();
                BeginUndoBatch(UndoBatchKind.Edit);

                var edgeIndex = FindEdgeIndex(polygon, mapX, mapY, hitRadius);
                if (edgeIndex >= 0)
                {
                    var closestPoint = GetClosestPointOnSegment(polygon, edgeIndex, mapX, mapY);
                    var insertIndex = edgeIndex + 1;
                    PushUndoState();
                    polygon.Points.Insert(insertIndex, closestPoint);
                    _editingPointIndex = insertIndex;
                    _editingEdgeIndex = -1;
                    _isDraggingEditPoint = true;
                    _statusMessage = "Vertex added. Drag to position.";
                    await DrawAsync();
                    return;
                }

                _editingPointIndex = -1;
                _editingEdgeIndex = -1;
                _isDraggingEditPoint = false;
                _statusMessage = "Polygon selected. Drag a point to edit.";
                await DrawAsync();
                return;
            }

            if (_editingPolygon is not null || _editingPointFeature is not null)
            {
                ClearEditSelection(false);
                _statusMessage = "Edit selection cleared.";
                await DrawAsync();
            }
            return;
        }

        if (_activeTool == MapToolType.Duplicate)
        {
            if (args.Button != 0)
            {
                return;
            }

            await DuplicateFeatureAsync(args);
            return;
        }

        _statusMessage = $"{ActiveToolDefinition.Label} tool is not available yet.";
    }

    private async Task HandlePointerMove(MouseEventArgs args)
    {
        if (_isPanning && (_activeTool == MapToolType.Pointer || _activeTool == MapToolType.Point))
        {
            UpdatePan(args);
            await DrawAsync();
            return;
        }

        if (_isPanCandidate && _activeTool == MapToolType.Point)
        {
            var dx = (float)args.OffsetX - _panCandidateStartX;
            var dy = (float)args.OffsetY - _panCandidateStartY;
            if ((dx * dx) + (dy * dy) >= (PanDragThreshold * PanDragThreshold))
            {
                StartPanFromCandidate();
                UpdatePan(args);
                await DrawAsync();
            }
            return;
        }

        if (_activeTool == MapToolType.Brush && _isBrushing)
        {
            await ContinueBrushAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Eraser && _isErasing)
        {
            await ContinueEraserAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPointFeature && _editingPointFeature is not null)
        {
            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            if (_undoBatchKind == UndoBatchKind.Edit && !_undoBatchPushed && _editingPointOriginalPosition is not null)
            {
                if (MathF.Abs(mapX - _editingPointOriginalPosition.X) > 0.01f
                    || MathF.Abs(mapY - _editingPointOriginalPosition.Y) > 0.01f)
                {
                    PushUndoState();
                }
            }

            UpdatePointFeaturePosition(_editingPointFeature, mapX, mapY);
            await DrawAsync();
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingTitleFeature && _editingTitleFeature is not null)
        {
            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            if (!_editingTitleFeature.Title.TargetFeatureId.HasValue)
            {
                if (_undoBatchKind == UndoBatchKind.Edit && !_undoBatchPushed && _editingTitleOriginalPosition is not null)
                {
                    if (MathF.Abs(mapX - _editingTitleOriginalPosition.X) > 0.01f
                        || MathF.Abs(mapY - _editingTitleOriginalPosition.Y) > 0.01f)
                    {
                        PushUndoState();
                    }
                }

                _editingTitleFeature.Title.X = mapX;
                _editingTitleFeature.Title.Y = mapY;
                await DrawAsync();
            }
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPoint && _editingPolygon is not null && _editingPointIndex >= 0)
        {
            if (!TryGetMapPoint(args, out var mapX, out var mapY))
            {
                return;
            }

            if (_undoBatchKind == UndoBatchKind.Edit && !_undoBatchPushed && _editingOriginalPoints is not null)
            {
                var shouldPush = true;
                if (_editingPointIndex >= 0 && _editingPointIndex < _editingOriginalPoints.Count)
                {
                    var original = _editingOriginalPoints[_editingPointIndex];
                    shouldPush = MathF.Abs(mapX - original.X) > 0.01f || MathF.Abs(mapY - original.Y) > 0.01f;
                }

                if (shouldPush)
                {
                    PushUndoState();
                }
            }

            _editingPolygon.Points[_editingPointIndex] = new MapPointDto { X = mapX, Y = mapY };
            await DrawAsync();
            return;
        }

        if (_activeTool == MapToolType.Edit && !_isDraggingEditPoint)
        {
            var previousEdge = _editingEdgeIndex;
            if (_editingPolygon is not null && TryGetMapPoint(args, out var mapX, out var mapY))
            {
                _editingEdgeIndex = FindEdgeIndex(_editingPolygon, mapX, mapY, GetEditHitRadius());
            }
            else
            {
                _editingEdgeIndex = -1;
            }

            if (previousEdge != _editingEdgeIndex)
            {
                await DrawAsync();
            }
        }

        if (_activeTool == MapToolType.Brush && !_isBrushing)
        {
            var wasVisible = _hasBrushCursor;
            var previousX = _brushCursorX;
            var previousY = _brushCursorY;
            _hasBrushCursor = TryGetMapPoint(args, out _brushCursorX, out _brushCursorY);

            var moved = _hasBrushCursor
                && (MathF.Abs(previousX - _brushCursorX) > 0.5f || MathF.Abs(previousY - _brushCursorY) > 0.5f);

            if (wasVisible != _hasBrushCursor || moved)
            {
                await DrawAsync();
            }
            return;
        }

        return;
    }

    private async Task HandlePointerUp(MouseEventArgs args)
    {
        if (_isPanning && (_activeTool == MapToolType.Pointer || _activeTool == MapToolType.Point))
        {
            _isPanning = false;
            _isPanCandidate = false;
            return;
        }

        if (_isPanCandidate && _activeTool == MapToolType.Point)
        {
            _isPanCandidate = false;
            await HandlePointToolAsync(args);
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPoint)
        {
            _isDraggingEditPoint = false;
            _statusMessage = "Polygon point updated. Right-click to confirm.";
            return;
        }

        if (_activeTool == MapToolType.Brush && _isBrushing)
        {
            _isBrushing = false;
            _hasBrushCursor = false;
            _statusMessage = _brushStrokeCount == 0
                ? "Brush stroke canceled."
                : $"Brush stroke placed ({_brushStrokeCount} item{(_brushStrokeCount == 1 ? string.Empty : "s")}).";
            EndUndoBatch(_brushStrokeCount > 0);
            return;
        }

        if (_activeTool == MapToolType.Eraser && _isErasing)
        {
            StopEraser();
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPointFeature)
        {
            _isDraggingEditPointFeature = false;
            _statusMessage = "Point feature updated. Right-click to confirm.";
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingTitleFeature)
        {
            _isDraggingTitleFeature = false;
            _statusMessage = "Title updated. Right-click to confirm.";
            return;
        }

        return;
    }

    private async Task HandleContextMenu(MouseEventArgs args)
    {
        if (_activeTool == MapToolType.Edit)
        {
            if (_editingPolygon is not null)
            {
                TrackEditedPolygon(_editingPolygon);
                ClearEditSelection(true);
                _statusMessage = "Polygon edit confirmed.";
                await DrawAsync();
            }
            else if (_editingPointFeature is not null)
            {
                TrackEditedPointFeature(_editingPointFeature);
                ClearEditSelection(true);
                _statusMessage = "Point feature edit confirmed.";
                await DrawAsync();
            }
            else if (_editingTitleFeature is not null)
            {
                var newName = await PromptTitleRenameAsync(_editingTitleFeature.Title);
                if (newName is null)
                {
                    _statusMessage = "Title edit canceled.";
                }
                else if (string.Equals(newName, _editingTitleFeature.Title.Name, StringComparison.Ordinal))
                {
                    _statusMessage = "Title unchanged.";
                }
                else
                {
                    PushUndoState();
                    _editingTitleFeature.Title.Name = newName;
                    TrackEditedTitleFeature(_editingTitleFeature);
                    _statusMessage = "Title updated.";
                }
                ClearEditSelection(true);
                await DrawAsync();
            }
            return;
        }

        if (_activeTool != MapToolType.Polygon)
        {
            return;
        }

        if (_activePolygonPoints.Count < 3)
        {
            _activePolygonPoints.Clear();
            _statusMessage = "Polygon cleared (need at least 3 points).";
            await DrawAsync();
            return;
        }

        if (_placementType == PlacementType.Title)
        {
            var centroid = GetPolygonCentroid(_activePolygonPoints);
            var points = _activePolygonPoints
                .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                .ToList();
            var placed = await PlaceTitleAtPointAsync(
                centroid.X,
                centroid.Y,
                allowTargetSearch: false,
                polygonPoints: points);
            _activePolygonPoints.Clear();
            _statusMessage = placed
                ? "Title placed for area (unsaved)."
                : "Title placement canceled.";
        }
        else if (IsPointPlacement(_placementType))
        {
            PushUndoState();
            var placedCount = PlacePolygonPointFeatures(_activePolygonPoints);
            _activePolygonPoints.Clear();
            var label = _placementType == PlacementType.House ? "house" : "tree";
            _statusMessage = placedCount == 0
                ? "Polygon placed with no points (adjust density)."
                : $"Polygon filled with {placedCount} {label} item{(placedCount == 1 ? string.Empty : "s")} (unsaved).";
            if (placedCount == 0 && _undoStack.Count > 0)
            {
                _undoStack.RemoveAt(_undoStack.Count - 1);
            }
        }
        else
        {
            EnsureAreaLayers();
            var layer = _activeAreaLayer;
            if (layer is null)
            {
                _statusMessage = "Select a layer before placing polygons.";
                return;
            }

            PushUndoState();
            var polygon = new AreaPolygonDto
            {
                FeatureType = GetAreaPlacementFeatureType(),
                LayerIndex = layer.LayerIndex,
                Points = _activePolygonPoints
                    .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                    .ToList()
            };

            if (IsLandFeatureType(polygon.FeatureType))
            {
                _stagedLandPolygons.Add(polygon);
            }
            else
            {
                _stagedWaterPolygons.Add(polygon);
            }
            _activePolygonPoints.Clear();
            _statusMessage = $"Polygon placed on {GetLayerLabel(layer)} (unsaved).";
        }
        await DrawAsync();
    }

    private async Task HandlePointerLeave(MouseEventArgs args)
    {
        if ((_isPanning || _isPanCandidate) && (_activeTool == MapToolType.Pointer || _activeTool == MapToolType.Point))
        {
            _isPanning = false;
            _isPanCandidate = false;
            return;
        }

        if (_activeTool == MapToolType.Brush && _isBrushing)
        {
            _isBrushing = false;
            _hasBrushCursor = false;
            _statusMessage = _brushStrokeCount == 0
                ? "Brush stroke canceled."
                : $"Brush stroke placed ({_brushStrokeCount} item{(_brushStrokeCount == 1 ? string.Empty : "s")}).";
            EndUndoBatch(_brushStrokeCount > 0);
            return;
        }

        if (_activeTool == MapToolType.Eraser && _isErasing)
        {
            StopEraser();
            return;
        }

        if (_activeTool == MapToolType.Brush && _hasBrushCursor)
        {
            _hasBrushCursor = false;
            await DrawAsync();
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPoint)
        {
            _isDraggingEditPoint = false;
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingEditPointFeature)
        {
            _isDraggingEditPointFeature = false;
            return;
        }

        if (_activeTool == MapToolType.Edit && _isDraggingTitleFeature)
        {
            _isDraggingTitleFeature = false;
            return;
        }

        if (_activeTool == MapToolType.Edit && _editingEdgeIndex >= 0)
        {
            _editingEdgeIndex = -1;
            await DrawAsync();
        }

        return;
    }

    private async Task HandleWheel(WheelEventArgs args)
    {
        var zoomFactor = args.DeltaY < 0 ? 1.1f : 0.9f;
        var newZoom = Math.Clamp(_zoom * zoomFactor, MinZoom, MaxZoom);
        if (Math.Abs(newZoom - _zoom) < 0.001f)
        {
            return;
        }

        var before = ScreenToMap((float)args.OffsetX, (float)args.OffsetY);
        _zoom = newZoom;
        _viewX = before.X - ((float)args.OffsetX / _zoom);
        _viewY = before.Y - ((float)args.OffsetY / _zoom);
        ClampView();
        await DrawAsync();
    }

    private void StartPan(MouseEventArgs args)
    {
        _isPanning = true;
        _panStartX = (float)args.OffsetX;
        _panStartY = (float)args.OffsetY;
        _panOriginX = _viewX;
        _panOriginY = _viewY;
        _statusMessage = "Panning map...";
    }

    private void BeginPanCandidate(MouseEventArgs args)
    {
        _isPanCandidate = true;
        _panCandidateStartX = (float)args.OffsetX;
        _panCandidateStartY = (float)args.OffsetY;
    }

    private void StartPanFromCandidate()
    {
        _isPanning = true;
        _panStartX = _panCandidateStartX;
        _panStartY = _panCandidateStartY;
        _panOriginX = _viewX;
        _panOriginY = _viewY;
        _isPanCandidate = false;
        _statusMessage = "Panning map...";
    }

    private void UpdatePan(MouseEventArgs args)
    {
        var dx = ((float)args.OffsetX - _panStartX) / _zoom;
        var dy = ((float)args.OffsetY - _panStartY) / _zoom;
        _viewX = _panOriginX - dx;
        _viewY = _panOriginY - dy;
        ClampView();
    }

    private (float X, float Y) ScreenToMap(float screenX, float screenY)
    {
        var scaleX = GetCanvasScaleX();
        var scaleY = GetCanvasScaleY();
        return (_viewX + ((screenX * scaleX) / _zoom), _viewY + ((screenY * scaleY) / _zoom));
    }

    private bool TryGetMapPoint(MouseEventArgs args, out float mapX, out float mapY)
    {
        var (rawX, rawY) = ScreenToMap((float)args.OffsetX, (float)args.OffsetY);
        if (rawX < 0 || rawX > MapWidth || rawY < 0 || rawY > MapHeight)
        {
            mapX = 0;
            mapY = 0;
            return false;
        }

        mapX = Math.Clamp(rawX, 0, MapWidth);
        mapY = Math.Clamp(rawY, 0, MapHeight);
        return true;
    }

    private void ClampView()
    {
        var maxX = Math.Max(0f, MapWidth - (CanvasWidth / _zoom));
        var maxY = Math.Max(0f, MapHeight - (CanvasHeight / _zoom));
        _viewX = Math.Clamp(_viewX, 0f, maxX);
        _viewY = Math.Clamp(_viewY, 0f, maxY);
    }

    private async Task HandlePointToolAsync(MouseEventArgs args)
    {
        if (_placementType == PlacementType.Title)
        {
            if (!TryGetMapPoint(args, out var titleMapX, out var titleMapY))
            {
                return;
            }

            await PlaceTitleAtPointAsync(titleMapX, titleMapY);
            await DrawAsync();
            return;
        }

        if (_placementType == PlacementType.Land)
        {
            _statusMessage = "Land can only be placed with the Polygon tool.";
            return;
        }

        if (_placementType == PlacementType.Water)
        {
            _statusMessage = "Water can only be placed with the Polygon tool.";
            return;
        }

        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        PushUndoState();
        PlacePointFeature(mapX, mapY);
        if (_placementType == PlacementType.House)
        {
            _statusMessage = $"Placed house at {_lastX:0}, {_lastY:0} (unsaved).";
        }
        else
        {
            _statusMessage = $"Placed tree at {_lastX:0}, {_lastY:0} (unsaved).";
        }

        await DrawAsync();
    }

    private async Task StartEraserAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        BeginUndoBatch(UndoBatchKind.Eraser);
        PushUndoState();
        _isErasing = true;
        _eraseCount = 0;
        _eraseLastX = mapX;
        _eraseLastY = mapY;

        string? status = null;
        var erased = TryEraseAtPoint(mapX, mapY, out status, showEmptyStatus: true);

        _statusMessage = erased
            ? "Erasing..."
            : status ?? "Nothing to erase.";

        if (!erased && status == "Select a layer before erasing.")
        {
            _isErasing = false;
            EndUndoBatch(false);
        }

        if (erased)
        {
            _eraseCount += 1;
            await DrawAsync();
        }
    }

    private async Task ContinueEraserAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        var dx = mapX - _eraseLastX;
        var dy = mapY - _eraseLastY;
        var distance = MathF.Sqrt((dx * dx) + (dy * dy));
        if (distance < EraseMinSpacing)
        {
            return;
        }

        _eraseLastX = mapX;
        _eraseLastY = mapY;

        if (TryEraseAtPoint(mapX, mapY, out _, showEmptyStatus: false))
        {
            _eraseCount += 1;
            await DrawAsync();
        }
    }

    private void StopEraser()
    {
        _isErasing = false;
        _statusMessage = _eraseCount == 0
            ? "Nothing erased."
            : $"Erased {_eraseCount} item{(_eraseCount == 1 ? string.Empty : "s")}.";
        EndUndoBatch(_eraseCount > 0);
    }

    private async Task SaveEditsAsync()
    {
        if (PendingCount == 0)
        {
            return;
        }

        if (!IsLoggedIn)
        {
            _statusMessage = "Please log in to save features to the map.";
            return;
        }

        if (!_hasMap)
        {
            _statusMessage = "Create a new map before saving features.";
            return;
        }

        _isSaving = true;
        var pendingCount = PendingCount;
        _statusMessage = $"Saving {pendingCount} item{(pendingCount == 1 ? string.Empty : "s")}...";

        var request = new MapEditsRequest
        {
            UserId = UserState.CurrentUser?.UserId,
            SessionToken = UserState.CurrentUser?.SessionToken,
            MapId = MapId,
            AreaLayers = _areaLayers
                .OrderBy(layer => layer.LayerIndex)
                .Select(layer => new AreaLayerDto
                {
                    LayerKey = layer.LayerKey,
                    LayerIndex = layer.LayerIndex,
                    FeatureType = layer.FeatureType
                })
                .ToList(),
            AddedTrees = new List<TreeFeatureDto>(_stagedTrees),
            AddedHouses = new List<HouseFeatureDto>(_stagedHouses),
            AddedTitles = new List<TitleFeatureDto>(_stagedTitles),
            UpdatedTrees = _editedTrees.Values.ToList(),
            UpdatedHouses = _editedHouses.Values.ToList(),
            UpdatedTitles = _editedTitles.Values.ToList(),
            DeletedTreeIds = _deletedTreeIds.ToList(),
            DeletedHouseIds = _deletedHouseIds.ToList(),
            DeletedTitleIds = _deletedTitleIds.ToList(),
            AddedWaterPolygons = new List<AreaPolygonDto>(_stagedWaterPolygons),
            DeletedWaterPolygonIds = _deletedWaterPolygonIds.ToList(),
            UpdatedWaterPolygons = _editedWaterPolygons.Values
                .Select(ClonePolygon)
                .ToList(),
            AddedLandPolygons = new List<AreaPolygonDto>(_stagedLandPolygons),
            DeletedLandPolygonIds = _deletedLandPolygonIds.ToList(),
            UpdatedLandPolygons = _editedLandPolygons.Values
                .Select(ClonePolygon)
                .ToList()
        };

        var response = await Http.PostAsJsonAsync("api/demo-map/edits", request);

        if (response.IsSuccessStatusCode)
        {
            var map = await response.Content.ReadFromJsonAsync<MapDto>();
            _trees = map?.Trees ?? new List<TreeFeatureDto>();
            _houses = map?.Houses ?? new List<HouseFeatureDto>();
            _titles = map?.Titles ?? new List<TitleFeatureDto>();
            _waterPolygons.Clear();
            _landPolygons.Clear();
            LoadAreaPolygons(map);
            _editedWaterPolygons.Clear();
            _deletedWaterPolygonIds.Clear();
            _editedLandPolygons.Clear();
            _deletedLandPolygonIds.Clear();
            _editedTrees.Clear();
            _editedHouses.Clear();
            _editedTitles.Clear();
            _deletedTreeIds.Clear();
            _deletedHouseIds.Clear();
            _deletedTitleIds.Clear();
            LoadAreaLayers(map);
            _stagedTrees.Clear();
            _stagedHouses.Clear();
            _stagedTitles.Clear();
            _statusMessage = $"Saved {pendingCount} item{(pendingCount == 1 ? string.Empty : "s")}.";
            ClearEditSelection(true);
            await DrawAsync();
        }
        else
        {
            _statusMessage = "Failed to save changes.";
        }

        _isSaving = false;
    }

    private async Task ReloadAsync()
    {
        await LoadMapAsync();
        await DrawAsync();
    }

    private async Task PerformUndoAsync()
    {
        if (_undoStack.Count == 0)
        {
            _statusMessage = "Nothing to undo.";
            return;
        }

        _redoStack.Add(CaptureUndoState());
        _isUndoing = true;
        _undoBatchKind = UndoBatchKind.None;
        _undoBatchPushed = false;

        var state = _undoStack[^1];
        _undoStack.RemoveAt(_undoStack.Count - 1);
        ApplyUndoState(state);
        ClearEditSelection(true);
        _statusMessage = "Undo complete.";
        _isUndoing = false;
        await DrawAsync();
    }

    private async Task PerformRedoAsync()
    {
        if (_redoStack.Count == 0)
        {
            _statusMessage = "Nothing to redo.";
            return;
        }

        _undoStack.Add(CaptureUndoState());
        _isRedoing = true;
        _undoBatchKind = UndoBatchKind.None;
        _undoBatchPushed = false;

        var state = _redoStack[^1];
        _redoStack.RemoveAt(_redoStack.Count - 1);
        ApplyUndoState(state);
        ClearEditSelection(true);
        _statusMessage = "Redo complete.";
        _isRedoing = false;
        await DrawAsync();
    }

    private async Task LoadMapAsync()
    {
        _isLoading = true;
        _statusMessage = "Loading map from the server...";

        if (!IsLoggedIn)
        {
            _trees = new List<TreeFeatureDto>();
            _houses = new List<HouseFeatureDto>();
            _titles = new List<TitleFeatureDto>();
            _waterPolygons.Clear();
            _landPolygons.Clear();
            _hasMap = false;
            ResetAreaLayers();
            ClearStaged();
            ClearUndoHistory();
            _statusMessage = "Log in, then return to Start to create a map.";
            _isLoading = false;
            return;
        }

        if (MapId <= 0)
        {
            _trees = new List<TreeFeatureDto>();
            _houses = new List<HouseFeatureDto>();
            _titles = new List<TitleFeatureDto>();
            _waterPolygons.Clear();
            _landPolygons.Clear();
            _hasMap = false;
            ResetAreaLayers();
            ClearStaged();
            ClearUndoHistory();
            _statusMessage = "Select a map from Start.";
            _isLoading = false;
            return;
        }

        var map = await Http.GetFromJsonAsync<MapDto>(GetMapUrl());
        _trees = map?.Trees ?? new List<TreeFeatureDto>();
        _houses = map?.Houses ?? new List<HouseFeatureDto>();
        _titles = map?.Titles ?? new List<TitleFeatureDto>();
        _waterPolygons.Clear();
        _landPolygons.Clear();
        LoadAreaPolygons(map);
        _editedWaterPolygons.Clear();
        _editedLandPolygons.Clear();
        _editedTrees.Clear();
        _editedHouses.Clear();
        _hasMap = map?.Id > 0;
        LoadAreaLayers(map);
        ClearStaged();
        ClearUndoHistory();

        _statusMessage = _hasMap
            ? "Map loaded from the database."
            : "No map found. Return to Start and click New Map.";
        _isLoading = false;
    }

    [JSInvokable]
    public Task HandleUndoShortcut()
    {
        return PerformUndoAsync();
    }

    private async Task DrawAsync()
    {
        var renderState = BuildRenderState();
        await JS.InvokeVoidAsync("inkAndRealmDemo.drawMap", CanvasId, renderState);
    }

    private Task SelectPlacement(PlacementType placementType)
    {
        _placementType = placementType;
        if (IsPointPlacement(placementType))
        {
            if (_editingPolygon is not null)
            {
                _editingPolygon = null;
                _editingOriginalPoints = null;
                _editingPointIndex = -1;
                _editingEdgeIndex = -1;
                _isDraggingEditPoint = false;
                _ = InvokeAsync(DrawAsync);
            }
        }
        return Task.CompletedTask;
    }

    private async Task SelectTool(MapToolType tool)
    {
        if (tool == MapToolType.Undo)
        {
            await PerformUndoAsync();
            return;
        }
        if (tool == MapToolType.Redo)
        {
            await PerformRedoAsync();
            return;
        }

        _activeTool = tool;
        if (_isBrushing)
        {
            var keepUndo = _brushStrokeCount > 0;
            _isBrushing = false;
            _brushStrokeCount = 0;
            if (_undoBatchKind == UndoBatchKind.Brush)
            {
                EndUndoBatch(keepUndo);
            }
        }
        if (_isErasing)
        {
            var keepUndo = _eraseCount > 0;
            _isErasing = false;
            _eraseCount = 0;
            if (_undoBatchKind == UndoBatchKind.Eraser)
            {
                EndUndoBatch(keepUndo);
            }
        }
        if (_activeTool != MapToolType.Brush)
        {
            _hasBrushCursor = false;
        }
        if (tool != MapToolType.Edit && (_editingPolygon is not null || _editingPointFeature is not null))
        {
            ClearEditSelection(false);
            _ = InvokeAsync(DrawAsync);
        }
        _statusMessage = ActiveToolDefinition.IsImplemented
            ? $"{ActiveToolDefinition.Label} tool selected."
            : $"{ActiveToolDefinition.Label} tool is not available yet.";

        if (tool == MapToolType.Edit)
        {
            _statusMessage = "Edit tool selected. Click a feature to edit; right-click to confirm.";
        }

        if (tool == MapToolType.Duplicate)
        {
            _statusMessage = "Duplicate tool selected. Click a feature to clone.";
        }
    }

    private void SelectEraserTarget(EraserTarget target)
    {
        _eraserTarget = target;
        _statusMessage = $"Eraser set to {GetEraserTargetLabel(target)}.";
    }

    private void EnsureAreaLayers()
    {
        if (_areaLayers.Count == 0)
        {
            var featureType = GetAreaPlacementFeatureType();
            var layer = new AreaLayerDto
            {
                LayerKey = $"{featureType.ToLowerInvariant()}-0",
                LayerIndex = 0,
                FeatureType = featureType
            };
            _areaLayers.Add(layer);
            _activeAreaLayer = layer;
        }
        else if (_activeAreaLayer is null)
        {
            _activeAreaLayer = _areaLayers.OrderBy(layer => layer.LayerIndex).First();
        }
    }

    private void LoadAreaLayers(MapDto? map)
    {
        var desiredLayerIndex = _activeAreaLayer?.LayerIndex;
        _areaLayers.Clear();
        if (map?.AreaLayers is not null && map.AreaLayers.Count > 0)
        {
            _areaLayers.AddRange(map.AreaLayers);
        }

        NormalizeAreaLayers();
        if (_areaLayers.Count > 0)
        {
            _activeAreaLayer = desiredLayerIndex is null
                ? null
                : _areaLayers.FirstOrDefault(layer => layer.LayerIndex == desiredLayerIndex.Value);
        }
        else
        {
            _activeAreaLayer = null;
        }
        EnsureAreaLayers();
    }

    private void LoadAreaPolygons(MapDto? map)
    {
        if (map?.AreaPolygons is null || map.AreaPolygons.Count == 0)
        {
            return;
        }

        foreach (var polygon in map.AreaPolygons)
        {
            if (polygon is null || polygon.Points.Count == 0)
            {
                continue;
            }

            if (IsLandFeatureType(polygon.FeatureType))
            {
                _landPolygons.Add(polygon);
            }
            else if (IsWaterFeatureType(polygon.FeatureType))
            {
                _waterPolygons.Add(polygon);
            }
        }
    }

    private void ResetAreaLayers()
    {
        _areaLayers.Clear();
        _activeAreaLayer = null;
        EnsureAreaLayers();
    }

    private void NormalizeAreaLayers()
    {
        if (_areaLayers.Count == 0)
        {
            return;
        }

        _areaLayers.Sort((left, right) =>
        {
            var indexCompare = left.LayerIndex.CompareTo(right.LayerIndex);
            return indexCompare != 0 ? indexCompare : string.CompareOrdinal(left.LayerKey, right.LayerKey);
        });
    }

    private void AddAreaLayer()
    {
        PushUndoState();
        var nextIndex = GetNextLayerIndex();
        var featureType = GetAreaPlacementFeatureType();
        var layer = new AreaLayerDto
        {
            LayerKey = $"{featureType.ToLowerInvariant()}-{nextIndex}",
            LayerIndex = nextIndex,
            FeatureType = featureType
        };
        _areaLayers.Add(layer);
        NormalizeAreaLayers();
        _activeAreaLayer = layer;
        _statusMessage = $"{GetLayerLabel(layer)} created.";
    }

    private void SelectAreaLayer(AreaLayerDto layer)
    {
        _activeAreaLayer = layer;
        _statusMessage = $"{GetLayerLabel(layer)} selected.";
    }

    private async Task PromptDeleteLayerAsync(AreaLayerDto layer)
    {
        var label = GetLayerLabel(layer);
        var confirmed = await JS.InvokeAsync<bool>(
            "confirm",
            $"Delete {label}? Deleting the layer removes everything on that layer. Continue?");
        if (!confirmed)
        {
            return;
        }

        PushUndoState();
        DeleteAreaLayer(layer);
        _statusMessage = $"{label} deleted.";
        await DrawAsync();
    }

    private void DeleteAreaLayer(AreaLayerDto layer)
    {
        var layerIndex = layer.LayerIndex;
        if (_activeAreaLayer?.LayerIndex == layerIndex)
        {
            _activePolygonPoints.Clear();
        }

        if (_editingPolygon is not null && _editingPolygon.LayerIndex == layerIndex)
        {
            ClearEditSelection(true);
        }

        _stagedWaterPolygons.RemoveAll(polygon => polygon.LayerIndex == layerIndex);
        _stagedLandPolygons.RemoveAll(polygon => polygon.LayerIndex == layerIndex);

        foreach (var polygonId in _editedWaterPolygons
                     .Where(entry => entry.Value.LayerIndex == layerIndex)
                     .Select(entry => entry.Key)
                     .ToList())
        {
            _editedWaterPolygons.Remove(polygonId);
        }

        foreach (var polygonId in _editedLandPolygons
                     .Where(entry => entry.Value.LayerIndex == layerIndex)
                     .Select(entry => entry.Key)
                     .ToList())
        {
            _editedLandPolygons.Remove(polygonId);
        }

        foreach (var polygonId in _waterPolygons
                     .Where(polygon => polygon.LayerIndex == layerIndex && polygon.Id > 0)
                     .Select(polygon => polygon.Id))
        {
            _deletedWaterPolygonIds.Add(polygonId);
        }

        foreach (var polygonId in _landPolygons
                     .Where(polygon => polygon.LayerIndex == layerIndex && polygon.Id > 0)
                     .Select(polygon => polygon.Id))
        {
            _deletedLandPolygonIds.Add(polygonId);
        }

        _waterPolygons.RemoveAll(polygon => polygon.LayerIndex == layerIndex);
        _landPolygons.RemoveAll(polygon => polygon.LayerIndex == layerIndex);
        _areaLayers.RemoveAll(existing => existing.LayerIndex == layerIndex);

        if (_activeAreaLayer == layer)
        {
            _activeAreaLayer = null;
        }

        NormalizeAreaLayers();
        EnsureAreaLayers();
    }

    private int GetNextLayerIndex()
    {
        return _areaLayers.Count == 0 ? 0 : _areaLayers.Max(layer => layer.LayerIndex) + 1;
    }

    private string GetLayerLabel(AreaLayerDto layer, int fallbackIndex = 0)
    {
        var index = layer.LayerIndex >= 0 ? layer.LayerIndex : fallbackIndex;
        return $"Layer {index + 1}";
    }

    private string GetEraserTargetLabel(EraserTarget target)
    {
        return EraserTargetDefinitions.First(definition => definition.Target == target).Label;
    }


    private string GetMapUrl()
    {
        var sessionToken = UserState.CurrentUser?.SessionToken;
        if (!string.IsNullOrWhiteSpace(sessionToken))
        {
            return $"api/demo-map/{MapId}?sessionToken={Uri.EscapeDataString(sessionToken)}";
        }

        var userId = UserState.CurrentUser?.UserId;
        return userId is null ? $"api/demo-map/{MapId}" : $"api/demo-map/{MapId}?userId={userId.Value}";
    }

    private void OnUserChanged()
    {
        _ = InvokeAsync(async () =>
        {
            await LoadMapAsync();
            await DrawAsync();
            StateHasChanged();
        });
    }

    private void GoHome()
    {
        Navigation.NavigateTo("/");
    }

    public void Dispose()
    {
        UserState.Changed -= OnUserChanged;
        if (_undoShortcutRef is not null)
        {
            _ = JS.InvokeVoidAsync("inkAndRealmDemo.unregisterUndoShortcut", CanvasId);
            _undoShortcutRef.Dispose();
            _undoShortcutRef = null;
        }
    }

    private void ClearStaged()
    {
        _stagedTrees.Clear();
        _stagedHouses.Clear();
        _stagedTitles.Clear();
        _stagedWaterPolygons.Clear();
        _stagedLandPolygons.Clear();
        _editedWaterPolygons.Clear();
        _deletedWaterPolygonIds.Clear();
        _editedLandPolygons.Clear();
        _deletedLandPolygonIds.Clear();
        _editedTrees.Clear();
        _editedHouses.Clear();
        _editedTitles.Clear();
        _deletedTreeIds.Clear();
        _deletedHouseIds.Clear();
        _deletedTitleIds.Clear();
        _activePolygonPoints.Clear();
        ClearEditSelection(false);
        _hasLastPlacement = false;
        _isBrushing = false;
        _brushStrokeCount = 0;
        _isErasing = false;
        _eraseCount = 0;
        _hasBrushCursor = false;
    }

    private void ClearUndoHistory()
    {
        _undoStack.Clear();
        _redoStack.Clear();
        _undoBatchKind = UndoBatchKind.None;
        _undoBatchPushed = false;
    }

    private void BeginUndoBatch(UndoBatchKind kind)
    {
        _undoBatchKind = kind;
        _undoBatchPushed = false;
    }

    private void EndUndoBatch(bool keepChanges)
    {
        if (_undoBatchKind == UndoBatchKind.None)
        {
            return;
        }

        if (!keepChanges && _undoBatchPushed && _undoStack.Count > 0)
        {
            _undoStack.RemoveAt(_undoStack.Count - 1);
        }

        _undoBatchKind = UndoBatchKind.None;
        _undoBatchPushed = false;
    }

    private void PushUndoState()
    {
        if (_isUndoing)
        {
            return;
        }

        if (_undoBatchKind != UndoBatchKind.None && _undoBatchPushed)
        {
            return;
        }

        if (!_isRedoing && _redoStack.Count > 0)
        {
            _redoStack.Clear();
        }

        _undoStack.Add(CaptureUndoState());

        if (_undoBatchKind != UndoBatchKind.None)
        {
            _undoBatchPushed = true;
        }
    }

    private UndoState CaptureUndoState()
    {
        return new UndoState
        {
            Trees = CloneList(_trees),
            Houses = CloneList(_houses),
            Titles = CloneList(_titles),
            StagedTrees = CloneList(_stagedTrees),
            StagedHouses = CloneList(_stagedHouses),
            StagedTitles = CloneList(_stagedTitles),
            WaterPolygons = CloneList(_waterPolygons),
            StagedWaterPolygons = CloneList(_stagedWaterPolygons),
            EditedWaterPolygons = CloneDictionary(_editedWaterPolygons),
            DeletedWaterPolygonIds = new HashSet<int>(_deletedWaterPolygonIds),
            LandPolygons = CloneList(_landPolygons),
            StagedLandPolygons = CloneList(_stagedLandPolygons),
            EditedLandPolygons = CloneDictionary(_editedLandPolygons),
            DeletedLandPolygonIds = new HashSet<int>(_deletedLandPolygonIds),
            EditedTrees = CloneDictionary(_editedTrees),
            EditedHouses = CloneDictionary(_editedHouses),
            EditedTitles = CloneDictionary(_editedTitles),
            DeletedTreeIds = new HashSet<int>(_deletedTreeIds),
            DeletedHouseIds = new HashSet<int>(_deletedHouseIds),
            DeletedTitleIds = new HashSet<int>(_deletedTitleIds),
            AreaLayers = CloneList(_areaLayers),
            ActiveAreaLayerKey = _activeAreaLayer?.LayerKey,
            ActiveAreaLayerIndex = _activeAreaLayer?.LayerIndex,
            LastX = _lastX,
            LastY = _lastY,
            HasLastPlacement = _hasLastPlacement
        };
    }

    private void ApplyUndoState(UndoState state)
    {
        ReplaceListContents(_trees, state.Trees);
        ReplaceListContents(_houses, state.Houses);
        ReplaceListContents(_titles, state.Titles);
        ReplaceListContents(_stagedTrees, state.StagedTrees);
        ReplaceListContents(_stagedHouses, state.StagedHouses);
        ReplaceListContents(_stagedTitles, state.StagedTitles);
        ReplaceListContents(_waterPolygons, state.WaterPolygons);
        ReplaceListContents(_stagedWaterPolygons, state.StagedWaterPolygons);
        ReplaceDictionaryContents(_editedWaterPolygons, state.EditedWaterPolygons);
        ReplaceSetContents(_deletedWaterPolygonIds, state.DeletedWaterPolygonIds);
        ReplaceListContents(_landPolygons, state.LandPolygons);
        ReplaceListContents(_stagedLandPolygons, state.StagedLandPolygons);
        ReplaceDictionaryContents(_editedLandPolygons, state.EditedLandPolygons);
        ReplaceSetContents(_deletedLandPolygonIds, state.DeletedLandPolygonIds);
        ReplaceDictionaryContents(_editedTrees, state.EditedTrees);
        ReplaceDictionaryContents(_editedHouses, state.EditedHouses);
        ReplaceDictionaryContents(_editedTitles, state.EditedTitles);
        ReplaceSetContents(_deletedTreeIds, state.DeletedTreeIds);
        ReplaceSetContents(_deletedHouseIds, state.DeletedHouseIds);
        ReplaceSetContents(_deletedTitleIds, state.DeletedTitleIds);
        ReplaceListContents(_areaLayers, state.AreaLayers);

        _activeAreaLayer = null;
        if (!string.IsNullOrWhiteSpace(state.ActiveAreaLayerKey))
        {
            _activeAreaLayer = _areaLayers.FirstOrDefault(layer => layer.LayerKey == state.ActiveAreaLayerKey);
        }

        if (_activeAreaLayer is null && state.ActiveAreaLayerIndex is not null)
        {
            _activeAreaLayer = _areaLayers.FirstOrDefault(layer => layer.LayerIndex == state.ActiveAreaLayerIndex.Value);
        }

        if (_activeAreaLayer is null && _areaLayers.Count > 0)
        {
            _activeAreaLayer = _areaLayers.OrderBy(layer => layer.LayerIndex).First();
        }

        _lastX = state.LastX;
        _lastY = state.LastY;
        _hasLastPlacement = state.HasLastPlacement;

        _activePolygonPoints.Clear();
        _isBrushing = false;
        _brushStrokeCount = 0;
        _isErasing = false;
        _eraseCount = 0;
        _hasBrushCursor = false;
    }

    private static List<T> CloneList<T>(IEnumerable<T> source)
    {
        return CloneDto(source.ToList());
    }

    private static Dictionary<int, T> CloneDictionary<T>(Dictionary<int, T> source)
    {
        return source.ToDictionary(entry => entry.Key, entry => CloneDto(entry.Value));
    }

    private static void ReplaceListContents<T>(List<T> target, List<T> source)
    {
        target.Clear();
        target.AddRange(source);
    }

    private static void ReplaceDictionaryContents<T>(Dictionary<int, T> target, Dictionary<int, T> source)
    {
        target.Clear();
        foreach (var entry in source)
        {
            target[entry.Key] = entry.Value;
        }
    }

    private static void ReplaceSetContents<T>(HashSet<T> target, HashSet<T> source)
    {
        target.Clear();
        foreach (var value in source)
        {
            target.Add(value);
        }
    }

    private async Task UpdateCanvasClientSizeAsync()
    {
        var size = await JS.InvokeAsync<CanvasClientSize?>("inkAndRealmDemo.getCanvasClientSize", CanvasId);
        if (size is null || size.Width <= 0 || size.Height <= 0)
        {
            _canvasClientWidth = CanvasWidth;
            _canvasClientHeight = CanvasHeight;
            return;
        }

        _canvasClientWidth = size.Width;
        _canvasClientHeight = size.Height;
    }

    private string GetStyleForPlacement(PlacementType placementType)
    {
        return _selectedStyleByPlacement.TryGetValue(placementType, out var style)
            ? style
            : string.Empty;
    }

    private float GetPointSizeForPlacement(PlacementType placementType)
    {
        if (!IsPointPlacement(placementType))
        {
            return 1f;
        }

        return _pointSizeByPlacement.TryGetValue(placementType, out var size)
            ? size
            : 1f;
    }

    private void SetPointSizeForPlacement(PlacementType placementType, float value)
    {
        if (!IsPointPlacement(placementType))
        {
            return;
        }

        _pointSizeByPlacement[placementType] = NormalizePointSize(value);
    }

    private static bool IsPointPlacement(PlacementType placementType)
    {
        return placementType == PlacementType.Tree || placementType == PlacementType.House;
    }

    private static bool IsTitlePlacement(PlacementType placementType)
    {
        return placementType == PlacementType.Title;
    }

    private static bool CanDragTitle(TitleFeatureDto title)
    {
        return !title.TargetFeatureId.HasValue
            && (title.Points is null || title.Points.Count < 3);
    }

    private static bool IsLandFeatureType(string? featureType)
    {
        return string.Equals(featureType, "Land", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsWaterFeatureType(string? featureType)
    {
        return string.Equals(featureType, "Water", StringComparison.OrdinalIgnoreCase);
    }

    private string GetAreaPlacementFeatureType()
    {
        return _placementType == PlacementType.Land ? "Land" : "Water";
    }

    private static float NormalizePointSize(float size)
    {
        return float.IsFinite(size) && size > 0f ? size : 1f;
    }

    private static string NormalizeTitleName(string? name)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return "Untitled";
        }

        var trimmed = name.Trim();
        return trimmed.Length <= TitleNameMaxLength ? trimmed : trimmed[..TitleNameMaxLength];
    }

    private static float NormalizeTitleSize(float size)
    {
        if (!float.IsFinite(size))
        {
            return 1f;
        }

        if (size < TitleSizeMin)
        {
            return TitleSizeMin;
        }

        if (size > TitleSizeMax)
        {
            return TitleSizeMax;
        }

        return size;
    }

    private float GetCanvasScaleX()
    {
        return _canvasClientWidth > 0 ? (CanvasWidth / _canvasClientWidth) : 1f;
    }

    private float GetCanvasScaleY()
    {
        return _canvasClientHeight > 0 ? (CanvasHeight / _canvasClientHeight) : 1f;
    }

    private void ClearEditSelection(bool keepChanges)
    {
        if (!keepChanges && _editingPolygon is not null && _editingOriginalPoints is not null)
        {
            _editingPolygon.Points = _editingOriginalPoints
                .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                .ToList();
        }

        if (!keepChanges && _editingPointFeature is not null && _editingPointOriginalPosition is not null)
        {
            UpdatePointFeaturePosition(_editingPointFeature, _editingPointOriginalPosition.X, _editingPointOriginalPosition.Y);
        }

        if (!keepChanges && _editingTitleFeature is not null && _editingTitleOriginalPosition is not null)
        {
            _editingTitleFeature.Title.X = _editingTitleOriginalPosition.X;
            _editingTitleFeature.Title.Y = _editingTitleOriginalPosition.Y;
        }

        if (!_isUndoing && _undoBatchKind == UndoBatchKind.Edit)
        {
            EndUndoBatch(keepChanges && _undoBatchPushed);
        }

        _editingPolygon = null;
        _editingOriginalPoints = null;
        _editingPointIndex = -1;
        _editingEdgeIndex = -1;
        _isDraggingEditPoint = false;
        _editingPointFeature = null;
        _editingPointOriginalPosition = null;
        _isDraggingEditPointFeature = false;
        _editingTitleFeature = null;
        _editingTitleOriginalPosition = null;
        _isDraggingTitleFeature = false;
    }

    private void TrackEditedPolygon(AreaPolygonDto polygon)
    {
        if (polygon.Id <= 0)
        {
            return;
        }

        if (IsLandFeatureType(polygon.FeatureType))
        {
            _editedLandPolygons[polygon.Id] = ClonePolygon(polygon);
        }
        else
        {
            _editedWaterPolygons[polygon.Id] = ClonePolygon(polygon);
        }
    }

    private void TrackEditedPointFeature(EditingPointFeature feature)
    {
        if (feature.Tree is not null)
        {
            if (feature.IsStaged || feature.Tree.Id <= 0)
            {
                return;
            }

            _editedTrees[feature.Tree.Id] = feature.Tree;
            return;
        }

        if (feature.House is not null)
        {
            if (feature.IsStaged || feature.House.Id <= 0)
            {
                return;
            }

            _editedHouses[feature.House.Id] = feature.House;
        }
    }

    private void TrackEditedTitleFeature(EditingTitleFeature feature)
    {
        if (feature.IsStaged || feature.Title.Id <= 0)
        {
            return;
        }

        _editedTitles[feature.Title.Id] = feature.Title;
    }

    private static AreaPolygonDto ClonePolygon(AreaPolygonDto polygon)
    {
        return CloneDto(polygon);
    }

    private AreaPolygonDto? FindPolygonAtPoint(float mapX, float mapY)
    {
        return FindPolygonAtPoint(mapX, mapY, true, null);
    }

    private AreaPolygonDto? FindPolygonAtPoint(float mapX, float mapY, bool restrictToActiveLayer)
    {
        return FindPolygonAtPoint(mapX, mapY, restrictToActiveLayer, null);
    }

    private AreaPolygonDto? FindPolygonAtPoint(float mapX, float mapY, bool restrictToActiveLayer, string? featureTypeFilter)
    {
        var activeLayerIndex = restrictToActiveLayer ? _activeAreaLayer?.LayerIndex : null;
        var candidates = GetPolygonCandidates(featureTypeFilter);
        AreaPolygonDto? selected = null;
        var selectedLayer = int.MinValue;
        var selectedOrder = -1;

        for (var i = 0; i < candidates.Count; i += 1)
        {
            var polygon = candidates[i];
            if (polygon.Points.Count < 3)
            {
                continue;
            }

            if (activeLayerIndex is not null && polygon.LayerIndex != activeLayerIndex.Value)
            {
                continue;
            }

            if (!IsPointInPolygon(mapX, mapY, polygon))
            {
                continue;
            }

            var layerIndex = polygon.LayerIndex;
            if (layerIndex > selectedLayer || (layerIndex == selectedLayer && i > selectedOrder))
            {
                selected = polygon;
                selectedLayer = layerIndex;
                selectedOrder = i;
            }
        }

        return selected;
    }

    private List<AreaPolygonDto> GetPolygonCandidates(string? featureTypeFilter)
    {
        IEnumerable<AreaPolygonDto> candidates = _waterPolygons.Concat(_stagedWaterPolygons)
            .Concat(_landPolygons)
            .Concat(_stagedLandPolygons);

        if (!string.IsNullOrWhiteSpace(featureTypeFilter))
        {
            candidates = candidates.Where(polygon => string.Equals(
                polygon.FeatureType,
                featureTypeFilter,
                StringComparison.OrdinalIgnoreCase));
        }

        return candidates.ToList();
    }

    private async Task DuplicateFeatureAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        var hitRadius = GetEditHitRadius();
        if (_placementType == PlacementType.Title)
        {
            var titleFeature = FindTitleFeatureAtPoint(mapX, mapY, hitRadius);
            if (titleFeature is not null)
            {
                var placed = DuplicateTitleFeature(titleFeature);
                _statusMessage = placed
                    ? "Title duplicated (unsaved)."
                    : "Duplicate failed (feature out of bounds).";
                if (placed)
                {
                    await DrawAsync();
                }
                return;
            }
        }

        var pointFeature = FindPointFeatureAtPoint(mapX, mapY, hitRadius);
        if (pointFeature is not null)
        {
            var placed = DuplicatePointFeature(pointFeature);
            _statusMessage = placed
                ? "Feature duplicated (unsaved)."
                : "Duplicate failed (feature out of bounds).";
            if (placed)
            {
                await DrawAsync();
            }
            return;
        }

        if (_placementType != PlacementType.Title)
        {
            var titleFeature = FindTitleFeatureAtPoint(mapX, mapY, hitRadius);
            if (titleFeature is not null)
            {
                var placed = DuplicateTitleFeature(titleFeature);
                _statusMessage = placed
                    ? "Title duplicated (unsaved)."
                    : "Duplicate failed (feature out of bounds).";
                if (placed)
                {
                    await DrawAsync();
                }
                return;
            }
        }

        var polygon = FindPolygonAtPoint(mapX, mapY, false);
        if (polygon is not null)
        {
            DuplicatePolygon(polygon);
            _statusMessage = "Polygon duplicated (unsaved).";
            await DrawAsync();
            return;
        }

        _statusMessage = "No feature found to duplicate.";
    }

    private bool DuplicatePointFeature(EditingPointFeature feature)
    {
        var source = GetPointFeaturePosition(feature);
        if (source is null)
        {
            return false;
        }

        PushUndoState();
        var (newX, newY) = GetAdjacentPoint(source.X, source.Y);

        if (feature.Tree is not null)
        {
            var clone = CloneDto(feature.Tree);
            clone.Id = 0;
            clone.X = newX;
            clone.Y = newY;
            _stagedTrees.Add(clone);
            return true;
        }

        if (feature.House is not null)
        {
            var clone = CloneDto(feature.House);
            clone.Id = 0;
            clone.X = newX;
            clone.Y = newY;
            _stagedHouses.Add(clone);
            return true;
        }

        return false;
    }

    private bool DuplicateTitleFeature(EditingTitleFeature feature)
    {
        PushUndoState();
        var clone = CloneDto(feature.Title);
        clone.Id = 0;

        if (clone.Points is not null && clone.Points.Count >= 3)
        {
            var (offsetX, offsetY) = GetAdjacentOffsetForPoints(clone.Points);
            foreach (var point in clone.Points)
            {
                point.X = Math.Clamp(point.X + offsetX, 0f, MapWidth);
                point.Y = Math.Clamp(point.Y + offsetY, 0f, MapHeight);
            }
            clone.X = Math.Clamp(clone.X + offsetX, 0f, MapWidth);
            clone.Y = Math.Clamp(clone.Y + offsetY, 0f, MapHeight);
        }
        else if (!clone.TargetFeatureId.HasValue)
        {
            var position = GetTitlePosition(feature.Title);
            var (newX, newY) = GetAdjacentPoint(position.X, position.Y);
            clone.X = newX;
            clone.Y = newY;
        }

        _stagedTitles.Add(clone);
        return true;
    }

    private void DuplicatePolygon(AreaPolygonDto polygon)
    {
        PushUndoState();
        var clone = CloneDto(polygon);
        clone.Id = 0;
        var (offsetX, offsetY) = GetAdjacentOffsetForPolygon(clone);

        foreach (var point in clone.Points)
        {
            point.X = Math.Clamp(point.X + offsetX, 0f, MapWidth);
            point.Y = Math.Clamp(point.Y + offsetY, 0f, MapHeight);
        }

        if (IsLandFeatureType(clone.FeatureType))
        {
            _stagedLandPolygons.Add(clone);
        }
        else
        {
            _stagedWaterPolygons.Add(clone);
        }
    }

    private static T CloneDto<T>(T source)
    {
        var json = JsonSerializer.Serialize(source);
        var clone = JsonSerializer.Deserialize<T>(json);
        if (clone is null)
        {
            throw new InvalidOperationException("Failed to clone map feature.");
        }
        return clone;
    }

    private (float X, float Y) GetAdjacentPoint(float x, float y)
    {
        var offset = GetDuplicateOffset();
        var candidates = new (float Dx, float Dy)[]
        {
            (offset, 0f),
            (0f, offset),
            (-offset, 0f),
            (0f, -offset),
            (offset, offset),
            (-offset, offset),
            (offset, -offset),
            (-offset, -offset)
        };

        foreach (var (dx, dy) in candidates)
        {
            var nx = x + dx;
            var ny = y + dy;
            if (nx >= 0f && nx <= MapWidth && ny >= 0f && ny <= MapHeight)
            {
                return (nx, ny);
            }
        }

        return (Math.Clamp(x + offset, 0f, MapWidth), Math.Clamp(y + offset, 0f, MapHeight));
    }

    private (float Dx, float Dy) GetAdjacentOffsetForPolygon(AreaPolygonDto polygon)
    {
        if (polygon.Points.Count == 0)
        {
            return (0f, 0f);
        }

        var offset = GetDuplicateOffset();
        var minX = polygon.Points.Min(point => point.X);
        var maxX = polygon.Points.Max(point => point.X);
        var minY = polygon.Points.Min(point => point.Y);
        var maxY = polygon.Points.Max(point => point.Y);
        var minDx = -minX;
        var maxDx = MapWidth - maxX;
        var minDy = -minY;
        var maxDy = MapHeight - maxY;

        var candidates = new (float Dx, float Dy)[]
        {
            (offset, 0f),
            (0f, offset),
            (-offset, 0f),
            (0f, -offset),
            (offset, offset),
            (-offset, offset),
            (offset, -offset),
            (-offset, -offset)
        };

        foreach (var (dx, dy) in candidates)
        {
            if (dx >= minDx && dx <= maxDx && dy >= minDy && dy <= maxDy)
            {
                return (dx, dy);
            }
        }

        return (Math.Clamp(offset, minDx, maxDx), Math.Clamp(offset, minDy, maxDy));
    }

    private (float Dx, float Dy) GetAdjacentOffsetForPoints(IReadOnlyList<MapPointDto> points)
    {
        if (points is null || points.Count == 0)
        {
            return (0f, 0f);
        }

        var offset = GetDuplicateOffset();
        var minX = points.Min(point => point.X);
        var maxX = points.Max(point => point.X);
        var minY = points.Min(point => point.Y);
        var maxY = points.Max(point => point.Y);
        var minDx = -minX;
        var maxDx = MapWidth - maxX;
        var minDy = -minY;
        var maxDy = MapHeight - maxY;

        var candidates = new (float Dx, float Dy)[]
        {
            (offset, 0f),
            (0f, offset),
            (-offset, 0f),
            (0f, -offset),
            (offset, offset),
            (-offset, offset),
            (offset, -offset),
            (-offset, -offset)
        };

        foreach (var (dx, dy) in candidates)
        {
            if (dx >= minDx && dx <= maxDx && dy >= minDy && dy <= maxDy)
            {
                return (dx, dy);
            }
        }

        return (Math.Clamp(offset, minDx, maxDx), Math.Clamp(offset, minDy, maxDy));
    }

    private float GetDuplicateOffset()
    {
        return MathF.Max(16f, GetEditHitRadius() * 1.5f);
    }

    private bool TryErasePolygonAtPoint(float mapX, float mapY, string? featureTypeFilter = null)
    {
        var polygon = FindPolygonAtPoint(mapX, mapY, true, featureTypeFilter);
        if (polygon is null)
        {
            return false;
        }

        if (_editingPolygon == polygon)
        {
            ClearEditSelection(true);
        }

        if (IsLandFeatureType(polygon.FeatureType))
        {
            if (polygon.Id > 0)
            {
                _deletedLandPolygonIds.Add(polygon.Id);
                _editedLandPolygons.Remove(polygon.Id);
            }

            _landPolygons.Remove(polygon);
            _stagedLandPolygons.Remove(polygon);
        }
        else
        {
            if (polygon.Id > 0)
            {
                _deletedWaterPolygonIds.Add(polygon.Id);
                _editedWaterPolygons.Remove(polygon.Id);
            }

            _waterPolygons.Remove(polygon);
            _stagedWaterPolygons.Remove(polygon);
        }

        return true;
    }

    private bool TryErasePointFeatureAtPoint(float mapX, float mapY, EraserTarget target, out string? status)
    {
        status = null;
        EnsureAreaLayers();
        var feature = FindPointFeatureAtPoint(mapX, mapY, GetEditHitRadius(), target, true);
        if (feature is null)
        {
            return false;
        }

        if (_editingPointFeature is not null
            && ((_editingPointFeature.Tree is not null && _editingPointFeature.Tree == feature.Tree)
                || (_editingPointFeature.House is not null && _editingPointFeature.House == feature.House)))
        {
            ClearEditSelection(true);
        }

        if (feature.Tree is not null)
        {
            if (feature.IsStaged)
            {
                _stagedTrees.Remove(feature.Tree);
            }
            else
            {
                if (feature.Tree.Id > 0)
                {
                    _deletedTreeIds.Add(feature.Tree.Id);
                }
                _editedTrees.Remove(feature.Tree.Id);
                _trees.Remove(feature.Tree);
                RemoveTitlesForTargetFeature(feature.Tree.Id);
            }

            status = "Tree erased (unsaved).";
            return true;
        }

        if (feature.House is not null)
        {
            if (feature.IsStaged)
            {
                _stagedHouses.Remove(feature.House);
            }
            else
            {
                if (feature.House.Id > 0)
                {
                    _deletedHouseIds.Add(feature.House.Id);
                }
                _editedHouses.Remove(feature.House.Id);
                _houses.Remove(feature.House);
                RemoveTitlesForTargetFeature(feature.House.Id);
            }

            status = "House erased (unsaved).";
            return true;
        }

        return false;
    }

    private bool TryEraseTitleAtPoint(float mapX, float mapY, out string? status)
    {
        status = null;
        var title = FindTitleFeatureAtPoint(mapX, mapY, GetEditHitRadius());
        if (title is null)
        {
            return false;
        }

        if (_editingTitleFeature is not null && _editingTitleFeature.Title == title.Title)
        {
            ClearEditSelection(true);
        }

        if (title.IsStaged)
        {
            _stagedTitles.Remove(title.Title);
        }
        else
        {
            if (title.Title.Id > 0)
            {
                _deletedTitleIds.Add(title.Title.Id);
            }
            _editedTitles.Remove(title.Title.Id);
            _titles.Remove(title.Title);
        }

        status = "Title erased (unsaved).";
        return true;
    }

    private void RemoveTitlesForTargetFeature(int featureId)
    {
        if (featureId <= 0)
        {
            return;
        }

        var stagedMatches = _stagedTitles
            .Where(title => title.TargetFeatureId == featureId)
            .ToList();
        foreach (var title in stagedMatches)
        {
            _stagedTitles.Remove(title);
        }

        var matches = _titles
            .Where(title => title.TargetFeatureId == featureId)
            .ToList();
        foreach (var title in matches)
        {
            _titles.Remove(title);
            if (title.Id > 0)
            {
                _deletedTitleIds.Add(title.Id);
            }
            _editedTitles.Remove(title.Id);
        }
    }

    private bool TryEraseAtPoint(float mapX, float mapY, out string? status, bool showEmptyStatus)
    {
        status = null;
        var erased = false;

        if (_eraserTarget == EraserTarget.Tree || _eraserTarget == EraserTarget.House)
        {
            erased = TryErasePointFeatureAtPoint(mapX, mapY, _eraserTarget, out status);
            if (!erased && showEmptyStatus)
            {
                status = $"Nothing to erase for {GetEraserTargetLabel(_eraserTarget)}.";
            }

            return erased;
        }

        if (_eraserTarget == EraserTarget.Water)
        {
            EnsureAreaLayers();
            if (_activeAreaLayer is null)
            {
                status = "Select a layer before erasing.";
                return false;
            }

            erased = TryErasePolygonAtPoint(mapX, mapY, "Water");
            if (showEmptyStatus)
            {
                status = erased
                    ? $"Polygon erased from {GetLayerLabel(_activeAreaLayer)} (unsaved)."
                    : $"Nothing to erase on {GetLayerLabel(_activeAreaLayer)}.";
            }

            return erased;
        }

        if (_eraserTarget == EraserTarget.Land)
        {
            EnsureAreaLayers();
            if (_activeAreaLayer is null)
            {
                status = "Select a layer before erasing.";
                return false;
            }

            erased = TryErasePolygonAtPoint(mapX, mapY, "Land");
            if (showEmptyStatus)
            {
                status = erased
                    ? $"Polygon erased from {GetLayerLabel(_activeAreaLayer)} (unsaved)."
                    : $"Nothing to erase on {GetLayerLabel(_activeAreaLayer)}.";
            }

            return erased;
        }

        erased = TryEraseTitleAtPoint(mapX, mapY, out status);
        if (!erased)
        {
            erased = TryErasePointFeatureAtPoint(mapX, mapY, EraserTarget.All, out status);
        }

        if (!erased)
        {
            EnsureAreaLayers();
            if (_activeAreaLayer is null)
            {
                status = "Select a layer before erasing.";
                return false;
            }

            erased = TryErasePolygonAtPoint(mapX, mapY);
            if (showEmptyStatus)
            {
                status = erased
                    ? $"Polygon erased from {GetLayerLabel(_activeAreaLayer)} (unsaved)."
                    : $"Nothing to erase on {GetLayerLabel(_activeAreaLayer)}.";
            }
        }

        return erased;
    }

    private EditingPointFeature? FindPointFeatureAtPoint(float mapX, float mapY, float threshold)
    {
        return FindPointFeatureAtPoint(mapX, mapY, threshold, EraserTarget.All, false);
    }

    private EditingPointFeature? FindPointFeatureAtPoint(
        float mapX,
        float mapY,
        float threshold,
        EraserTarget target,
        bool restrictToActiveLayer)
    {
        if (target == EraserTarget.Water)
        {
            return null;
        }

        if (target == EraserTarget.Land)
        {
            return null;
        }

        var thresholdSquared = threshold * threshold;
        EditingPointFeature? best = null;
        var bestDistance = float.MaxValue;
        var considerTrees = target == EraserTarget.All || target == EraserTarget.Tree;
        var considerHouses = target == EraserTarget.All || target == EraserTarget.House;
        var activeLayerIndex = restrictToActiveLayer ? _activeAreaLayer?.LayerIndex : null;

        void ConsiderTree(TreeFeatureDto tree, bool isStaged)
        {
            if (activeLayerIndex is not null && tree.LayerIndex != activeLayerIndex.Value)
            {
                return;
            }

            var dx = tree.X - mapX;
            var dy = tree.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance > thresholdSquared || distance >= bestDistance)
            {
                return;
            }

            bestDistance = distance;
            best = new EditingPointFeature
            {
                Tree = tree,
                House = null,
                IsStaged = isStaged
            };
        }

        void ConsiderHouse(HouseFeatureDto house, bool isStaged)
        {
            if (activeLayerIndex is not null && house.LayerIndex != activeLayerIndex.Value)
            {
                return;
            }

            var dx = house.X - mapX;
            var dy = house.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance > thresholdSquared || distance >= bestDistance)
            {
                return;
            }

            bestDistance = distance;
            best = new EditingPointFeature
            {
                Tree = null,
                House = house,
                IsStaged = isStaged
            };
        }

        if (considerTrees)
        {
            foreach (var tree in _trees)
            {
                ConsiderTree(tree, false);
            }

            foreach (var tree in _stagedTrees)
            {
                ConsiderTree(tree, true);
            }
        }

        if (considerHouses)
        {
            foreach (var house in _houses)
            {
                ConsiderHouse(house, false);
            }

            foreach (var house in _stagedHouses)
            {
                ConsiderHouse(house, true);
            }
        }

        return best;
    }

    private EditingTitleFeature? FindTitleFeatureAtPoint(float mapX, float mapY, float threshold)
    {
        var thresholdSquared = threshold * threshold;
        EditingTitleFeature? best = null;
        var bestDistance = float.MaxValue;

        void ConsiderTitle(TitleFeatureDto title, bool isStaged)
        {
            var position = GetTitlePosition(title);
            var dx = position.X - mapX;
            var dy = position.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance > thresholdSquared || distance >= bestDistance)
            {
                return;
            }

            bestDistance = distance;
            best = new EditingTitleFeature
            {
                Title = title,
                IsStaged = isStaged
            };
        }

        foreach (var title in _titles)
        {
            ConsiderTitle(title, false);
        }

        foreach (var title in _stagedTitles)
        {
            ConsiderTitle(title, true);
        }

        return best;
    }

    private static MapPointDto? GetPointFeaturePosition(EditingPointFeature feature)
    {
        if (feature.Tree is not null)
        {
            return new MapPointDto { X = feature.Tree.X, Y = feature.Tree.Y };
        }

        if (feature.House is not null)
        {
            return new MapPointDto { X = feature.House.X, Y = feature.House.Y };
        }

        return null;
    }

    private MapPointDto GetTitlePosition(TitleFeatureDto title)
    {
        if (title.TargetFeatureId.HasValue)
        {
            var targetId = title.TargetFeatureId.Value;
            var tree = _trees.FirstOrDefault(candidate => candidate.Id == targetId);
            if (tree is not null)
            {
                return new MapPointDto { X = tree.X, Y = tree.Y };
            }

            var house = _houses.FirstOrDefault(candidate => candidate.Id == targetId);
            if (house is not null)
            {
                return new MapPointDto { X = house.X, Y = house.Y };
            }
        }

        if (title.Points is not null && title.Points.Count >= 3)
        {
            return GetPolygonCentroid(title.Points);
        }

        return new MapPointDto { X = title.X, Y = title.Y };
    }

    private static void UpdatePointFeaturePosition(EditingPointFeature feature, float mapX, float mapY)
    {
        if (feature.Tree is not null)
        {
            feature.Tree.X = mapX;
            feature.Tree.Y = mapY;
            return;
        }

        if (feature.House is not null)
        {
            feature.House.X = mapX;
            feature.House.Y = mapY;
        }
    }

    private int FindPointIndex(AreaPolygonDto polygon, float mapX, float mapY, float threshold)
    {
        if (polygon.Points.Count == 0)
        {
            return -1;
        }

        var thresholdSquared = threshold * threshold;
        var bestIndex = -1;
        var bestDistance = float.MaxValue;

        for (var i = 0; i < polygon.Points.Count; i += 1)
        {
            var point = polygon.Points[i];
            var dx = point.X - mapX;
            var dy = point.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance <= thresholdSquared && distance < bestDistance)
            {
                bestDistance = distance;
                bestIndex = i;
            }
        }

        return bestIndex;
    }

    private int FindEdgeIndex(AreaPolygonDto polygon, float mapX, float mapY, float threshold)
    {
        if (polygon.Points.Count < 2)
        {
            return -1;
        }

        var thresholdSquared = threshold * threshold;
        var bestIndex = -1;
        var bestDistance = float.MaxValue;

        for (var i = 0; i < polygon.Points.Count; i += 1)
        {
            var j = (i + 1) % polygon.Points.Count;
            var closest = GetClosestPointOnSegment(polygon.Points[i], polygon.Points[j], mapX, mapY);
            var dx = closest.X - mapX;
            var dy = closest.Y - mapY;
            var distance = (dx * dx) + (dy * dy);
            if (distance <= thresholdSquared && distance < bestDistance)
            {
                bestDistance = distance;
                bestIndex = i;
            }
        }

        return bestIndex;
    }

    private static MapPointDto GetClosestPointOnSegment(AreaPolygonDto polygon, int edgeIndex, float mapX, float mapY)
    {
        var start = polygon.Points[edgeIndex];
        var end = polygon.Points[(edgeIndex + 1) % polygon.Points.Count];
        return GetClosestPointOnSegment(start, end, mapX, mapY);
    }

    private static MapPointDto GetClosestPointOnSegment(MapPointDto start, MapPointDto end, float mapX, float mapY)
    {
        var dx = end.X - start.X;
        var dy = end.Y - start.Y;
        var lengthSquared = (dx * dx) + (dy * dy);
        if (lengthSquared <= float.Epsilon)
        {
            return new MapPointDto { X = start.X, Y = start.Y };
        }

        var t = ((mapX - start.X) * dx + (mapY - start.Y) * dy) / lengthSquared;
        t = Math.Clamp(t, 0f, 1f);
        return new MapPointDto { X = start.X + (t * dx), Y = start.Y + (t * dy) };
    }

    private float GetEditHitRadius()
    {
        var scale = (GetCanvasScaleX() + GetCanvasScaleY()) / 2f;
        return (10f * scale) / _zoom;
    }

    private float GetBrushSpacing()
    {
        var normalized = (_brushTightness - 1f) / 9f;
        return BrushMaxSpacing - ((BrushMaxSpacing - BrushMinSpacing) * normalized);
    }

    private float GetBrushRadius()
    {
        var normalized = (_brushSize - 1f) / 9f;
        return BrushMinRadius + ((BrushMaxRadius - BrushMinRadius) * normalized);
    }

    private float GetBrushStampSpacing()
    {
        var radius = GetBrushRadius();
        var spacing = GetBrushSpacing();
        return MathF.Max(spacing, radius * 0.55f);
    }

    private float GetPolygonSpacing()
    {
        var normalized = (_polygonDensity - 1f) / 9f;
        return PolygonMaxSpacing - ((PolygonMaxSpacing - PolygonMinSpacing) * normalized);
    }

    private void PlacePointFeature(float mapX, float mapY)
    {
        if (!IsPointPlacement(_placementType))
        {
            return;
        }

        EnsureAreaLayers();
        var layerIndex = _activeAreaLayer?.LayerIndex ?? 0;
        _lastX = mapX;
        _lastY = mapY;
        _hasLastPlacement = true;

        var selectedStyle = GetStyleForPlacement(_placementType);
        var selectedSize = GetPointSizeForPlacement(_placementType);
        if (_placementType == PlacementType.House)
        {
            _stagedHouses.Add(new HouseFeatureDto
            {
                X = mapX,
                Y = mapY,
                HouseType = selectedStyle,
                LayerIndex = layerIndex,
                Size = selectedSize
            });
        }
        else
        {
            _stagedTrees.Add(new TreeFeatureDto
            {
                X = mapX,
                Y = mapY,
                TreeType = selectedStyle,
                LayerIndex = layerIndex,
                Size = selectedSize
            });
        }
    }

    private async Task<bool> PlaceTitleAtPointAsync(
        float mapX,
        float mapY,
        bool allowTargetSearch = true,
        IReadOnlyList<MapPointDto>? polygonPoints = null)
    {
        int? targetId = null;

        if (allowTargetSearch)
        {
            var hitRadius = GetEditHitRadius();
            var target = FindPointFeatureAtPoint(mapX, mapY, hitRadius, EraserTarget.All, false);
            if (target is null)
            {
                _statusMessage = "Click a tree or house to attach a title, or use Polygon for area titles.";
                return false;
            }

            var targetIdValue = target.Tree?.Id ?? target.House?.Id ?? 0;
            if (target.IsStaged || targetIdValue <= 0)
            {
                _statusMessage = "Save the feature before adding a title.";
                return false;
            }

            targetId = targetIdValue;
            var targetPosition = GetPointFeaturePosition(target);
            if (targetPosition is not null)
            {
                mapX = targetPosition.X;
                mapY = targetPosition.Y;
            }
        }

        var name = await PromptTitleNameAsync("New Title");
        if (name is null)
        {
            _statusMessage = "Title placement canceled.";
            return false;
        }

        var title = new TitleFeatureDto
        {
            X = mapX,
            Y = mapY,
            Name = name,
            TargetFeatureId = targetId,
            Size = _selectedTitleSize,
            Points = polygonPoints is null
                ? new List<MapPointDto>()
                : polygonPoints.Select(point => new MapPointDto { X = point.X, Y = point.Y }).ToList()
        };
        PushUndoState();
        _lastX = mapX;
        _lastY = mapY;
        _hasLastPlacement = true;
        _stagedTitles.Add(title);
        _statusMessage = "Title placed (unsaved).";
        return true;
    }

    private async Task<string?> PromptTitleNameAsync(string initialName)
    {
        var result = await JS.InvokeAsync<string?>("prompt", "Title name:", initialName);
        if (result is null)
        {
            return null;
        }

        return NormalizeTitleName(result);
    }

    private async Task<string?> PromptTitleRenameAsync(TitleFeatureDto title)
    {
        var result = await JS.InvokeAsync<string?>("prompt", "Edit title name:", title.Name);
        if (result is null)
        {
            return null;
        }

        return NormalizeTitleName(result);
    }

    private int PlacePolygonPointFeatures(IReadOnlyList<MapPointDto> points)
    {
        if (points is null || points.Count < 3)
        {
            return 0;
        }

        var minX = points.Min(point => point.X);
        var maxX = points.Max(point => point.X);
        var minY = points.Min(point => point.Y);
        var maxY = points.Max(point => point.Y);
        if (maxX <= minX || maxY <= minY)
        {
            return 0;
        }

        var spacing = GetPolygonSpacing();
        if (spacing <= 0.5f)
        {
            spacing = 0.5f;
        }

        var polygon = new AreaPolygonDto
        {
            Points = points.Select(point => new MapPointDto { X = point.X, Y = point.Y }).ToList()
        };

        var jitter = spacing * 0.35f;
        var placed = 0;

        if ((maxX - minX) < spacing && (maxY - minY) < spacing)
        {
            var centerX = (minX + maxX) / 2f;
            var centerY = (minY + maxY) / 2f;
            if (IsPointInPolygon(centerX, centerY, polygon))
            {
                PlacePointFeature(centerX, centerY);
                return 1;
            }
        }

        for (var y = minY; y <= maxY; y += spacing)
        {
            for (var x = minX; x <= maxX; x += spacing)
            {
                var candidateX = x + (float)((Random.Shared.NextDouble() * 2 - 1) * jitter);
                var candidateY = y + (float)((Random.Shared.NextDouble() * 2 - 1) * jitter);
                candidateX = Math.Clamp(candidateX, minX, maxX);
                candidateY = Math.Clamp(candidateY, minY, maxY);

                if (!IsPointInPolygon(candidateX, candidateY, polygon))
                {
                    continue;
                }

                PlacePointFeature(candidateX, candidateY);
                placed += 1;

                if (placed >= PolygonMaxPoints)
                {
                    return placed;
                }
            }
        }

        return placed;
    }

    private int PlaceBrushStamp(float centerX, float centerY)
    {
        var radius = GetBrushRadius();
        var spacing = GetBrushSpacing();
        if (radius <= 0.1f || spacing <= 0.1f)
        {
            PlacePointFeature(centerX, centerY);
            return 1;
        }

        if (radius < spacing * 0.75f)
        {
            PlacePointFeature(centerX, centerY);
            return 1;
        }

        var radiusSquared = radius * radius;
        var jitter = spacing * 0.35f;
        var placed = 0;
        var centerPlaced = false;

        for (var y = -radius; y <= radius; y += spacing)
        {
            for (var x = -radius; x <= radius; x += spacing)
            {
                if ((x * x) + (y * y) > radiusSquared)
                {
                    continue;
                }

                var jx = (float)((Random.Shared.NextDouble() * 2 - 1) * jitter);
                var jy = (float)((Random.Shared.NextDouble() * 2 - 1) * jitter);
                var offsetX = x + jx;
                var offsetY = y + jy;
                if (!centerPlaced && (offsetX * offsetX) + (offsetY * offsetY) <= (spacing * spacing * 0.25f))
                {
                    offsetX = 0f;
                    offsetY = 0f;
                    centerPlaced = true;
                }

                var mapX = Math.Clamp(centerX + offsetX, 0f, MapWidth);
                var mapY = Math.Clamp(centerY + offsetY, 0f, MapHeight);
                PlacePointFeature(mapX, mapY);
                placed += 1;

                if (placed >= BrushMaxPointsPerStamp)
                {
                    return placed;
                }
            }
        }

        if (!centerPlaced)
        {
            PlacePointFeature(centerX, centerY);
            placed += 1;
        }

        return placed;
    }

    private async Task StartBrushAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        BeginUndoBatch(UndoBatchKind.Brush);
        PushUndoState();
        _isBrushing = true;
        _hasBrushCursor = true;
        _brushCursorX = mapX;
        _brushCursorY = mapY;
        _brushLastX = mapX;
        _brushLastY = mapY;
        _brushStrokeCount = 0;
        _brushStrokeCount += PlaceBrushStamp(mapX, mapY);
        _statusMessage = "Brushing features...";
        await DrawAsync();
    }

    private async Task ContinueBrushAsync(MouseEventArgs args)
    {
        if (!TryGetMapPoint(args, out var mapX, out var mapY))
        {
            return;
        }

        _hasBrushCursor = true;
        _brushCursorX = mapX;
        _brushCursorY = mapY;
        var spacing = GetBrushStampSpacing();
        var dx = mapX - _brushLastX;
        var dy = mapY - _brushLastY;
        var distance = MathF.Sqrt((dx * dx) + (dy * dy));
        if (distance < spacing)
        {
            await DrawAsync();
            return;
        }

        var steps = Math.Max(1, (int)MathF.Floor(distance / spacing));
        var stepX = (dx / distance) * spacing;
        var stepY = (dy / distance) * spacing;

        for (var i = 0; i < steps; i += 1)
        {
            _brushLastX += stepX;
            _brushLastY += stepY;
            _brushStrokeCount += PlaceBrushStamp(_brushLastX, _brushLastY);
        }

        await DrawAsync();
    }

    private static bool IsPointInPolygon(float x, float y, AreaPolygonDto polygon)
    {
        var inside = false;
        var points = polygon.Points;
        for (var i = 0; i < points.Count; i += 1)
        {
            var j = (i == 0) ? points.Count - 1 : i - 1;
            var xi = points[i].X;
            var yi = points[i].Y;
            var xj = points[j].X;
            var yj = points[j].Y;
            var intersect = ((yi > y) != (yj > y))
                && (x < ((xj - xi) * (y - yi) / (yj - yi + float.Epsilon) + xi));
            if (intersect)
            {
                inside = !inside;
            }
        }

        return inside;
    }

    private static MapPointDto GetPolygonCentroid(IReadOnlyList<MapPointDto> points)
    {
        if (points is null || points.Count == 0)
        {
            return new MapPointDto();
        }

        if (points.Count == 1)
        {
            return new MapPointDto { X = points[0].X, Y = points[0].Y };
        }

        float area = 0f;
        float cx = 0f;
        float cy = 0f;

        for (var i = 0; i < points.Count; i += 1)
        {
            var j = (i + 1) % points.Count;
            var p1 = points[i];
            var p2 = points[j];
            var cross = (p1.X * p2.Y) - (p2.X * p1.Y);
            area += cross;
            cx += (p1.X + p2.X) * cross;
            cy += (p1.Y + p2.Y) * cross;
        }

        area *= 0.5f;
        if (MathF.Abs(area) < 0.001f)
        {
            var avgX = points.Average(point => point.X);
            var avgY = points.Average(point => point.Y);
            return new MapPointDto { X = avgX, Y = avgY };
        }

        var factor = 1f / (6f * area);
        return new MapPointDto { X = cx * factor, Y = cy * factor };
    }

    private MapRenderStateDto BuildRenderState()
    {
        var pointFeatures = new List<MapPointFeatureDto>();
        var titleFeatures = new List<MapTitleFeatureDto>();

        foreach (var tree in _trees)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "Tree",
                X = tree.X,
                Y = tree.Y,
                StyleKey = tree.TreeType,
                IsStaged = false,
                Size = NormalizePointSize(tree.Size)
            });
        }

        foreach (var house in _houses)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "House",
                X = house.X,
                Y = house.Y,
                StyleKey = house.HouseType,
                IsStaged = false,
                Size = NormalizePointSize(house.Size)
            });
        }

        foreach (var tree in _stagedTrees)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "Tree",
                X = tree.X,
                Y = tree.Y,
                StyleKey = tree.TreeType,
                IsStaged = true,
                Size = NormalizePointSize(tree.Size)
            });
        }

        foreach (var house in _stagedHouses)
        {
            pointFeatures.Add(new MapPointFeatureDto
            {
                FeatureType = "House",
                X = house.X,
                Y = house.Y,
                StyleKey = house.HouseType,
                IsStaged = true,
                Size = NormalizePointSize(house.Size)
            });
        }

        foreach (var title in _titles)
        {
            var position = GetTitlePosition(title);
            titleFeatures.Add(new MapTitleFeatureDto
            {
                Id = title.Id,
                Name = title.Name,
                X = position.X,
                Y = position.Y,
                IsStaged = false,
                Size = NormalizeTitleSize(title.Size),
                Points = title.Points
                    .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                    .ToList()
            });
        }

        foreach (var title in _stagedTitles)
        {
            var position = GetTitlePosition(title);
            titleFeatures.Add(new MapTitleFeatureDto
            {
                Id = title.Id,
                Name = title.Name,
                X = position.X,
                Y = position.Y,
                IsStaged = true,
                Size = NormalizeTitleSize(title.Size),
                Points = title.Points
                    .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                    .ToList()
            });
        }

        return new MapRenderStateDto
        {
            PointFeatures = pointFeatures,
            TitleFeatures = titleFeatures,
            AreaLayers = _areaLayers
                .OrderBy(layer => layer.LayerIndex)
                .ToList(),
            AreaPolygons = _waterPolygons
                .Concat(_stagedWaterPolygons)
                .Concat(_landPolygons)
                .Concat(_stagedLandPolygons)
                .OrderBy(polygon => polygon.LayerIndex)
                .ToList(),
            ActivePolygon = _activePolygonPoints.Count >= 1
                ? new AreaPolygonDto
                {
                    FeatureType = IsTitlePlacement(_placementType)
                        ? "Title"
                        : IsPointPlacement(_placementType)
                            ? _placementType.ToString()
                            : GetAreaPlacementFeatureType(),
                    LayerIndex = _activeAreaLayer?.LayerIndex ?? 0,
                    Points = _activePolygonPoints
                        .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                        .ToList()
                }
                : null,
            EditPolygon = _editingPolygon is null
                ? null
                : new AreaPolygonDto
                {
                    FeatureType = _editingPolygon.FeatureType,
                    LayerIndex = _editingPolygon.LayerIndex,
                    Points = _editingPolygon.Points
                        .Select(point => new MapPointDto { X = point.X, Y = point.Y })
                        .ToList()
                },
            EditPointFeature = _editingPointFeature is null
                ? null
                : _editingPointFeature.Tree is not null
                    ? new MapPointFeatureDto
                    {
                        FeatureType = "Tree",
                        X = _editingPointFeature.Tree.X,
                        Y = _editingPointFeature.Tree.Y,
                        StyleKey = _editingPointFeature.Tree.TreeType,
                        IsStaged = _editingPointFeature.IsStaged,
                        Size = NormalizePointSize(_editingPointFeature.Tree.Size)
                    }
                    : _editingPointFeature.House is not null
                        ? new MapPointFeatureDto
                        {
                            FeatureType = "House",
                            X = _editingPointFeature.House.X,
                            Y = _editingPointFeature.House.Y,
                            StyleKey = _editingPointFeature.House.HouseType,
                            IsStaged = _editingPointFeature.IsStaged,
                            Size = NormalizePointSize(_editingPointFeature.House.Size)
                        }
                        : null,
            EditPolygonPointIndex = _editingPointIndex >= 0 ? _editingPointIndex : null,
            EditPolygonEdgeIndex = _editingEdgeIndex >= 0 ? _editingEdgeIndex : null,
            BrushPreview = _activeTool == MapToolType.Brush && _hasBrushCursor
                ? new BrushPreviewDto
                {
                    X = _brushCursorX,
                    Y = _brushCursorY,
                    Radius = GetBrushRadius(),
                    IsActive = _isBrushing
                }
                : null,
            UseChaoticLandEdges = _useChaoticLandEdges,
            ViewState = new MapViewStateDto
            {
                ViewX = _viewX,
                ViewY = _viewY,
                Zoom = _zoom,
                MapWidth = MapWidth,
                MapHeight = MapHeight
            }
        };
    }

    private enum PlacementType
    {
        Tree,
        House,
        Title,
        Land,
        Water
    }

    private enum EraserTarget
    {
        All,
        Tree,
        House,
        Land,
        Water
    }

    private enum MapToolType
    {
        Pointer,
        Point,
        Brush,
        Polygon,
        Eraser,
        Edit,
        Duplicate,
        Undo,
        Redo
    }

    private enum UndoBatchKind
    {
        None,
        Brush,
        Eraser,
        Edit
    }

    private sealed class UndoState
    {
        public List<TreeFeatureDto> Trees { get; init; } = new();
        public List<HouseFeatureDto> Houses { get; init; } = new();
        public List<TitleFeatureDto> Titles { get; init; } = new();
        public List<TreeFeatureDto> StagedTrees { get; init; } = new();
        public List<HouseFeatureDto> StagedHouses { get; init; } = new();
        public List<TitleFeatureDto> StagedTitles { get; init; } = new();
        public List<AreaPolygonDto> WaterPolygons { get; init; } = new();
        public List<AreaPolygonDto> StagedWaterPolygons { get; init; } = new();
        public Dictionary<int, AreaPolygonDto> EditedWaterPolygons { get; init; } = new();
        public HashSet<int> DeletedWaterPolygonIds { get; init; } = new();
        public List<AreaPolygonDto> LandPolygons { get; init; } = new();
        public List<AreaPolygonDto> StagedLandPolygons { get; init; } = new();
        public Dictionary<int, AreaPolygonDto> EditedLandPolygons { get; init; } = new();
        public HashSet<int> DeletedLandPolygonIds { get; init; } = new();
        public Dictionary<int, TreeFeatureDto> EditedTrees { get; init; } = new();
        public Dictionary<int, HouseFeatureDto> EditedHouses { get; init; } = new();
        public Dictionary<int, TitleFeatureDto> EditedTitles { get; init; } = new();
        public HashSet<int> DeletedTreeIds { get; init; } = new();
        public HashSet<int> DeletedHouseIds { get; init; } = new();
        public HashSet<int> DeletedTitleIds { get; init; } = new();
        public List<AreaLayerDto> AreaLayers { get; init; } = new();
        public string? ActiveAreaLayerKey { get; init; }
        public int? ActiveAreaLayerIndex { get; init; }
        public float LastX { get; init; }
        public float LastY { get; init; }
        public bool HasLastPlacement { get; init; }
    }

    private sealed class EditingPointFeature
    {
        public TreeFeatureDto? Tree { get; init; }
        public HouseFeatureDto? House { get; init; }
        public bool IsStaged { get; init; }
    }

    private sealed class EditingTitleFeature
    {
        public TitleFeatureDto Title { get; init; } = new();
        public bool IsStaged { get; init; }
    }

    private sealed record ToolDefinition(MapToolType Tool, string Label, string Description, bool IsImplemented);
    private sealed record PlacementDefinition(PlacementType PlacementType, string Label, string ImageUrl);
    private sealed record EraserTargetDefinition(EraserTarget Target, string Label);
    private sealed record FeatureStyleDefinition(PlacementType PlacementType, string MenuLabel, IReadOnlyList<string> Styles);
    private sealed record CanvasClientSize(float Width, float Height);
}










